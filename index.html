
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="mobile-web-app-capable" content="yes">
<title>Cruza La Frontera - BETA</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
#betaBanner {
  position: fixed; top: 0; left: 0; right: 0; z-index: 99999;
  background: #ff880022; border-bottom: 2px solid #ff8800;
  color: #ffcc44; font: bold 13px monospace; text-align: center;
  padding: 6px 10px; pointer-events: none;
  animation: betaFade 8s forwards;
}
@keyframes betaFade {
  0%, 60% { opacity: 1; }
  100% { opacity: 0; display: none; }
}
html, body {
  background: #000;
  width: 100%;
  height: 100%;
  font-family: 'Segoe UI', Arial, sans-serif;
  overflow: hidden;
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  position: fixed;
  overscroll-behavior: none;
}
canvas {
  display: block;
  position: fixed;
  background: #000;
  touch-action: none;
}
#ui { display: none; }
#splash {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: #000; z-index: 999999;
  display: flex; align-items: center; justify-content: center;
}
#splash.out { animation: splashOut 1s ease-in-out forwards; }
#splash img { max-width: 80vw; max-height: 80vh; width: auto; height: auto; aspect-ratio: 16/9; object-fit: contain; opacity: 0; animation: splashLogoIn 1s ease-in-out forwards; }
@keyframes splashLogoIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes splashOut { from { opacity: 1; } to { opacity: 0; } }
</style>
</head>
<body>
<div id="splash"><img src="splash.png" alt="Logo"></div>
<script>
(function(){
  var s=document.getElementById('splash');
  setTimeout(function(){ s.classList.add('out'); },2500);
  setTimeout(function(){ s.style.display='none'; },3500);
})();
</script>
<div id="betaBanner">BETA VERSION — some stuff might be broken</div>
<div id="ui">
  <h1>CRUZA LA FRONTERA</h1>
  <p>Arrow Keys / WASD to move &amp; jump · Dodge la migra · Climb the border wall!</p>
</div>
<canvas id="game"></canvas>
<video id="deathVideo" playsinline preload="auto" style="display:none"></video>

<input id="hiddenInput" type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="position:fixed;left:0;bottom:0;width:100%;height:40px;opacity:0.01;font-size:16px;z-index:9999;pointer-events:none;" />

<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database-compat.js"></script>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const playerImg = new Image();
playerImg.src = 'player_new.png';
const PLAYER_IMG_SCALE = 1.4;
const guardImg = new Image();
guardImg.src = 'guard_new.png';
const projectileImg = new Image();
projectileImg.src = 'projectile.png';
const bossImg = new Image();
bossImg.src = 'trump5.png';
const bossIntroImg = new Image();
bossIntroImg.src = 'trump_intro.png';
const epsteinImg = new Image();
epsteinImg.src = 'TheBigE.png';
const epsteinFilesImg = new Image();
epsteinFilesImg.src = 'classifed folder.png';
const hawkingImg = new Image();
hawkingImg.src = 'mrstephen.png';
const hawkingGoldImg = new Image();
hawkingGoldImg.src = 'goldenstephen.png';
const clintonImg = new Image();
clintonImg.src = 'guard3_new.png';
const muskImg = new Image();
muskImg.src = 'guard4_new.png';
const girlImg = new Image();
girlImg.src = 'girl.png';
const epProjectileImgs = [];
function setupEpImgs() {
  if (epProjectileImgs.length > 0) return;
  epProjectileImgs.push(epsteinFilesImg, hawkingImg, clintonImg, muskImg, girlImg);
}
setTimeout(setupEpImgs, 500);

const images = {
  guard: guardImg,
  boss: bossImg,
  epstein: epsteinImg,
  clinton: clintonImg,
  musk: muskImg,
  hawking: hawkingImg,
  hawkingGold: hawkingGoldImg,
};

function imgH(img, w) {
  if (img.naturalWidth && img.naturalHeight) return w * (img.naturalHeight / img.naturalWidth);
  return w * 1.3;
}

const W = 1280;
const H = 720;
let GROUND_Y = H - 80;
canvas.width = W;
canvas.height = H;

let canvasScale = 1, canvasOffsetX = 0, canvasOffsetY = 0;
function resizeCanvas() {

  const vv = window.visualViewport;
  const winW = vv ? vv.width : window.innerWidth;
  const winH = vv ? vv.height : window.innerHeight;
  const aspect = W / H;
  let cw, ch;
  if (winW / winH > aspect) {
    ch = winH;
    cw = ch * aspect;
  } else {
    cw = winW;
    ch = cw / aspect;
  }
  canvasScale = cw / W;
  canvasOffsetX = (winW - cw) / 2;
  canvasOffsetY = (winH - ch) / 2;
  canvas.style.left = canvasOffsetX + 'px';
  canvas.style.top = canvasOffsetY + 'px';
  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => {
  setTimeout(resizeCanvas, 150);
  setTimeout(resizeCanvas, 350);
});

if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', resizeCanvas);
}

document.addEventListener('touchmove', e => {
  if (e.target === canvas || e.target === document.body || e.target === document.documentElement) {
    e.preventDefault();
  }
}, { passive: false });

function clientToCanvas(clientX, clientY) {
  return {
    x: (clientX - canvasOffsetX) / canvasScale,
    y: (clientY - canvasOffsetY) / canvasScale
  };
}

const GRAVITY = 0.55;
const PLAYER_SPEED = 5.0;
const JUMP_FORCE = -12.5;
const WALL_CLIMB_SPEED = 3.8;

let state = 'menu';
let cameraX = 0;
let cameraY = 0;
let levelWidth = 4000;
let particles = [];
let projectiles = [];
let bullets = [];
let boss = null;
let bossMinions = [];
let arenaPlats = [];
let bossVfx = [];
let bossDeathTimer = 0;
let screenFlash = 0;
let screenFlashColor = '#fff';

let mpToasts = [];
function showToast(text, color = '#ffffff') {
  mpToasts.push({ text, life: 180, color });
  if (mpToasts.length > 5) mpToasts.shift();
}
let bossIntroTimer = 0;
let mouseX = 0;
let mouseY = 0;
let mouseActive = false;
let shakeTimer = 0;
let epstein = null;
let phonecallTimer = 0;
let epsteinProjectiles = [];
let fusionBoss = null;
let fusionCutsceneTimer = 0;
let miniBosses = [];
let restartCooldown = 0;

let deathAnimTimer = 0;
let deathAnimVideoPlaying = false;
const _deathVid = document.getElementById('deathVideo');
_deathVid.src = 'data:video/mp4;base64,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AAMAAAMAAAMAAAMAAAMAAAMACyiAIQAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHshEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3p4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHcAAAAhAakHyLf/AAADAAADAAADAAADAAADAAADAAADAAADAO6YIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHoAAAAjIeRKIVf//IQAAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMAK24hEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3p4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHUhEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACEBqY/It/8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMA7pghEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3p4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAjIeZqITf/+lgAAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMAVUwhEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdSEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACEBqhfIl/8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMBF3AhEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfQAAACMh6IohF//6WAAAAwAAAwAAAwAAAwAAAwAAAwAAAwAAAwBVTCEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdiEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADenAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAByAAAAIAGqn8nfAAADAAADAAADAAADAAADAAADAAADAAADAS9wIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABzAAAAIiHqqiPf8yAAAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMAz6ghEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdQAAACABqyfJXwAAAwAAAwAAAwAAAwAAAwAAAwAAAwAAAwGVECEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcyEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADenAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+AAAA5CHsyiNf5EAAAAMAAAMAAAMAAA+oZkua6+KW0YNjKKKAmTj+J/RGZ4ziYWYs8hiho2x6+u+layghwI8DBDMncCn2aaGblHXaewjd4U8pJGzgPTpOC6z4SEXNbrJj7x+cbDhaApLKALDaFUNYMpBKfPEY14KqiVuthBuKAJ3gDw6H504suFol9sqCPsFeu0QYM1y9heFi8rWJgto8RcZ4eYgtzn/sb1tBcaGHSr4aS/BeElUFdODE3atbhAD/JaAKUPdQ8qIZz36COVfvewpgdUNfWY7H8ojdRI6QAAADAAADAACDsiEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAegAAACIBq6/LfwAAAwAAAwAAAwAACxzzDDW4GPgAAAMAAAMAAMWoIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHchEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3p4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHoAAAAiIe7qIt+HAAADAAADAAADAAADAAADAAADAAADAAADAAmagCEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADenAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB6AAAAIAGsN83/AAADAAADAAADAAADAAADAAADAAADAAADAekQIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdQAAACABrt/N/wAAAwAAAwAAAwAAAwAAAwAAAwAAAwAAAwHpECEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcQAAACEh+6o3/wAAAwAAAwAAAwAAAwAAAwAAAwAAAwAAAwAB/uAhEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfgAAACABr2fN/wAAAwAAAwAAAwAAAwAAAwAAAwAAAwAAAwHpECEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfSEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADenAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABzAAAAISH9yjf/AAADAAADAAADAAADAAADAAADAAADAAADAAH+4CEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcQAAACABr+/N/wAAAwAAAwAAAwAAAwAAAwAAAwAAAwAAAwHpECEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADenAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABzIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8AAAAISH/6jf/AAADAAADAAADAAADAAADAAADAAADAAADAAH+4CEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADenAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB6AAAAIAGod83/AAADAAADAAADAAADAAADAAADAAADAAADAekQIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4IRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH4AAAAhIeAKN/8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMAAf7gIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABxAAAAIAGo/83/AAADAAADAAADAAADAAADAAADAAADAAADAekQIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHMAAAAhIeIqN/8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMAAf7gIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB5IRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHoAAAAgAakHzf8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMB6RAhEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3p4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHIAAAAhIeRKN/8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMAAf7gIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH4hEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3p4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEAAAAgAamPzf8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMB6RAhEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3p4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHsAAAAhIeZqN/8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMAAf7gIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH4hEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3p4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH0AAAAgAaoXzf8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMB6RAhEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdgAAACEh6Io3/wAAAwAAAwAAAwAAAwAAAwAAAwAAAwAAAwAB/uAhEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3p4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQAAAAgAaqfzf8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMB6RAhEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAciEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdwAAACEh6qo3/wAAAwAAAwAAAwAAAwAAAwAAAwAAAwAAAwAB/uAhEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcgAAACABqyfN/wAAAwAAAwAAAwAAAwAAAwAAAwAAAwAAAwHpECEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfCEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADenAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+AAAAISHsyjf/AAADAAADAAADAAADAAADAAADAAADAAADAAH+4CEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfwAAACABq6/N/wAAAwAAAwAAAwAAAwAAAwAAAwAAAwAAAwHpECEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADenAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAByIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABxAAAAISHu6jf/AAADAAADAAADAAADAAADAAADAAADAAADAAH+4CEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADenAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABxAAAAIAGsN83/AAADAAADAAADAAADAAADAAADAAADAAADAekQIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB0IRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHkAAAAhIfEKN/8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMAAf7gIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2AAAAIAGsv83/AAADAAADAAADAAADAAADAAADAAADAAADAekQIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAhIfMaN/8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMAAf7gIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAByIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHYAAAAhIfUqN/8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMAAf7gIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB7AAAAISH3Ojf/AAADAAADAAADAAADAAADAAADAAADAAAD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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3mIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAhIfEaN/8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMAAf7gIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB6IRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcQAAACMBqwvN/wAAAwAAAwAIkqV5hyH/4SgAAAMAAAMAAAMAAATNECEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADenAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2IRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAByIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHIAAAAhIfSaN/8AAAMAAAMAAAMAAAMAAAMAAAMAAAMAAAMAAf7gIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAHEhEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3p4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH8AAAAlAa+/zf8AAAMAAAMAAAMAkSugZ9gzg7SBnigAAAMAAAMAACkkgAAAAAEKIRAFAKAb/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN6cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHMhEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3p4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQhEAUAoBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfyEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcSEQBQCgG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADenAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB3';
function initDeathAnim() {
  deathAnimTimer = 0;
  deathAnimVideoPlaying = false;
  _deathVid.currentTime = 0;
}

let hawkingRefusalTimer = 0;
let hawkingRefusalPhase = 0;
let hawkingPhase2 = false;
let hawkingDeathTimer = 0;
let hawkingDeathPhase = 0;
let winCutsceneTimer = 0;
let winCutsceneOfficeX = 0;

let introTimer = 0;
let introPhase = 0;
let introParticles = [];

let endless = {
  round: 0,
  enemies: [],
  spawnsLeft: 0,
  spawnTimer: 0,
  totalKills: 0,
  roundTimer: 0,
  intermission: false,
  intermissionTimer: 0,
  arenaW: 2400,
  arenaH: 900,
  roofY: 0,
  roofTimer: 0,
  endlessZoom: 1,
  arenaX: 0,
  arenaY: 0,
  platforms: [],

  powerups: {
    dmgBoost: 0,
    speedBoost: 0,
    maxHpBoost: 0,
    regenBoost: 0,
    projSpeed: 0,
    multiShot: 0,
    cooldownReduce: 0,
    vampirism: 0,
    shield: 0,
    thorns: 0,
    explosiveShot: 0,
    dash: 0,
    freezeAura: 0,
    luckyDrop: 0,
    critChance: 0,
    magnetism: 0,
    lastStand: 0,
    heavyImpact: 0,
  },
  shieldCharges: 0,
  dashCooldown: 0,
  shopChoices: [],
  shopSelection: 0,
  shopPicked: false,
  boss: null,
  bossActive: false,
  modifier: null,
  highScore: parseInt(localStorage.getItem('endlessHighScore') || '0'),
};

const ENDLESS_POWERUP_DEFS = {
  dmgBoost:       { name: 'DAMAGE UP',      icon: 'sword',   desc: '+20% throwable damage',        max: 8, color: '#ff4444' },
  speedBoost:     { name: 'SPEED UP',        icon: 'wind',    desc: '+12% movement speed',          max: 8, color: '#44aaff' },
  maxHpBoost:     { name: 'TOUGHNESS',       icon: 'heart',   desc: '+5 max HP (heals too)',         max: 10, color: '#ff88aa' },
  regenBoost:     { name: 'REGENERATION',    icon: 'cross',   desc: 'Regen HP over time',            max: 5, color: '#44ff88' },
  projSpeed:      { name: 'ARM STRENGTH',    icon: 'arm',     desc: '+15% throw speed',              max: 8, color: '#ffaa44' },
  multiShot:      { name: 'MULTI-THROW',     icon: 'target',  desc: '+1 extra projectile',           max: 5, color: '#ff44ff' },
  cooldownReduce: { name: 'QUICK HANDS',     icon: 'bolt',    desc: '-15% throw cooldown',           max: 6, color: '#ffff44' },
  vampirism:      { name: 'VAMPIRISM',       icon: 'fangs',   desc: 'Heal on enemy kill',            max: 5, color: '#aa44ff' },
  shield:         { name: 'ENERGY SHIELD',   icon: 'shield',  desc: 'Block 1 hit per round',         max: 5, color: '#44ddff' },
  thorns:         { name: 'THORNS',          icon: 'thorns',  desc: 'Reflect damage to attackers',   max: 5, color: '#ff8844' },
  explosiveShot:  { name: 'EXPLOSIVE SHOT',  icon: 'boom',    desc: 'Projectiles explode on hit',    max: 3, color: '#ff6622' },
  dash:           { name: 'DODGE ROLL',      icon: 'dash',    desc: 'Double-tap to dash',            max: 3, color: '#88ffcc' },
  freezeAura:     { name: 'FREEZE AURA',     icon: 'snow',    desc: 'Slow nearby enemies',           max: 3, color: '#88ccff' },
  luckyDrop:      { name: 'LUCKY DROPS',     icon: 'star',    desc: 'Enemies drop HP pickups',       max: 5, color: '#ffdd44' },

  critChance:     { name: 'CRITICAL HIT',    icon: 'crit',    desc: '15% chance for 2x damage',      max: 5, color: '#ff2222' },
  magnetism:      { name: 'MAGNETISM',       icon: 'magnet',  desc: 'Pull HP pickups from further',  max: 3, color: '#dd44dd' },
  lastStand:      { name: 'LAST STAND',      icon: 'skull',   desc: '+50% dmg when below 25% HP',    max: 3, color: '#ff0066' },
  heavyImpact:    { name: 'HEAVY IMPACT',    icon: 'hammer',  desc: 'Projectiles stun enemies',      max: 3, color: '#cc8844' },
};

function drawEndlessIcon(ctx, type, cx, cy, size, color) {
  ctx.save();
  ctx.fillStyle = color || '#fff';
  ctx.strokeStyle = color || '#fff';
  ctx.lineWidth = 2;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  const s = size / 2;
  switch(type) {
    case 'sword': {
      ctx.lineWidth = Math.max(2, size / 10);
      ctx.beginPath();
      ctx.moveTo(cx - s*0.7, cy + s*0.7); ctx.lineTo(cx + s*0.7, cy - s*0.7);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx + s*0.7, cy + s*0.7); ctx.lineTo(cx - s*0.7, cy - s*0.7);
      ctx.stroke();

      ctx.lineWidth = Math.max(1.5, size / 14);
      ctx.beginPath();
      ctx.moveTo(cx - s*0.35, cy - s*0.15); ctx.lineTo(cx + s*0.05, cy + s*0.25);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx - s*0.05, cy - s*0.25); ctx.lineTo(cx + s*0.35, cy + s*0.15);
      ctx.stroke();
      break;
    }
    case 'wind': {
      ctx.lineWidth = Math.max(2, size / 12);
      for (let i = 0; i < 3; i++) {
        const yOff = (i - 1) * s * 0.55;
        const xOff = i === 1 ? 0 : s * 0.15;
        ctx.beginPath();
        ctx.moveTo(cx - s*0.7 + xOff, cy + yOff);
        ctx.lineTo(cx + s*0.5, cy + yOff);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(cx + s*0.5, cy + yOff);
        ctx.lineTo(cx + s*0.25, cy + yOff - s*0.2);
        ctx.moveTo(cx + s*0.5, cy + yOff);
        ctx.lineTo(cx + s*0.25, cy + yOff + s*0.2);
        ctx.stroke();
      }
      break;
    }
    case 'heart': {
      ctx.beginPath();
      const hy = cy - s * 0.05;
      ctx.moveTo(cx, hy + s * 0.75);
      ctx.bezierCurveTo(cx - s*1.0, hy + s*0.15, cx - s*0.9, hy - s*0.65, cx, hy - s*0.2);
      ctx.bezierCurveTo(cx + s*0.9, hy - s*0.65, cx + s*1.0, hy + s*0.15, cx, hy + s*0.75);
      ctx.fill();
      break;
    }
    case 'cross': {
      const cw = s * 0.3;
      ctx.fillRect(cx - cw, cy - s*0.7, cw*2, s*1.4);
      ctx.fillRect(cx - s*0.7, cy - cw, s*1.4, cw*2);
      break;
    }
    case 'arm': {
      ctx.lineWidth = Math.max(2.5, size / 8);
      ctx.beginPath();
      ctx.moveTo(cx - s*0.5, cy + s*0.6);
      ctx.quadraticCurveTo(cx - s*0.6, cy, cx - s*0.15, cy - s*0.1);
      ctx.quadraticCurveTo(cx + s*0.3, cy - s*0.8, cx + s*0.15, cy + s*0.1);
      ctx.lineTo(cx + s*0.55, cy - s*0.45);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(cx + s*0.55, cy - s*0.5, s*0.18, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'target': {
      ctx.lineWidth = Math.max(1.5, size / 14);
      ctx.beginPath(); ctx.arc(cx, cy, s*0.8, 0, Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(cx, cy, s*0.5, 0, Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(cx, cy, s*0.2, 0, Math.PI*2); ctx.fill();

      ctx.beginPath();
      ctx.moveTo(cx, cy - s*0.9); ctx.lineTo(cx, cy + s*0.9);
      ctx.moveTo(cx - s*0.9, cy); ctx.lineTo(cx + s*0.9, cy);
      ctx.stroke();
      break;
    }
    case 'bolt': {
      ctx.beginPath();
      ctx.moveTo(cx + s*0.15, cy - s*0.85);
      ctx.lineTo(cx - s*0.35, cy + s*0.05);
      ctx.lineTo(cx + s*0.08, cy + s*0.05);
      ctx.lineTo(cx - s*0.15, cy + s*0.85);
      ctx.lineTo(cx + s*0.35, cy - s*0.05);
      ctx.lineTo(cx - s*0.08, cy - s*0.05);
      ctx.closePath();
      ctx.fill();
      break;
    }
    case 'fangs': {
      ctx.beginPath();

      ctx.moveTo(cx - s*0.45, cy - s*0.25);
      ctx.lineTo(cx - s*0.28, cy + s*0.65);
      ctx.lineTo(cx - s*0.1, cy - s*0.25);
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(cx + s*0.1, cy - s*0.25);
      ctx.lineTo(cx + s*0.28, cy + s*0.65);
      ctx.lineTo(cx + s*0.45, cy - s*0.25);
      ctx.fill();

      ctx.beginPath();
      ctx.arc(cx, cy - s*0.1, s*0.6, 0, Math.PI, false);
      ctx.lineWidth = Math.max(1.5, size / 14);
      ctx.stroke();
      break;
    }
    case 'star': {
      ctx.beginPath();
      for (let i = 0; i < 10; i++) {
        const r = i % 2 === 0 ? s*0.85 : s*0.38;
        const angle = (i * Math.PI / 5) - Math.PI / 2;
        const px = cx + Math.cos(angle) * r;
        const py = cy + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      break;
    }
    case 'shield': {
      ctx.beginPath();
      ctx.moveTo(cx, cy - s*0.8);
      ctx.lineTo(cx + s*0.7, cy - s*0.4);
      ctx.lineTo(cx + s*0.6, cy + s*0.3);
      ctx.lineTo(cx, cy + s*0.8);
      ctx.lineTo(cx - s*0.6, cy + s*0.3);
      ctx.lineTo(cx - s*0.7, cy - s*0.4);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = Math.max(1, size / 16);
      ctx.stroke();
      break;
    }
    case 'thorns': {
      ctx.beginPath();
      for (let i = 0; i < 12; i++) {
        const r2 = i % 2 === 0 ? s*0.8 : s*0.45;
        const angle = (i * Math.PI / 6) - Math.PI / 2;
        const px = cx + Math.cos(angle) * r2;
        const py = cy + Math.sin(angle) * r2;
        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      break;
    }
    case 'boom': {
      ctx.beginPath();
      ctx.arc(cx, cy, s*0.3, 0, Math.PI*2);
      ctx.fill();
      ctx.lineWidth = Math.max(2, size / 10);
      for (let i = 0; i < 8; i++) {
        const angle = i * Math.PI / 4;
        ctx.beginPath();
        ctx.moveTo(cx + Math.cos(angle) * s*0.4, cy + Math.sin(angle) * s*0.4);
        ctx.lineTo(cx + Math.cos(angle) * s*0.85, cy + Math.sin(angle) * s*0.85);
        ctx.stroke();
      }
      break;
    }
    case 'dash': {
      ctx.lineWidth = Math.max(2.5, size / 8);
      ctx.beginPath();
      ctx.moveTo(cx - s*0.7, cy + s*0.2);
      ctx.quadraticCurveTo(cx - s*0.1, cy + s*0.2, cx + s*0.5, cy - s*0.1);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx + s*0.5, cy - s*0.1);
      ctx.lineTo(cx + s*0.15, cy - s*0.35);
      ctx.moveTo(cx + s*0.5, cy - s*0.1);
      ctx.lineTo(cx + s*0.2, cy + s*0.2);
      ctx.stroke();

      ctx.lineWidth = Math.max(1.5, size / 14);
      for (let i = 0; i < 3; i++) {
        const yy = cy - s*0.3 + i * s*0.3;
        ctx.beginPath();
        ctx.moveTo(cx - s*0.85, yy);
        ctx.lineTo(cx - s*0.45, yy);
        ctx.stroke();
      }
      break;
    }
    case 'snow': {
      ctx.lineWidth = Math.max(1.5, size / 12);
      for (let i = 0; i < 6; i++) {
        const angle = i * Math.PI / 3;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        const ex = cx + Math.cos(angle) * s*0.8;
        const ey = cy + Math.sin(angle) * s*0.8;
        ctx.lineTo(ex, ey);
        ctx.stroke();

        const mx = cx + Math.cos(angle) * s*0.5;
        const my = cy + Math.sin(angle) * s*0.5;
        ctx.beginPath();
        ctx.moveTo(mx, my);
        ctx.lineTo(mx + Math.cos(angle + 0.7) * s*0.25, my + Math.sin(angle + 0.7) * s*0.25);
        ctx.moveTo(mx, my);
        ctx.lineTo(mx + Math.cos(angle - 0.7) * s*0.25, my + Math.sin(angle - 0.7) * s*0.25);
        ctx.stroke();
      }
      break;
    }
    case 'crit': {
      ctx.lineWidth = Math.max(2.5, size / 8);
      ctx.beginPath();
      ctx.moveTo(cx - s*0.4, cy - s*0.6); ctx.lineTo(cx + s*0.4, cy + s*0.6);
      ctx.moveTo(cx + s*0.4, cy - s*0.6); ctx.lineTo(cx - s*0.4, cy + s*0.6);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx, cy, s*0.2, 0, Math.PI*2);
      ctx.fill();
      break;
    }
    case 'magnet': {
      ctx.lineWidth = Math.max(2.5, size / 8);
      ctx.beginPath();
      ctx.arc(cx, cy + s*0.1, s*0.5, Math.PI, 0, false);
      ctx.stroke();
      ctx.fillRect(cx - s*0.55, cy + s*0.05, s*0.2, s*0.55);
      ctx.fillRect(cx + s*0.35, cy + s*0.05, s*0.2, s*0.55);

      ctx.fillStyle = '#ff4444';
      ctx.fillRect(cx - s*0.55, cy + s*0.5, s*0.2, s*0.15);
      ctx.fillRect(cx + s*0.35, cy + s*0.5, s*0.2, s*0.15);
      break;
    }
    case 'skull': {
      ctx.beginPath();
      ctx.arc(cx, cy - s*0.15, s*0.55, 0, Math.PI*2);
      ctx.fill();
      ctx.fillRect(cx - s*0.4, cy + s*0.2, s*0.8, s*0.35);

      ctx.fillStyle = '#000';
      ctx.beginPath(); ctx.arc(cx - s*0.2, cy - s*0.15, s*0.13, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + s*0.2, cy - s*0.15, s*0.13, 0, Math.PI*2); ctx.fill();

      ctx.fillRect(cx - s*0.25, cy + s*0.3, s*0.1, s*0.2);
      ctx.fillRect(cx - s*0.05, cy + s*0.3, s*0.1, s*0.2);
      ctx.fillRect(cx + s*0.15, cy + s*0.3, s*0.1, s*0.2);
      break;
    }
    case 'hammer': {
      ctx.fillRect(cx - s*0.1, cy - s*0.1, s*0.2, s*0.9);
      ctx.fillRect(cx - s*0.45, cy - s*0.7, s*0.9, s*0.45);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = Math.max(1, size / 16);
      ctx.strokeRect(cx - s*0.45, cy - s*0.7, s*0.9, s*0.45);
      break;
    }
  }
  ctx.restore();
}

const ENDLESS_ENEMY_TIERS = [

  { type: 'guard',   imgKey: 'guard',   color: '#888',    w: 48, h: 72,  baseHp: 2, baseSpeed: 1.0, shootCd: 120, dmg: 1 },

  { type: 'guard2',  imgKey: 'guard',   color: '#aa6622', w: 48, h: 72,  baseHp: 3, baseSpeed: 1.4, shootCd: 90,  dmg: 1 },

  { type: 'clinton', imgKey: 'clinton', color: '#cc2222', w: 60, h: 80,  baseHp: 6, baseSpeed: 1.8, shootCd: 70,  dmg: 2 },

  { type: 'musk',    imgKey: 'musk',    color: '#4488ff', w: 60, h: 80,  baseHp: 8, baseSpeed: 2.2, shootCd: 60,  dmg: 2 },

  { type: 'epstein', imgKey: 'epstein', color: '#8844ff', w: 70, h: 100, baseHp: 12, baseSpeed: 1.8, shootCd: 50, dmg: 3 },

  { type: 'trump',   imgKey: 'boss',    color: '#ff4400', w: 80, h: 110, baseHp: 16, baseSpeed: 1.5, shootCd: 45, dmg: 3 },

  { type: 'hawking', imgKey: 'hawking', color: '#44ff88', w: 80, h: 110, baseHp: 25, baseSpeed: 1.2, shootCd: 40, dmg: 4 },
];

function startEndless() {
  state = 'endless';
  endless.round = Math.max(0, endlessStartRound - 1);
  endless.enemies = [];
  endless.totalKills = 0;
  endless.roundTimer = 0;
  endless.intermission = false;
  endless.intermissionTimer = 0;
  endless.shopChoices = [];
  endless.shopSelection = 0;
  endless.boss = null;
  endless.bossActive = false;
  endless.modifier = null;

  for (const k in endless.powerups) endless.powerups[k] = 0;
  endless.shieldCharges = 0;
  endless.dashCooldown = 0;

  const aW = endless.arenaW;
  const aH = endless.arenaH;
  endless.arenaX = 200;
  endless.arenaY = GROUND_Y - aH;
  endless.roofY = 0;
  endless.roofTimer = 0;
  endless.endlessZoom = 1;
  endless.platforms = endlessGeneratePlatforms(endless.arenaX, endless.arenaY, aW, aH, 0);

  const dm = getDiffMult();
  player.x = endless.arenaX + aW / 2 - player.w / 2;
  player.y = endless.arenaY + aH - player.h - 10;
  player.hp = dm.playerHp;
  player.maxHp = dm.playerHp;
  player.alive = true;
  player.won = false;
  player.vx = 0;
  player.vy = 0;
  player.onGround = true;
  player.facing = 1;
  player.iFrames = 60;

  moveJoystick.active = false; moveJoystick.touchId = null; moveJoystick.dx = 0; moveJoystick.dy = 0; moveJoystick.inJumpUp = false;
  touchAim.active = false; aimTouchId = null; touchControls.left = false; touchControls.right = false; touchControls.up = false;
  particles = [];
  projectiles = [];
  bullets = [];
  bossMinions = [];
  bossVfx = [];
  epsteinProjectiles = [];

  bigWall = null;
  boss = null;
  epstein = null;
  fusionBoss = null;
  guards = [];
  miniBosses = [];

  cameraX = endless.arenaX + aW / 2 - W / 2;
  cameraY = 0;
  levelWidth = endless.arenaX + aW + 200;
  gameTimer = 0;

  endlessNextRound();
}

function endlessGeneratePlatforms(arenaX, arenaY, aW, aH, round) {

  const plats = [
    { x: arenaX, y: arenaY + aH, w: aW, h: 30, isFloor: true },
    { x: arenaX - 30, y: arenaY, w: 30, h: aH + 30, isSideWall: true },
    { x: arenaX + aW, y: arenaY, w: 30, h: aH + 30, isSideWall: true },
  ];

  const layout = round % 5;
  if (layout === 0) {

    plats.push(
      { x: arenaX + 100,          y: arenaY + aH - 140, w: 200, h: 14, isPlatform: true },
      { x: arenaX + aW - 300,     y: arenaY + aH - 140, w: 200, h: 14, isPlatform: true },
      { x: arenaX + aW/2 - 120,   y: arenaY + aH - 280, w: 240, h: 14, isPlatform: true },
      { x: arenaX + 250,          y: arenaY + aH - 400, w: 160, h: 14, isPlatform: true },
      { x: arenaX + aW - 410,     y: arenaY + aH - 400, w: 160, h: 14, isPlatform: true },
      { x: arenaX + aW/2 - 100,   y: arenaY + aH - 540, w: 200, h: 14, isPlatform: true },
      { x: arenaX + aW/2 - 80,    y: arenaY + aH - 700, w: 160, h: 14, isPlatform: true },
      { x: arenaX + 80,           y: arenaY + aH - 560, w: 140, h: 14, isPlatform: true },
      { x: arenaX + aW - 220,     y: arenaY + aH - 560, w: 140, h: 14, isPlatform: true },
    );
  } else if (layout === 1) {

    plats.push(
      { x: arenaX + 60,           y: arenaY + aH - 120, w: 180, h: 14, isPlatform: true },
      { x: arenaX + 320,          y: arenaY + aH - 220, w: 180, h: 14, isPlatform: true },
      { x: arenaX + 580,          y: arenaY + aH - 320, w: 180, h: 14, isPlatform: true },
      { x: arenaX + 840,          y: arenaY + aH - 420, w: 180, h: 14, isPlatform: true },
      { x: arenaX + 1100,         y: arenaY + aH - 520, w: 180, h: 14, isPlatform: true },
      { x: arenaX + 1360,         y: arenaY + aH - 620, w: 180, h: 14, isPlatform: true },
      { x: arenaX + 1620,         y: arenaY + aH - 720, w: 180, h: 14, isPlatform: true },
      { x: arenaX + 1900,         y: arenaY + aH - 500, w: 200, h: 14, isPlatform: true },
      { x: arenaX + 2100,         y: arenaY + aH - 300, w: 180, h: 14, isPlatform: true },
    );
  } else if (layout === 2) {

    plats.push(
      { x: arenaX + 150,          y: arenaY + aH - 180, w: 160, h: 14, isPlatform: true },
      { x: arenaX + 500,          y: arenaY + aH - 140, w: 200, h: 14, isPlatform: true },
      { x: arenaX + 900,          y: arenaY + aH - 200, w: 160, h: 14, isPlatform: true },
      { x: arenaX + 1350,         y: arenaY + aH - 160, w: 200, h: 14, isPlatform: true },
      { x: arenaX + 1800,         y: arenaY + aH - 180, w: 180, h: 14, isPlatform: true },
      { x: arenaX + 2100,         y: arenaY + aH - 250, w: 160, h: 14, isPlatform: true },
      { x: arenaX + 300,          y: arenaY + aH - 380, w: 180, h: 14, isPlatform: true },
      { x: arenaX + 700,          y: arenaY + aH - 420, w: 200, h: 14, isPlatform: true },
      { x: arenaX + 1100,         y: arenaY + aH - 460, w: 180, h: 14, isPlatform: true },
      { x: arenaX + 1550,         y: arenaY + aH - 400, w: 200, h: 14, isPlatform: true },
      { x: arenaX + 2000,         y: arenaY + aH - 450, w: 160, h: 14, isPlatform: true },
      { x: arenaX + aW/2 - 100,   y: arenaY + aH - 650, w: 200, h: 14, isPlatform: true },
    );
  } else if (layout === 3) {

    plats.push(
      { x: arenaX + 350,          y: arenaY + aH - 150, w: 180, h: 14, isPlatform: true },
      { x: arenaX + 350,          y: arenaY + aH - 320, w: 180, h: 14, isPlatform: true },
      { x: arenaX + 350,          y: arenaY + aH - 490, w: 180, h: 14, isPlatform: true },
      { x: arenaX + 350,          y: arenaY + aH - 660, w: 180, h: 14, isPlatform: true },
      { x: arenaX + aW - 530,     y: arenaY + aH - 150, w: 180, h: 14, isPlatform: true },
      { x: arenaX + aW - 530,     y: arenaY + aH - 320, w: 180, h: 14, isPlatform: true },
      { x: arenaX + aW - 530,     y: arenaY + aH - 490, w: 180, h: 14, isPlatform: true },
      { x: arenaX + aW - 530,     y: arenaY + aH - 660, w: 180, h: 14, isPlatform: true },
      { x: arenaX + aW/2 - 120,   y: arenaY + aH - 400, w: 240, h: 14, isPlatform: true },
      { x: arenaX + aW/2 - 100,   y: arenaY + aH - 750, w: 200, h: 14, isPlatform: true },
    );
  } else {

    plats.push(
      { x: arenaX + aW/2 - 100,   y: arenaY + aH - 140, w: 200, h: 14, isPlatform: true },
      { x: arenaX + aW/2 - 350,   y: arenaY + aH - 300, w: 180, h: 14, isPlatform: true },
      { x: arenaX + aW/2 + 170,   y: arenaY + aH - 300, w: 180, h: 14, isPlatform: true },
      { x: arenaX + aW/2 - 500,   y: arenaY + aH - 460, w: 180, h: 14, isPlatform: true },
      { x: arenaX + aW/2 + 320,   y: arenaY + aH - 460, w: 180, h: 14, isPlatform: true },
      { x: arenaX + aW/2 - 350,   y: arenaY + aH - 620, w: 180, h: 14, isPlatform: true },
      { x: arenaX + aW/2 + 170,   y: arenaY + aH - 620, w: 180, h: 14, isPlatform: true },
      { x: arenaX + aW/2 - 100,   y: arenaY + aH - 780, w: 200, h: 14, isPlatform: true },
      { x: arenaX + 60,           y: arenaY + aH - 200, w: 160, h: 14, isPlatform: true },
      { x: arenaX + aW - 220,     y: arenaY + aH - 200, w: 160, h: 14, isPlatform: true },
    );
  }
  return plats;
}

const ENDLESS_BOSS_ROUNDS = {
  10:  { name: 'EL CAPITAN',     color: '#ff8800', w: 100, h: 130, hp: 80,  speed: 1.5, dmg: 3, attacks: ['charge','slam'],       imgKey: 'boss' },
  25:  { name: 'THE KINGPIN',    color: '#ff44ff', w: 110, h: 140, hp: 200, speed: 1.8, dmg: 4, attacks: ['charge','slam','summon'], imgKey: 'epstein' },
  50:  { name: 'LA SOMBRA',      color: '#44ffaa', w: 120, h: 150, hp: 500, speed: 2.0, dmg: 5, attacks: ['charge','slam','summon','barrage'], imgKey: 'hawking' },
  75:  { name: 'DOBLE MUERTE',   color: '#ff4444', w: 100, h: 130, hp: 350, speed: 2.2, dmg: 4, attacks: ['charge','slam','barrage'], imgKey: 'boss', count: 2 },
  100: { name: 'EL DIABLO',      color: '#ffd700', w: 220, h: 270, hp: 1000,speed: 2.5, dmg: 6, attacks: ['charge','slam','summon','barrage','laser'], imgKey: 'hawkingGold' },
  150: { name: 'THE TRIBUNAL',   color: '#ff2222', w: 110, h: 140, hp: 600, speed: 2.0, dmg: 5, attacks: ['charge','slam','summon','barrage'], imgKey: 'boss', count: 3 },
  200: { name: 'GOD EMPEROR',    color: '#ffffff', w: 320, h: 400, hp: 2500,speed: 3.0, dmg: 8, attacks: ['charge','slam','summon','barrage','laser'], imgKey: 'hawkingGold' },
};

const ENDLESS_ROUND_MODIFIERS = [
  { name: 'SWARM',      desc: 'Double enemies, half HP!',   chance: 0.14, minRound: 4 },
  { name: 'ARMORED',    desc: 'Enemies have 2x HP!',        chance: 0.11, minRound: 5 },
  { name: 'BLITZ',      desc: 'Enemies are faster!',        chance: 0.11, minRound: 3 },
  { name: 'MARKSMAN',   desc: 'Enemies shoot more!',        chance: 0.10, minRound: 6 },
  { name: 'DARKNESS',   desc: 'Limited visibility!',        chance: 0.08, minRound: 8 },
  { name: 'GIANTS',     desc: 'Enemies are 1.5x bigger!',   chance: 0.09, minRound: 7 },
  { name: 'REGEN',      desc: 'Enemies slowly heal!',       chance: 0.08, minRound: 9 },
  { name: 'GRAVITY',    desc: 'Low gravity!',               chance: 0.10, minRound: 4 },
];

function endlessIsBossRound(round) {
  return ENDLESS_BOSS_ROUNDS[round] !== undefined;
}

function endlessNextRound() {
  state = 'endless';
  endless.round++;
  endless.roundTimer = 0;
  endless.intermission = false;
  endless.boss = null;
  endless.bossActive = false;
  endless.modifier = null;
  endless.roofY = 0;
  endless.roofTimer = 0;

  if (mpEnabled && !player.alive) {
    player.alive = true;
    player.hp = player.maxHp;
    player.iFrames = 90;
    mpSpectating = false;
    mpDeathSynced = false;

    player.x = endless.arenaX + endless.arenaW / 2 - player.w / 2;
    player.y = endless.arenaY + endless.arenaH - player.h - 10;
    player.vy = 0; player.vx = 0;
    spawnParticles(player.x + player.w/2, player.y + player.h/2, '#44ff88', 15);
    showToast('Revived! New round starting', '#44ff88');
  }

  endless.platforms = endlessGeneratePlatforms(endless.arenaX, endless.arenaY, endless.arenaW, endless.arenaH, endless.round);

  if (endless.powerups.shield > 0) {
    endless.shieldCharges = endless.powerups.shield;
  }

  endless.dashCooldown = 0;

  const r = endless.round;

  bullets = [];
  epsteinProjectiles = [];

  if (endlessIsBossRound(r)) {
    const def = ENDLESS_BOSS_ROUNDS[r];
    const hpScale = 1 + (r - 10) * 0.05;
    const bossCount = def.count || 1;
    endless.bossActive = true;
    endless.spawnsLeft = 0;
    endless.enemies = [];

    for (let bi = 0; bi < bossCount; bi++) {
      const bossHp = Math.ceil(def.hp * hpScale / (bossCount > 1 ? 1.3 : 1));
      const aX = endless.arenaX, aW = endless.arenaW, aH = endless.arenaH;
      const floorY = endless.arenaY + aH;
      const spawnX = bossCount > 1
        ? aX + (aW / (bossCount + 1)) * (bi + 1) - def.w / 2
        : aX + aW / 2 - def.w / 2;

      endless.enemies.push({
        x: spawnX, y: floorY - def.h - 2,
        w: def.w, h: def.h,
        hp: bossHp, maxHp: bossHp,
        speed: def.speed,
        dir: bi % 2 === 0 ? -1 : 1,
        type: 'boss',
        imgKey: def.imgKey,
        color: def.color,
        frame: 0, frameTimer: 0,
        vy: 0, dead: false,
        shootCooldown: 60,
        attackTimer: 120 + bi * 40,
        dmg: def.dmg,
        iFrames: 0,
        isBoss: true,
        bossName: bossCount > 1 ? `${def.name} ${bi + 1}` : def.name,
        attacks: def.attacks,
        currentAttack: null,
        chargeVx: 0,
        slamming: false,
        charging: false,
        summonCooldown: 300,
        barrageCooldown: 200,
      });
    }

    screenFlash = 40;
    screenFlashColor = def.color + '88';
    shakeTimer = 30;
    return;
  }

  const baseCount = 2 + Math.floor(r * 0.8) + Math.floor(r / 5);
  endless.spawnsLeft = Math.min(baseCount, 25);
  endless.spawnTimer = 40;

  if (r >= 3 && !endlessIsBossRound(r)) {
    for (const mod of ENDLESS_ROUND_MODIFIERS) {
      if (r >= mod.minRound && Math.random() < mod.chance) {
        endless.modifier = mod;

        if (mod.name === 'SWARM') {
          endless.spawnsLeft = Math.min(endless.spawnsLeft * 2, 40);
        }
        break;
      }
    }
  }
}

function endlessGenerateShop() {
  const pu = endless.powerups;

  const available = Object.keys(ENDLESS_POWERUP_DEFS).filter(k => pu[k] < ENDLESS_POWERUP_DEFS[k].max);

  if (available.length === 0) {
    endlessNextRound();
    return;
  }

  const choices = [];
  const pool = [...available];

  for (let i = pool.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [pool[i], pool[j]] = [pool[j], pool[i]]; }
  for (let i = 0; i < 3 && i < pool.length; i++) choices.push(pool[i]);

  endless.shopChoices = choices;
  endless.shopSelection = 0;
}

function endlessApplyPowerup(key) {
  const pu = endless.powerups;
  const def = ENDLESS_POWERUP_DEFS[key];
  if (!def) return;
  if (pu[key] >= def.max) return;
  pu[key]++;

  if (key === 'maxHpBoost') {
    player.maxHp += 5;
    player.hp = Math.min(player.hp + 5, player.maxHp);
  }
  if (key === 'shield') {

    endless.shieldCharges = pu.shield;
  }
}

function endlessGetEnemyForRound(round) {

  const tierWeights = [];
  for (let t = 0; t < ENDLESS_ENEMY_TIERS.length; t++) {
    const tier = ENDLESS_ENEMY_TIERS[t];

    const unlockRound = t * 2 + 1;
    if (round >= unlockRound) {

      const w = Math.max(1, round - unlockRound + 1);
      tierWeights.push({ tier: t, weight: w });
    }
  }

  const totalW = tierWeights.reduce((s, tw) => s + tw.weight, 0);
  let roll = Math.random() * totalW;
  let pickedTier = 0;
  for (const tw of tierWeights) {
    roll -= tw.weight;
    if (roll <= 0) { pickedTier = tw.tier; break; }
  }
  return ENDLESS_ENEMY_TIERS[pickedTier];
}

function endlessSpawnEnemy() {
  const r = endless.round;
  const template = endlessGetEnemyForRound(r);
  const aX = endless.arenaX, aW = endless.arenaW, aH = endless.arenaH;
  const floorY = endless.arenaY + aH;

  let hpScale = 1 + r * 0.08;
  let spdScale = 1 + r * 0.02;

  if (endless.modifier) {
    if (endless.modifier.name === 'SWARM') hpScale *= 0.5;
    if (endless.modifier.name === 'ARMORED') hpScale *= 2;
    if (endless.modifier.name === 'BLITZ') spdScale *= 1.5;
  }
  const hp = Math.ceil(template.baseHp * hpScale);

  const side = Math.random() > 0.5 ? 1 : -1;
  const sx = side > 0 ? aX + aW - template.w - 10 : aX + 10;

  const sizeScale = (endless.modifier && endless.modifier.name === 'GIANTS') ? 1.5 : 1;

  const enemy = {
    x: sx,
    y: floorY - Math.floor(template.h * sizeScale) - 2,
    w: Math.floor(template.w * sizeScale), h: Math.floor(template.h * sizeScale),
    hp: hp, maxHp: hp,
    speed: template.baseSpeed * spdScale,
    dir: side > 0 ? -1 : 1,
    type: template.type,
    imgKey: template.imgKey,
    color: template.color,
    frame: 0, frameTimer: 0,
    vy: 0,
    dead: false,
    shootCooldown: template.shootCd + Math.floor(Math.random() * 30),
    attackTimer: 0,
    dmg: template.dmg,
    iFrames: 0,
  };

  if (endless.modifier && endless.modifier.name === 'MARKSMAN') {
    enemy.shootCooldown = Math.floor(enemy.shootCooldown * 0.5);
  }
  endless.enemies.push(enemy);
}

let menuState = 'main';
let menuSelection = 0;

let cheats = {
  godMode: false,
  oneHitKill: false,
  infiniteJumps: false,
  speedBoost: false,
  bigProjectiles: false,
  noCooldown: false,
};
let endlessStartRound = 1;
let cheatSelection = 0;
let menuBgRunners = [];
let menuBgBullets = [];
let menuBgTimer = 0;
let menuBgFloorY = 0;

let settings = {
  difficulty: 'normal',
  screenShake: true,
  particles: true,
  showFPS: false,
  musicVolume: 80,
  sfxVolume: 100,
  touchButtons: true,
  doubleJump: true,
  showTimer: false,
  colorblind: false,
};

let _perfPromptShown = localStorage.getItem('perfPromptDismissed') === 'true';
let _showPerfPrompt = false;

(function checkPerfPrompt() {
  if (_perfPromptShown) return;
  const isTouch = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
  const isIpad = /iPad|Macintosh/i.test(navigator.userAgent) && navigator.maxTouchPoints > 1;
  const isMobile = /iPhone|Android|webOS|iPod/i.test(navigator.userAgent);
  if (isTouch || isIpad || isMobile) {
    _showPerfPrompt = true;
  }
})();
function _acceptPerfMode() {
  settings.particles = false;
  settings.screenShake = false;
  _showPerfPrompt = false;
  _perfPromptShown = true;
  localStorage.setItem('perfPromptDismissed', 'true');
}
function _declinePerfMode() {
  _showPerfPrompt = false;
  _perfPromptShown = true;
  localStorage.setItem('perfPromptDismissed', 'true');
}

const _isBetaSite = window.location.pathname.includes('borderbeta');
let _showBetaPopup = _isBetaSite;
if (!_isBetaSite) { const bb = document.getElementById('betaBanner'); if (bb) bb.style.display = 'none'; }
window._betaOkBtn = null;
function _dismissBetaPopup() { _showBetaPopup = false; }

const TOUCH_PRESETS = {
  default: { name: 'Default', moveX: 140, moveY: 600, moveR: 70, aimX: 1140, aimY: 600, aimR: 70 },
  lefty:   { name: 'Lefty',   moveX: 1140, moveY: 600, moveR: 70, aimX: 140, aimY: 600, aimR: 70 },
  compact: { name: 'Compact', moveX: 100, moveY: 640, moveR: 50, aimX: 1180, aimY: 640, aimR: 50 },
  spread:  { name: 'Spread',  moveX: 160, moveY: 540, moveR: 80, aimX: 1120, aimY: 540, aimR: 80 },
  high:    { name: 'High',    moveX: 140, moveY: 480, moveR: 65, aimX: 1140, aimY: 480, aimR: 65 },
};
let touchLayout = Object.assign({}, TOUCH_PRESETS.default);
let touchPresetName = 'default';

(function loadTouchLayout() {
  try {
    const saved = localStorage.getItem('touchLayout');
    if (saved) {
      const parsed = JSON.parse(saved);
      touchLayout = Object.assign({}, TOUCH_PRESETS.default, parsed);
    }
    const savedPreset = localStorage.getItem('touchPreset');
    if (savedPreset) touchPresetName = savedPreset;
  } catch(e) {}
})();
function saveTouchLayout() {
  localStorage.setItem('touchLayout', JSON.stringify(touchLayout));
  localStorage.setItem('touchPreset', touchPresetName);
}

let tcDragging = null;
let tcResizing = null;
let tcDragOffX = 0, tcDragOffY = 0;
let tutorialPage = 0;
let tutorialDone = localStorage.getItem('tutorialDone') === 'true';
function completeTutorial() {
  tutorialDone = true;
  localStorage.setItem('tutorialDone', 'true');
  if (currentUser) {
    db.ref('users/' + currentUser.uid + '/tutorialDone').set(true);
  }
  startGame();
}
let gameTimer = 0;

function getPlayerCountMult() {
  if (!mpEnabled) return 1;
  const count = Math.max(1, Object.keys(roomPlayers).length);

  if (count === 1) return 1;
  if (count === 2) return 1.8;
  if (count === 3) return 2.4;
  return 3;
}
function getDiffMult() {
  const pm = getPlayerCountMult();
  switch(settings.difficulty) {
    case 'easy': return { dmg: 0.5 * pm, enemyHp: 0.7 * pm, enemySpeed: 0.85, playerHp: 20, projSpeed: 0.75 };
    case 'normal': return { dmg: 1.0 * pm, enemyHp: 1.0 * pm, enemySpeed: 1.0, playerHp: 15, projSpeed: 1.0 };
    case 'hard': return { dmg: 1.5 * pm, enemyHp: 1.4 * pm, enemySpeed: 1.2, playerHp: 12, projSpeed: 1.2 };
    case 'insane': return { dmg: 2.2 * pm, enemyHp: 1.8 * pm, enemySpeed: 1.45, playerHp: 8, projSpeed: 1.45 };
    default: return { dmg: 1.0 * pm, enemyHp: 1.0 * pm, enemySpeed: 1.0, playerHp: 15, projSpeed: 1.0 };
  }
}

function initMenuBg() {
  menuBgFloorY = H - 100;
  menuBgRunners = [];
  menuBgBullets = [];
  menuBgTimer = 0;

  for (let i = 0; i < 3; i++) {
    menuBgRunners.push({
      x: 100 + i * 250, y: menuBgFloorY - 60,
      w: 40, h: 60, vy: 0,
      onGround: true, frame: 0, frameTimer: 0,
      jumpTimer: 60 + Math.floor(Math.random() * 80),
    });
  }
}
initMenuBg();

const firebaseConfig = {
  apiKey: "AIzaSyDRKmh2UiXCV8qXw7Ugq-H5I5Phz5Bu720",
  authDomain: "border-f1340.firebaseapp.com",
  projectId: "border-f1340",
  storageBucket: "border-f1340.firebasestorage.app",
  messagingSenderId: "755794545025",
  appId: "1:755794545025:web:ca32b027df866d6a900080",
  databaseURL: "https://border-f1340-default-rtdb.firebaseio.com",
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();

let currentUser = null;
let playerUsername = '';
let authError = '';
let authScreen = 'login';
let authInputField = 0;
let authInputs = { username: '', password: '', confirm: '' };
let authLoading = false;

let mpEnabled = false;
let isHost = false;
let currentRoom = null;
let roomRef = null;
let roomPlayers = {};
let roomChat = [];
let chatInput = '';
let chatOpen = false;
let mpSyncTimer = 0;
let lastSyncData = '';
let mpEnemyData = {};
let joinRoomInput = '';
let mpMenuSelection = 0;
let mpGameStarted = false;

let friendsList = [];
let friendRequests = [];
let blockedUsers = [];
let friendInput = '';
let friendMenuSelection = 0;
let friendTab = 0;
let authSuccessMsg = '';
let friendsBackTo = 'main';
let mpDeathSynced = false;
let mpDamageQueueRef = null;
let mpSpectating = false;
let mpSpectateTarget = null;
let mpSpectateIndex = 0;
let mpRetryVotes = {};
let mpRetrySelection = 0;
let mpMatchSettings = null;
let mpSettingsSelection = 0;
let mpGameMode = 'story';

function getAlivePlayerList() {
  const alive = [];
  const uid = myUid();
  for (const pid in roomPlayers) {
    if (pid === uid) continue;
    const rp = roomPlayers[pid];
    if (rp && rp.alive && rp.hp > 0) alive.push({ uid: pid, ...rp });
  }
  return alive;
}

function handlePlayerDeath() {
  const p = player;
  if (!p.alive) return;
  p.alive = false;
  p.hp = 0;
  p.iFrames = 99999;
  shakeTimer = 15;
  spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4444', 25);
  restartCooldown = 40;
  if (mpEnabled) {
    syncMyPositionImmediate();
    mpDeathSynced = true;
    const alive = getAlivePlayerList();
    if (alive.length > 0) {

      mpSpectating = true;
      mpSpectateIndex = 0;
      mpSpectateTarget = alive[0].uid;
      if (state === 'endless' || state === 'endlessShop') {
        showToast('You died! You\'ll respawn next round.', '#ff6644');
      }
    } else {

      initDeathAnim();
      state = 'deathAnim';
      mpSpectating = false;
    }
  } else {

    initDeathAnim();
    state = 'deathAnim';
  }
}

let activeTextInput = null;
let textCursorBlink = 0;

const _hiddenInput = document.getElementById('hiddenInput');
function _focusHiddenInput(inputType) {
  if (!_hiddenInput) return;
  const cur = _getTextInputValue(inputType);
  _hiddenInput.value = cur || '';
  _hiddenInput.setAttribute('maxlength', inputType === 'chat' ? '100' : inputType === 'roomcode' ? '6' : '20');
  _hiddenInput.type = (inputType === 'password' || inputType === 'confirm') ? 'password' : 'text';
  _hiddenInput.style.pointerEvents = 'auto';

  _hiddenInput.focus();

  setTimeout(() => { if (document.activeElement !== _hiddenInput) _hiddenInput.focus(); }, 100);
}
function _blurHiddenInput() {
  if (!_hiddenInput) return;
  _hiddenInput.blur();
  _hiddenInput.style.pointerEvents = 'none';
}
function _getTextInputValue(type) {
  if (type === 'username') return authInputs.username;
  if (type === 'password') return authInputs.password;
  if (type === 'confirm') return authInputs.confirm;
  if (type === 'chat') return chatInput;
  if (type === 'roomcode') return joinRoomInput;
  if (type === 'friendadd') return friendInput;
  return '';
}
function _setTextInputValue(type, v) {
  if (type === 'username') authInputs.username = v;
  else if (type === 'password') authInputs.password = v;
  else if (type === 'confirm') authInputs.confirm = v;
  else if (type === 'chat') chatInput = v;
  else if (type === 'roomcode') joinRoomInput = v;
  else if (type === 'friendadd') friendInput = v;
}
function activateTextInput(type) {
  activeTextInput = type;
  _focusHiddenInput(type);
}
function deactivateTextInput() {
  activeTextInput = null;
  _blurHiddenInput();
}

if (_hiddenInput) {
  _hiddenInput.addEventListener('input', () => {
    if (!activeTextInput) return;
    let val = _hiddenInput.value;

    if (activeTextInput === 'username') val = val.replace(/[^a-zA-Z0-9_\-]/g, '');
    if (activeTextInput === 'roomcode') val = val.toUpperCase();
    const maxLen = activeTextInput === 'chat' ? 100 : activeTextInput === 'roomcode' ? 6 : 20;
    val = val.slice(0, maxLen);
    _hiddenInput.value = val;
    _setTextInputValue(activeTextInput, val);
  });
  _hiddenInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      if (activeTextInput === 'chat') { sendChatMessage(); chatOpen = false; deactivateTextInput(); }
      else if (activeTextInput === 'roomcode') { joinRoom(joinRoomInput); deactivateTextInput(); }
      else if (activeTextInput === 'friendadd') { addFriend(friendInput); deactivateTextInput(); }
      else if (activeTextInput === 'username' || activeTextInput === 'password' || activeTextInput === 'confirm') {
        if (authScreen === 'register') registerAccount(authInputs.username, authInputs.password);
        else loginAccount(authInputs.username, authInputs.password);
        deactivateTextInput();
      }
      else { deactivateTextInput(); }
    }
  });
}

window.addEventListener('keydown', e => {
  if (!activeTextInput) return;
  e.preventDefault();
  e.stopPropagation();
  if (e.key === 'Escape') {
    if (activeTextInput === 'chat') chatOpen = false;
    deactivateTextInput();
    return;
  }
  let cur = _getTextInputValue(activeTextInput);
  const maxLen = activeTextInput === 'chat' ? 100 : activeTextInput === 'roomcode' ? 6 : 20;
  if (e.key === 'Backspace') { _setTextInputValue(activeTextInput, cur.slice(0, -1)); if (_hiddenInput) _hiddenInput.value = _getTextInputValue(activeTextInput); }
  else if (e.key === 'Tab') {
    if (activeTextInput === 'username') activateTextInput('password');
    else if (activeTextInput === 'password') activateTextInput(authScreen === 'register' ? 'confirm' : 'username');
    else if (activeTextInput === 'confirm') activateTextInput('username');
  }
  else if (e.key === 'Enter') {
    if (activeTextInput === 'chat') { sendChatMessage(); chatOpen = false; deactivateTextInput(); }
    else if (activeTextInput === 'roomcode') { joinRoom(joinRoomInput); deactivateTextInput(); }
    else if (activeTextInput === 'friendadd') { addFriend(friendInput); deactivateTextInput(); }
    else if (activeTextInput === 'username' || activeTextInput === 'password' || activeTextInput === 'confirm') {
      if (authScreen === 'register') registerAccount(authInputs.username, authInputs.password);
      else loginAccount(authInputs.username, authInputs.password);
      deactivateTextInput();
    }
    else { deactivateTextInput(); }
  }
  else if (e.key.length === 1 && cur.length < maxLen) {
    if (activeTextInput === 'username') {
      if (/^[a-zA-Z0-9_\-]$/.test(e.key)) _setTextInputValue(activeTextInput, cur + e.key);
    }
    else if (activeTextInput === 'roomcode') _setTextInputValue(activeTextInput, cur + e.key.toUpperCase());
    else _setTextInputValue(activeTextInput, cur + e.key);
    if (_hiddenInput) _hiddenInput.value = _getTextInputValue(activeTextInput);
  }
}, true);

async function registerAccount(username, password) {
  if (authLoading) return;
  if (!username || username.length < 2) { authError = 'Username must be at least 2 characters!'; return; }
  if (!password || password.length < 6) { authError = 'Password must be at least 6 characters!'; return; }
  if (authInputs.confirm !== password) { authError = 'Passwords do not match!'; return; }
  authLoading = true;
  authError = '';
  try {
    const email = username.toLowerCase() + '@gmail.com';
    const cred = await auth.createUserWithEmailAndPassword(email, password);
    await cred.user.updateProfile({ displayName: username });
    currentUser = cred.user;
    playerUsername = username;

    await db.ref('users/' + cred.user.uid).set({
      username: username,
      online: true,
      lastSeen: firebase.database.ServerValue.TIMESTAMP,
      friends: {},
      blocked: {},
    });
    authScreen = 'main';
    menuState = 'multiplayer';
    mpMenuSelection = 0;
    authLoading = false;
  } catch (err) {
    authError = err.message.replace('Firebase: ', '').replace(/\(auth\/.*\)/, '').trim();
    if (authError.includes('email-already-in-use')) authError = 'Username already taken!';
    authLoading = false;
  }
}

async function loginAccount(username, password) {
  if (authLoading) return;
  if (!username || !password) { authError = 'Enter username and password!'; return; }
  authLoading = true;
  authError = '';
  try {
    const email = username.toLowerCase() + '@gmail.com';
    const cred = await auth.signInWithEmailAndPassword(email, password);
    currentUser = cred.user;
    playerUsername = cred.user.displayName || username;
    await db.ref('users/' + cred.user.uid + '/online').set(true);
    await db.ref('users/' + cred.user.uid + '/lastSeen').set(firebase.database.ServerValue.TIMESTAMP);
    authScreen = 'main';
    menuState = 'multiplayer';
    mpMenuSelection = 0;
    authLoading = false;
    loadFriendsList();
  } catch (err) {
    authError = err.message.replace('Firebase: ', '').replace(/\(auth\/.*\)/, '').trim();
    if (authError.includes('user-not-found') || authError.includes('invalid-credential')) authError = 'Wrong username or password!';
    authLoading = false;
  }
}

function logoutAccount() {
  if (currentUser) {
    db.ref('users/' + currentUser.uid + '/online').set(false);
    if (currentRoom) leaveRoom();
  }
  auth.signOut();
  currentUser = null;
  playerUsername = '';
  _myUid = null;
  friendsList = [];
  friendRequests = [];
  blockedUsers = [];
  authInputs = { username: '', password: '', confirm: '' };
  authError = '';
  authSuccessMsg = '';
  menuState = 'multiplayer';
  mpMenuSelection = 0;
}

function playAsGuest() {
  playerUsername = 'Guest_' + Math.floor(Math.random() * 9999);
  currentUser = null;
  authInputs = { username: '', password: '', confirm: '' };
  authScreen = 'main';
  menuState = 'multiplayer';
  mpMenuSelection = 0;
}

auth.onAuthStateChanged(user => {
  if (user) {
    currentUser = user;
    playerUsername = user.displayName || 'Player';
    db.ref('users/' + user.uid + '/online').set(true);
    db.ref('users/' + user.uid + '/online').onDisconnect().set(false);
    db.ref('users/' + user.uid + '/lastSeen').onDisconnect().set(firebase.database.ServerValue.TIMESTAMP);

    db.ref('users/' + user.uid + '/tutorialDone').once('value', snap => {
      if (snap.val() === true) {
        tutorialDone = true;
        localStorage.setItem('tutorialDone', 'true');
      }
    });
    loadFriendsList();
  }
});

function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

async function createRoom() {
  if (!playerUsername) return;
  const code = generateRoomCode();
  currentRoom = code;
  isHost = true;
  mpEnabled = true;
  mpGameStarted = false;
  roomChat = [];
  roomPlayers = {};

  const uid = myUid();
  roomRef = db.ref('rooms/' + code);
  await roomRef.set({
    host: uid,
    hostName: playerUsername,
    state: 'lobby',
    created: firebase.database.ServerValue.TIMESTAMP,
    players: {
      [uid]: {
        username: playerUsername,
        ready: false,
        alive: true,
        x: 80, y: 560, hp: 15, maxHp: 15, facing: 1,
      }
    },
    chat: {},
    enemies: {},
  });

  setupRoomListeners(code, uid);
  menuState = 'lobby';
}

async function joinRoom(code) {
  if (!playerUsername || !code || code.length !== 6) { authError = 'Enter a valid 6-letter code!'; return; }
  code = code.toUpperCase();
  try {
    const snap = await db.ref('rooms/' + code).once('value');
    if (!snap.exists()) { authError = 'Room not found!'; return; }
    const roomData = snap.val();
    if (roomData.state !== 'lobby') { authError = 'Game already started!'; return; }
    const playerCount = roomData.players ? Object.keys(roomData.players).length : 0;
    if (playerCount >= 4) { authError = 'Room is full! (max 4 players)'; return; }

    currentRoom = code;
    isHost = false;
    mpEnabled = true;
    mpGameStarted = false;
    roomChat = [];
    roomPlayers = {};

    const uid = myUid();
    roomRef = db.ref('rooms/' + code);
    await roomRef.child('players/' + uid).set({
      username: playerUsername,
      ready: false,
      alive: true,
      x: 80, y: 560, hp: 15, maxHp: 15, facing: 1,
    });

    setupRoomListeners(code, uid);
    menuState = 'lobby';
  } catch (err) {
    authError = 'Failed to join room!';
  }
}

let _myUid = null;
function myUid() {
  if (currentUser) return currentUser.uid;
  if (!_myUid) {
    _myUid = sessionStorage.getItem('guestUid');
    if (!_myUid) {
      _myUid = 'guest_' + Math.floor(Math.random() * 99999);
      sessionStorage.setItem('guestUid', _myUid);
    }
  }
  return _myUid;
}

function setupRoomListeners(code, uid) {
  const roomR = db.ref('rooms/' + code);

  let _wasConnected = true;
  const connRef = db.ref('.info/connected');
  const _connHandler = connRef.on('value', snap => {
    const connected = snap.val() === true;
    if (_wasConnected && !connected) {
      showToast('Connection lost — reconnecting...', '#ffaa00');
    } else if (!_wasConnected && connected) {
      showToast('Reconnected!', '#44ff88');
    }
    _wasConnected = connected;
  });
  window._mpConnRef = connRef;
  window._mpConnHandler = _connHandler;

  let _prevPlayerIds = new Set();
  roomR.child('players').on('value', snap => {
    const data = snap.val() || {};
    const newIds = new Set(Object.keys(data));
    const myId = myUid();

    for (const pid of newIds) {
      if (!_prevPlayerIds.has(pid) && _prevPlayerIds.size > 0 && pid !== myId) {
        const name = data[pid]?.username || 'Player';
        showToast(name + ' joined', '#44ff88');
      }
    }

    for (const pid of _prevPlayerIds) {
      if (!newIds.has(pid) && pid !== myId) {
        const name = roomPlayers[pid]?.username || 'Player';
        showToast(name + ' disconnected', '#ff6644');
      }
    }
    _prevPlayerIds = newIds;

    for (const pid in data) {
      if (roomPlayers[pid] && roomPlayers[pid]._dx !== undefined) {
        data[pid]._dx = roomPlayers[pid]._dx;
        data[pid]._dy = roomPlayers[pid]._dy;
      } else {
        data[pid]._dx = data[pid].x;
        data[pid]._dy = data[pid].y;
      }
    }
    roomPlayers = data;
  });

  roomR.child('chat').orderByChild('time').limitToLast(50).on('child_added', snap => {
    const msg = snap.val();
    if (msg) roomChat.push(msg);
    if (roomChat.length > 50) roomChat.shift();
  });

  roomR.child('state').on('value', snap => {
    const st = snap.val();
    if (st === 'playing' && !mpGameStarted) {
      mpGameStarted = true;
      if (mpGameMode === 'endless') { startEndless(); } else { startGame(); }
    }
    if (st === 'playing' && mpGameStarted && (state === 'won' || state === 'dead')) {

      mpRetryVotes = {};
      if (mpGameMode === 'endless') { startEndless(); } else { startGame(); }
    }
    if (st === 'restarting') {

      mpRetryVotes = {};
    }
  });

  roomR.child('retry').on('value', snap => {
    mpRetryVotes = snap.val() || {};
  });

  if (!isHost) {
    roomR.child('enemies').on('value', snap => {
      mpEnemyData = snap.val() || {};
    });

    roomR.child('matchSettings').on('value', snap => {
      const ms = snap.val();
      if (ms) {
        mpMatchSettings = ms;

        if (ms.difficulty) settings.difficulty = ms.difficulty;
        if (ms.cheats) {
          for (const k in ms.cheats) {
            if (k in cheats) cheats[k] = ms.cheats[k];
          }
        }
        if (typeof ms.doubleJump === 'boolean') settings.doubleJump = ms.doubleJump;
        if (ms.gameMode) mpGameMode = ms.gameMode;
      }
    });
  }

  if (!isHost) {
    let _hostGraceTimeout = null;
    roomR.child('host').on('value', snap => {
      if (!snap.exists() && currentRoom === code) {

        if (!_hostGraceTimeout) {
          _hostGraceTimeout = setTimeout(() => {

            roomR.child('host').once('value', snap2 => {
              if (!snap2.exists() && currentRoom === code) {
                authError = 'Host left the room!';
                leaveRoom();
              }
              _hostGraceTimeout = null;
            });
          }, 5000);
        }
      } else {

        if (_hostGraceTimeout) {
          clearTimeout(_hostGraceTimeout);
          _hostGraceTimeout = null;
        }
      }
    });
  }

  if (isHost) {
    mpDamageQueueRef = roomR.child('damageQueue');
    mpDamageQueueRef.on('child_added', snap => {
      const dmg = snap.val();
      if (dmg) mpHandleDamageEvent(dmg);
      snap.ref.remove();
    });

    roomR.child('cutsceneAdvance').on('child_added', snap => {
      const evt = snap.val();
      if (evt) {
        if (evt.type === 'advance') {
          advanceCutscene();
        } else if (evt.type === 'skip') {

          if (state === 'cutscene') { cutscene.phase = 3; cutscene.fadeAlpha = 1; cutscene.timer = 0; }
          else if (state === 'fusioncutscene') { fusionCutsceneTimer = 1; }
          else if (state === 'phonecall') { phonecallTimer = 1; }
          else if (state === 'hawkingRefusal') { hawkingRefusalTimer = 1129; }
          else if (state === 'hawkingDeath') { hawkingDeathTimer = 899; }
          else if (state === 'winCutscene') { winCutsceneTimer = 699; }
          else if (state === 'bossdialogue') { bossDialogue.index = bossDialogue.texts.length; advanceCutscene(); }
        }
      }
      snap.ref.remove();
    });

    roomR.child('shopPicks').on('value', snap => {
      const picks = snap.val();
      if (!picks || state !== 'endlessShop') return;

      const playerUids = Object.keys(roomPlayers);
      const allPicked = playerUids.every(uid => picks[uid]);
      if (allPicked && playerUids.length > 0) {

        for (const uid of playerUids) {
          if (picks[uid]) endlessApplyPowerup(picks[uid]);
        }
        snap.ref.remove();
        endless.shopPicked = false;
        endlessNextRound();
      }
    });
  }

  roomR.child('players/' + uid).onDisconnect().remove();

  if (isHost) {
    roomR.child('host').onDisconnect().remove();
  }

  const _visHandler = () => {
    if (document.visibilityState === 'visible' && currentRoom) {
      const uid2 = myUid();
      if (!uid2) return;
      const rr = db.ref('rooms/' + currentRoom);

      rr.child('players/' + uid2).update({ alive: player ? player.alive : true });
      rr.child('players/' + uid2).onDisconnect().remove();
      if (isHost) {
        rr.child('host').set(uid2);
        rr.child('host').onDisconnect().remove();
      }
    }
  };
  document.addEventListener('visibilitychange', _visHandler);

  window._mpVisHandler = _visHandler;
}

async function leaveRoom() {
  if (!currentRoom) return;
  const uid = myUid();

  if (window._mpVisHandler) {
    document.removeEventListener('visibilitychange', window._mpVisHandler);
    window._mpVisHandler = null;
  }

  if (window._mpConnRef && window._mpConnHandler) {
    window._mpConnRef.off('value', window._mpConnHandler);
    window._mpConnRef = null;
    window._mpConnHandler = null;
  }
  try {
    await db.ref('rooms/' + currentRoom + '/players/' + uid).remove();

    if (isHost) {
      await db.ref('rooms/' + currentRoom).remove();
    }
  } catch(e) {}
  if (roomRef) {
    roomRef.child('players').off();
    roomRef.child('chat').off();
    roomRef.child('state').off();
    roomRef.child('enemies').off();
    roomRef.child('host').off();
    roomRef.child('damageQueue').off();
    roomRef.child('cutsceneAdvance').off();
    roomRef.child('retry').off();
    roomRef.child('matchSettings').off();
    roomRef.off();
  }
  currentRoom = null;
  roomRef = null;
  mpEnabled = false;
  isHost = false;
  roomPlayers = {};
  roomChat = [];
  mpGameStarted = false;
  chatOpen = false;
  chatInput = '';
  deactivateTextInput();
  lastSyncData = '';
  mpSyncTimer = 0;
  mpEnemySyncTimer = 0;
  mpEnemyData = {};
  mpDeathSynced = false;
  mpSpectating = false;
  mpSpectateTarget = null;
  mpSpectateIndex = 0;
  mpRetryVotes = {};
  mpRetrySelection = 0;
  mpMatchSettings = null;

  moveJoystick.active = false; moveJoystick.touchId = null; moveJoystick.dx = 0; moveJoystick.dy = 0; moveJoystick.inJumpUp = false;
  touchAim.active = false; aimTouchId = null; touchControls.left = false; touchControls.right = false; touchControls.up = false;
  menuState = 'multiplayer';
  mpMenuSelection = 0;
}

async function startMultiplayerGame() {
  if (!isHost || !currentRoom) return;
  chatOpen = false;
  chatInput = '';
  deactivateTextInput();

  await db.ref('rooms/' + currentRoom + '/matchSettings').set({
    difficulty: settings.difficulty,
    cheats: cheats,
    doubleJump: settings.doubleJump,
    gameMode: mpGameMode,
  });
  await db.ref('rooms/' + currentRoom + '/state').set('playing');
  mpGameStarted = true;
  if (mpGameMode === 'endless') { startEndless(); } else { startGame(); }
}

function sendChatMessage() {
  if (!currentRoom || !chatInput.trim()) return;
  db.ref('rooms/' + currentRoom + '/chat').push({
    username: playerUsername,
    text: chatInput.trim(),
    time: firebase.database.ServerValue.TIMESTAMP,
  });
  chatInput = '';
}

function syncMyPositionImmediate() {

  if (!mpEnabled || !currentRoom || !player) return;
  const uid = myUid();
  db.ref('rooms/' + currentRoom + '/players/' + uid).update({
    alive: player.alive,
    hp: player.hp,
    x: Math.round(player.x),
    y: Math.round(player.y),
    facing: player.facing,
  });
}

function syncMyPosition() {
  if (!mpEnabled || !currentRoom || !player) return;
  const now = Date.now();
  if (now - _lastSyncTime < 50) return;
  _lastSyncTime = now;

  const uid = myUid();
  const data = {
    username: playerUsername,
    x: Math.round(player.x),
    y: Math.round(player.y),
    hp: player.hp,
    maxHp: player.maxHp,
    facing: player.facing,
    alive: player.alive,
    runFrame: player.runFrame,
    climbingBigWall: player.climbingBigWall,
    iFrames: player.iFrames,
    throwCooldown: player.throwCooldown,
  };

  if (projectiles.length > 0) {
    data.projectiles = projectiles.map(pj => ({
      x: Math.round(pj.x), y: Math.round(pj.y),
      vx: Math.round(pj.vx * 10) / 10, vy: Math.round(pj.vy * 10) / 10,
      w: pj.w, h: pj.h
    }));
  } else {
    data.projectiles = null;
  }
  const dataStr = JSON.stringify(data);
  if (dataStr === lastSyncData) return;
  lastSyncData = dataStr;

  db.ref('rooms/' + currentRoom + '/players/' + uid).update(data);
}

let mpEnemySyncTimer = 0;
function syncEnemyData() {
  if (!mpEnabled || !isHost || !currentRoom) return;
  const now = Date.now();
  if (now - _lastEnemySyncTime < 50) return;
  _lastEnemySyncTime = now;

  const enemies = {};

  enemies.guards = guards.map(g => ({
    x: Math.round(g.x), y: Math.round(g.y), dir: g.dir,
    hp: g.hp, maxHp: g.maxHp, dead: g.dead,
    alert: g.alert, frame: g.frame, climbing: g.climbing,
    w: g.w, h: g.h
  }));

  if (boss) {
    enemies.boss = {
      x: Math.round(boss.x), y: Math.round(boss.y), w: boss.w, h: boss.h,
      hp: boss.hp, maxHp: boss.maxHp, dir: boss.dir, dead: boss.dead,
      phase: boss.phase, frame: boss.frame, alert: boss.alert,
      charging: boss.charging, slamming: boss.slamming,
      chargeVx: boss.chargeVx, speed: boss.speed, vy: boss.vy,
      _slamShock: boss._slamShock || 0
    };
  }

  if (epstein) {
    enemies.epstein = {
      x: Math.round(epstein.x), y: Math.round(epstein.y), w: epstein.w, h: epstein.h,
      hp: epstein.hp, maxHp: epstein.maxHp, dir: epstein.dir, dead: epstein.dead,
      phase: epstein.phase, frame: epstein.frame,
      charging: epstein.charging, chargeVx: epstein.chargeVx
    };
  }

  if (fusionBoss) {
    enemies.fusion = {
      x: Math.round(fusionBoss.x), y: Math.round(fusionBoss.y), w: fusionBoss.w, h: fusionBoss.h,
      hp: fusionBoss.hp, maxHp: fusionBoss.maxHp, dir: fusionBoss.dir, dead: fusionBoss.dead,
      phase: fusionBoss.phase, frame: fusionBoss.frame,
      charging: fusionBoss.charging, chargeVx: fusionBoss.chargeVx, mergeGlow: fusionBoss.mergeGlow,
      _slamShock: fusionBoss._slamShock || 0
    };
  }

  if (miniBosses.length > 0) {
    enemies.minis = miniBosses.map(mb => ({
      x: Math.round(mb.x), y: Math.round(mb.y), w: mb.w, h: mb.h,
      hp: mb.hp, maxHp: mb.maxHp, dead: mb.dead, dir: mb.dir,
      name: mb.name, color: mb.color, frame: mb.frame, speed: mb.speed, vy: mb.vy,
      imgKey: mb.imgKey,
      _slamShock: mb._slamShock || 0,
      _gravPull: mb._gravPull || null
    }));
  }

  if (bossMinions.length > 0) {
    enemies.bossMinions = bossMinions.map(m => ({
      x: Math.round(m.x), y: Math.round(m.y), w: m.w, h: m.h,
      hp: m.hp, maxHp: m.maxHp, dead: m.dead, dir: m.dir, speed: m.speed, frame: m.frame
    }));
  }

  if (bullets.length > 0) {
    enemies.bullets = bullets.map(b => ({
      x: Math.round(b.x), y: Math.round(b.y), vx: b.vx, vy: b.vy, life: b.life
    }));
  }

  if (epsteinProjectiles.length > 0) {
    enemies.epProj = epsteinProjectiles.map(ep => ({
      x: Math.round(ep.x), y: Math.round(ep.y), vx: ep.vx, vy: ep.vy,
      size: ep.size, rotation: ep.rotation, life: ep.life, imgIdx: ep.imgIdx
    }));
  }

  if (state === 'endless' || state === 'endlessShop') {
    enemies.endlessRound = endless.round;
    enemies.endlessTotalKills = endless.totalKills;
    enemies.endlessModifier = endless.modifier ? endless.modifier.name : null;
    enemies.endlessBossActive = endless.bossActive;
    enemies.endlessPowerups = { ...endless.powerups };
    enemies.endlessShieldCharges = endless.shieldCharges;
    enemies.endlessSpawnsLeft = endless.spawnsLeft;
    enemies.endlessShopChoices = endless.shopChoices;
    enemies.endlessShopSel = endless.shopSelection;
    enemies.endlessIntermission = endless.intermission;
    if (endless.enemies.length > 0) {
      enemies.endlessEnemies = endless.enemies.map(e => ({
        x: Math.round(e.x), y: Math.round(e.y), w: e.w, h: e.h,
        hp: e.hp, maxHp: e.maxHp, speed: e.speed, dir: e.dir,
        type: e.type, imgKey: e.imgKey, color: e.color,
        frame: e.frame, dead: e.dead, vy: e.vy,
        shootCooldown: e.shootCooldown, dmg: e.dmg,
        isBoss: e.isBoss || false, bossName: e.bossName || null,
      }));
    }
    if (bullets.length > 0) {
      enemies.endlessBullets = bullets.map(b => ({
        x: Math.round(b.x), y: Math.round(b.y), vx: b.vx, vy: b.vy, life: b.life,
        w: b.w || 8, h: b.h || 8, dmg: b.dmg || 1
      }));
    }
  }

  enemies.gameState = state;
  enemies.cutscenePhase = cutscene.phase;
  enemies.cutsceneDI = cutscene.dialogueIndex;
  enemies.cutsceneFA = Math.round(cutscene.fadeAlpha * 100) / 100;
  enemies.bdActive = bossDialogue.active;
  enemies.bdIndex = bossDialogue.index;
  if (bossDialogue.active && bossDialogue.texts) enemies.bdTexts = bossDialogue.texts;
  enemies.phonecallT = phonecallTimer;
  enemies.fusionCT = fusionCutsceneTimer;
  enemies.bossIntroT = bossIntroTimer;
  enemies.bossDeathT = bossDeathTimer;
  enemies.shakeT = shakeTimer;
  enemies.hawkP2 = hawkingPhase2;
  enemies.hawkRefT = hawkingRefusalTimer;
  enemies.hawkDeathT = hawkingDeathTimer;
  enemies.winCutT = winCutsceneTimer;

  db.ref('rooms/' + currentRoom + '/enemies').set(enemies);
}

function applyEnemyData() {
  if (!mpEnabled || isHost || !mpEnemyData) return;
  const d = mpEnemyData;

  if (d.guards && guards.length > 0) {
    for (let i = 0; i < d.guards.length && i < guards.length; i++) {
      const sg = d.guards[i];
      guards[i].x = sg.x; guards[i].y = sg.y; guards[i].dir = sg.dir;
      guards[i].hp = sg.hp; guards[i].dead = sg.dead;
      guards[i].alert = sg.alert; guards[i].frame = sg.frame;
      guards[i].climbing = sg.climbing;
    }
  }

  if (d.boss) {
    if (!boss) {
      boss = { frameTimer: 0, phaseTriggered2: false, phaseTriggered3: false,
        attackTimer: 0, currentAttack: 'shoot', summonCooldown: 300, shootCooldown: 50,
        x: d.boss.x, y: d.boss.y, w: d.boss.w || 120, h: d.boss.h || 150,
        hp: d.boss.hp || 1, maxHp: d.boss.maxHp || 1, dead: false, phase: 1, dir: -1,
        speed: d.boss.speed || 2, vy: 0, charging: false, slamming: false };
    }

    if (Math.abs(boss.x - d.boss.x) > 200 || Math.abs(boss.y - d.boss.y) > 200) {
      boss.x = d.boss.x; boss.y = d.boss.y;
    } else {
      boss.x += (d.boss.x - boss.x) * 0.5; boss.y += (d.boss.y - boss.y) * 0.5;
    }
    boss.w = d.boss.w; boss.h = d.boss.h;
    boss.hp = d.boss.hp; boss.maxHp = d.boss.maxHp; boss.dir = d.boss.dir;
    boss.dead = d.boss.dead; boss.phase = d.boss.phase; boss.frame = d.boss.frame;
    boss.charging = d.boss.charging; boss.slamming = d.boss.slamming;
    boss.chargeVx = d.boss.chargeVx || 0; boss.alert = d.boss.alert;
    boss.speed = d.boss.speed; boss.vy = d.boss.vy;
    boss._slamShock = d.boss._slamShock || 0;
  }

  if (d.epstein) {
    if (!epstein) {
      epstein = { frameTimer: 0, phaseTriggered2: false, attackTimer: 0, shootCooldown: 40,
        teleportCooldown: 200, speed: 2.5, vy: 0,
        x: d.epstein.x, y: d.epstein.y, w: d.epstein.w || 100, h: d.epstein.h || 130,
        hp: d.epstein.hp || 1, maxHp: d.epstein.maxHp || 1, dead: false, phase: 1, dir: -1 };
    }

    if (Math.abs(epstein.x - d.epstein.x) > 200 || Math.abs(epstein.y - d.epstein.y) > 200) {
      epstein.x = d.epstein.x; epstein.y = d.epstein.y;
    } else {
      epstein.x += (d.epstein.x - epstein.x) * 0.5; epstein.y += (d.epstein.y - epstein.y) * 0.5;
    }
    epstein.w = d.epstein.w; epstein.h = d.epstein.h;
    epstein.hp = d.epstein.hp; epstein.maxHp = d.epstein.maxHp; epstein.dir = d.epstein.dir;
    epstein.dead = d.epstein.dead; epstein.phase = d.epstein.phase; epstein.frame = d.epstein.frame;
    epstein.charging = d.epstein.charging; epstein.chargeVx = d.epstein.chargeVx || 0;
  }

  if (d.fusion) {
    if (!fusionBoss) {
      fusionBoss = { frameTimer: 0, phaseTriggered2: false, attackTimer: 0, shootCooldown: 30,
        slamCooldown: 200, dashCooldown: 150, speed: 3, vy: 0,
        x: d.fusion.x, y: d.fusion.y, w: d.fusion.w || 150, h: d.fusion.h || 180,
        hp: d.fusion.hp || 1, maxHp: d.fusion.maxHp || 1, dead: false, phase: 1, dir: -1 };
    }

    if (Math.abs(fusionBoss.x - d.fusion.x) > 200 || Math.abs(fusionBoss.y - d.fusion.y) > 200) {
      fusionBoss.x = d.fusion.x; fusionBoss.y = d.fusion.y;
    } else {
      fusionBoss.x += (d.fusion.x - fusionBoss.x) * 0.5; fusionBoss.y += (d.fusion.y - fusionBoss.y) * 0.5;
    }
    fusionBoss.w = d.fusion.w; fusionBoss.h = d.fusion.h;
    fusionBoss.hp = d.fusion.hp; fusionBoss.maxHp = d.fusion.maxHp; fusionBoss.dir = d.fusion.dir;
    fusionBoss.dead = d.fusion.dead; fusionBoss.phase = d.fusion.phase; fusionBoss.frame = d.fusion.frame;
    fusionBoss.charging = d.fusion.charging; fusionBoss.chargeVx = d.fusion.chargeVx || 0;
    fusionBoss.mergeGlow = d.fusion.mergeGlow || 0;
    fusionBoss._slamShock = d.fusion._slamShock || 0;
  }

  if (d.minis) {
    while (miniBosses.length < d.minis.length) {
      miniBosses.push({ frameTimer: 0, attackTimer: 0, shootCooldown: 60, vx: 0, vy: 0 });
    }
    for (let i = 0; i < d.minis.length; i++) {
      const sm = d.minis[i];
      miniBosses[i].x = sm.x; miniBosses[i].y = sm.y; miniBosses[i].w = sm.w; miniBosses[i].h = sm.h;
      miniBosses[i].hp = sm.hp; miniBosses[i].maxHp = sm.maxHp; miniBosses[i].dead = sm.dead;
      miniBosses[i].dir = sm.dir; miniBosses[i].name = sm.name; miniBosses[i].color = sm.color;
      miniBosses[i].frame = sm.frame; miniBosses[i].speed = sm.speed;
      if (sm.imgKey) miniBosses[i].imgKey = sm.imgKey;
      miniBosses[i]._slamShock = sm._slamShock || 0;
      miniBosses[i]._gravPull = sm._gravPull || null;
    }
  }

  if (d.bossMinions) {
    while (bossMinions.length < d.bossMinions.length) bossMinions.push({ vy: 0, frameTimer: 0 });
    while (bossMinions.length > d.bossMinions.length) bossMinions.pop();
    for (let i = 0; i < d.bossMinions.length; i++) {
      const sm = d.bossMinions[i];
      bossMinions[i].x = sm.x; bossMinions[i].y = sm.y; bossMinions[i].w = sm.w; bossMinions[i].h = sm.h;
      bossMinions[i].hp = sm.hp; bossMinions[i].maxHp = sm.maxHp; bossMinions[i].dead = sm.dead;
      bossMinions[i].dir = sm.dir; bossMinions[i].frame = sm.frame;
    }
  } else {
    bossMinions = [];
  }

  if (d.bullets) {
    bullets = d.bullets.map(b => ({ x: b.x, y: b.y, vx: b.vx, vy: b.vy, life: b.life }));
  } else {
    bullets = [];
  }

  if (d.epProj) {
    epsteinProjectiles = d.epProj.map(ep => ({
      x: ep.x, y: ep.y, vx: ep.vx, vy: ep.vy,
      size: ep.size, rotation: ep.rotation || 0, life: ep.life, imgIdx: ep.imgIdx
    }));
  } else {
    epsteinProjectiles = [];
  }

  if (d.gameState) {
    const syncStates = ['cutscene','bossfight','bossdialogue','phonecall','epsteinfight','fusioncutscene','fusionfight','splitfight','hawkingRefusal','hawkingDeath','winCutscene','won','dead','endless','endlessShop'];
    if (syncStates.includes(d.gameState) && state !== d.gameState) {
      const oldState = state;

      if (d.gameState === 'cutscene' && state !== 'cutscene') {
        cutscene.active = true;
        cutscene.timer = 0;
        cutscene.phase = 0;
        cutscene.dialogueIndex = 0;
        cutscene.fadeAlpha = 0;
      }

      if (d.gameState === 'endless' && oldState === 'endlessShop') {
        if (!player.alive) {

          player.alive = true;
          player.hp = player.maxHp;
          player.iFrames = 90;
          mpSpectating = false;
          mpDeathSynced = false;
          player.x = endless.arenaX + endless.arenaW / 2 - player.w / 2;
          player.y = endless.arenaY + endless.arenaH - player.h - 10;
          player.vy = 0; player.vx = 0;
          spawnParticles(player.x + player.w/2, player.y + player.h/2, '#44ff88', 15);
          showToast('Revived! New round starting', '#44ff88');
        } else {
          player.hp = Math.min(player.hp + Math.ceil(player.maxHp * 0.2), player.maxHp);
          player.iFrames = 60;
        }
      }

      if (d.gameState === 'endlessShop' && oldState === 'endless') {
        bullets = [];
        endless.bossActive = false;
        endless.modifier = null;
        endless.shopPicked = false;
        screenFlash = 20;
        screenFlashColor = '#44ff44';
      }

      const fightStates = ['bossfight','epsteinfight','fusionfight','splitfight'];
      const wasInFight = fightStates.includes(oldState);
      if (fightStates.includes(d.gameState) && !wasInFight && bigWall) {
        const arenaW2 = 2400;
        const arenaLeft2 = bigWall.x + bigWall.w/2 - arenaW2/2;
        const arenaBottom2 = bigWall.y + 40 + 800;
        player.x = arenaLeft2 + 100 + Math.random() * 200;
        player.y = arenaBottom2 - player.h - 10;
        player.vy = 0; player.vx = 0;
        player.onGround = true;
        player.climbingBigWall = false;
        player.onWall = false;
        screenFlash = 30;
        screenFlashColor = '#ffffff';
        shakeTimer = 15;
      }

      if (d.gameState === 'epsteinfight' && oldState !== 'epsteinfight') {
        player.maxHp += 5; player.hp = player.maxHp;
      }
      if (d.gameState === 'fusionfight' && oldState !== 'fusionfight') {
        player.maxHp = 40; player.hp = player.maxHp;
      }
      if (d.gameState === 'splitfight' && oldState !== 'splitfight') {
        player.maxHp = 50; player.hp = player.maxHp;
      }

      if (d.gameState === 'won' || d.gameState === 'dead' || d.gameState === 'winCutscene') {
        mpSpectating = false;
        restartCooldown = 60;
      }

      if (d.gameState === 'winCutscene' && oldState !== 'winCutscene') {
        player.alive = true;
        player.hp = player.maxHp;
        player.won = true;
        player.iFrames = 99999;
        winCutsceneTimer = 0;
        if (bigWall) {
          player.x = bigWall.x + bigWall.w + 30;
          player.y = bigWall.y - player.h;
        }
        player.vy = 0; player.vx = 0;
        winCutsceneOfficeX = player.x + 750;
        guards = []; bullets = []; projectiles = []; epsteinProjectiles = []; bossMinions = [];
      }
      state = d.gameState;
    }
  }
  if (typeof d.cutscenePhase === 'number') cutscene.phase = d.cutscenePhase;
  if (typeof d.cutsceneDI === 'number') cutscene.dialogueIndex = d.cutsceneDI;
  if (typeof d.cutsceneFA === 'number') cutscene.fadeAlpha = d.cutsceneFA;
  if (d.bdActive) {
    bossDialogue.active = true;
    bossDialogue.index = d.bdIndex || 0;
    if (d.bdTexts) bossDialogue.texts = d.bdTexts;
  } else {
    bossDialogue.active = false;
  }
  if (typeof d.phonecallT === 'number') phonecallTimer = d.phonecallT;
  if (typeof d.fusionCT === 'number') fusionCutsceneTimer = d.fusionCT;
  if (typeof d.bossIntroT === 'number') bossIntroTimer = d.bossIntroT;
  if (typeof d.bossDeathT === 'number') bossDeathTimer = d.bossDeathT;
  if (typeof d.shakeT === 'number') shakeTimer = Math.max(shakeTimer, d.shakeT);

  if (d.hawkP2 !== undefined) hawkingPhase2 = d.hawkP2;
  if (typeof d.hawkRefT === 'number') hawkingRefusalTimer = d.hawkRefT;
  if (typeof d.hawkDeathT === 'number') hawkingDeathTimer = d.hawkDeathT;
  if (typeof d.winCutT === 'number') winCutsceneTimer = d.winCutT;

  if (typeof d.endlessRound === 'number') endless.round = d.endlessRound;
  if (typeof d.endlessTotalKills === 'number') endless.totalKills = d.endlessTotalKills;
  if (typeof d.endlessSpawnsLeft === 'number') endless.spawnsLeft = d.endlessSpawnsLeft;
  if (d.endlessBossActive !== undefined) endless.bossActive = d.endlessBossActive;
  if (d.endlessModifier) {
    const modDef = ENDLESS_ROUND_MODIFIERS.find(m => m.name === d.endlessModifier);
    endless.modifier = modDef || null;
  } else if (d.endlessModifier === null) {
    endless.modifier = null;
  }
  if (d.endlessPowerups) {
    for (const k in d.endlessPowerups) {
      if (k in endless.powerups) endless.powerups[k] = d.endlessPowerups[k];
    }
  }
  if (typeof d.endlessShieldCharges === 'number') endless.shieldCharges = d.endlessShieldCharges;
  if (d.endlessShopChoices) endless.shopChoices = d.endlessShopChoices;
  if (typeof d.endlessShopSel === 'number') endless.shopSelection = d.endlessShopSel;
  if (d.endlessIntermission !== undefined) endless.intermission = d.endlessIntermission;

  if (d.endlessEnemies) {
    while (endless.enemies.length < d.endlessEnemies.length) {
      endless.enemies.push({ iFrames: 0, frameTimer: 0, attackTimer: 0 });
    }
    while (endless.enemies.length > d.endlessEnemies.length) endless.enemies.pop();
    for (let i = 0; i < d.endlessEnemies.length; i++) {
      const se = d.endlessEnemies[i];
      const ee = endless.enemies[i];
      ee.x = se.x; ee.y = se.y; ee.w = se.w; ee.h = se.h;
      ee.hp = se.hp; ee.maxHp = se.maxHp; ee.speed = se.speed; ee.dir = se.dir;
      ee.type = se.type; ee.imgKey = se.imgKey; ee.color = se.color;
      ee.frame = se.frame; ee.dead = se.dead; ee.vy = se.vy;
      ee.shootCooldown = se.shootCooldown; ee.dmg = se.dmg;
      ee.isBoss = se.isBoss || false; ee.bossName = se.bossName || null;
    }
  } else if (state === 'endless' || state === 'endlessShop') {
    endless.enemies = [];
  }

  if (state === 'endless' || state === 'endlessShop') {
    if (d.endlessBullets) {
      bullets = d.endlessBullets.map(b => ({ x: b.x, y: b.y, vx: b.vx, vy: b.vy, life: b.life, w: b.w || 8, h: b.h || 8, dmg: b.dmg || 1 }));
    } else {
      bullets = [];
    }
  }
}

function mpHandleDamageEvent(dmg) {
  if (!dmg || !dmg.target) return;
  const amt = cheats.oneHitKill ? 999 : (dmg.amount || 1);
  if (dmg.target === 'guard' && typeof dmg.index === 'number' && dmg.index < guards.length && !guards[dmg.index].dead) {
    const g = guards[dmg.index];
    g.hp -= amt;
    spawnParticles(g.x + g.w/2, g.y + g.h/2, '#ff4444', 8);
    if (g.hp <= 0) { g.dead = true; spawnParticles(g.x + g.w/2, g.y + g.h/2, '#ffffff', 10); }
  } else if (dmg.target === 'boss' && boss && !boss.dead) {
    boss.hp -= amt;
    spawnParticles(boss.x + boss.w/2, boss.y + boss.h/3, '#ff8800', 10);
    shakeTimer = 6;
    if (boss.hp <= 0) {
      boss.dead = true; bossDeathTimer = 200; bullets = [];
      shakeTimer = 60; screenFlash = 50; screenFlashColor = '#ffffff';
      for (let w2 = 0; w2 < 5; w2++) {
        const ox = (Math.random()-0.5)*boss.w*2; const oy = (Math.random()-0.5)*boss.h*2;
        spawnParticles(boss.x+boss.w/2+ox, boss.y+boss.h/2+oy, '#ff4444', 20);
      }
      bossVfx.push({ type: 'ring', x: boss.x+boss.w/2, y: boss.y+boss.h/2, radius: 10, maxRadius: 500, life: 60, maxLife: 60, color: '#ff4444' });
      bossVfx.push({ type: 'text', x: boss.x+boss.w/2, y: boss.y-20, text: 'DEFEATED!', life: 150, maxLife: 150, color: '#ffdd44' });
    }
  } else if (dmg.target === 'epstein' && epstein && !epstein.dead) {
    epstein.hp -= amt;
    spawnParticles(epstein.x + epstein.w/2, epstein.y + epstein.h/3, '#8844ff', 10);
    shakeTimer = 6;
    if (epstein.hp <= 0) {
      epstein.dead = true; bossDeathTimer = 200; bullets = []; epsteinProjectiles = [];
      shakeTimer = 60; screenFlash = 50; screenFlashColor = '#ffffff';
      bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 500, life: 60, maxLife: 60, color: '#8844ff' });
    }
  } else if (dmg.target === 'fusion' && fusionBoss && !fusionBoss.dead) {
    fusionBoss.hp -= amt;
    spawnParticles(fusionBoss.x + fusionBoss.w/2, fusionBoss.y + fusionBoss.h/3, '#ff8844', 10);
    shakeTimer = 6;
    if (fusionBoss.hp <= 0) {
      fusionBoss.dead = true; bossDeathTimer = 200; bullets = []; epsteinProjectiles = [];
      shakeTimer = 60; screenFlash = 60; screenFlashColor = '#ffffff';
      bossVfx.push({ type: 'ring', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y+fusionBoss.h/2, radius: 10, maxRadius: 600, life: 60, maxLife: 60, color: '#ff4400' });
    }
  } else if (dmg.target === 'mini' && typeof dmg.index === 'number' && dmg.index < miniBosses.length && !miniBosses[dmg.index].dead) {
    const mb = miniBosses[dmg.index];
    mb.hp -= amt;
    spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, mb.color || '#ffffff', 10);
    shakeTimer = 6;
    if (mb.hp <= 0) {

      if (mb.name === 'HAWKING' && !hawkingPhase2) {
        mb.hp = 1;
        hawkingRefusalTimer = 0; hawkingRefusalPhase = 0;
        mb._savedX = mb.x; mb._savedY = mb.y;
        state = 'hawkingRefusal';
        epsteinProjectiles = []; bossMinions = []; bossVfx = [];
        screenFlash = 40; screenFlashColor = '#44ff88'; shakeTimer = 30;
        spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#44ff88', 40);
      } else if (mb.name === 'HAWKING' && hawkingPhase2) {

        mb.hp = 1;
        hawkingDeathTimer = 0; hawkingDeathPhase = 0;
        mb._deathX = mb.x + mb.w/2; mb._deathY = mb.y + mb.h/2;
        state = 'hawkingDeath';
        projectiles = []; epsteinProjectiles = []; bossMinions = []; bossVfx = [];
        screenFlash = 60; screenFlashColor = '#ffd700'; shakeTimer = 40;
        spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffd700', 60);
        spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffffff', 40);
      } else {
        mb.dead = true;
        spawnParticles(mb.x+mb.w/2, mb.y+mb.h/2, mb.color||'#ffffff', 25);
        bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 250, life: 30, maxLife: 30, color: mb.color||'#ffffff' });
        bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y-20, text: mb.name+' DOWN!', life: 120, maxLife: 120, color: mb.color||'#fff' });
      }
    }
  } else if (dmg.target === 'bossMinion' && typeof dmg.index === 'number' && dmg.index < bossMinions.length && !bossMinions[dmg.index].dead) {
    const bm = bossMinions[dmg.index];
    bm.hp -= amt;
    spawnParticles(bm.x + bm.w/2, bm.y + bm.h/2, '#ff4444', 6);
    if (bm.hp <= 0) { bm.dead = true; spawnParticles(bm.x+bm.w/2, bm.y+bm.h/2, '#ffffff', 8); }
  } else if (dmg.target === 'endlessEnemy' && typeof dmg.index === 'number' && dmg.index < endless.enemies.length && !endless.enemies[dmg.index].dead) {
    const ee = endless.enemies[dmg.index];
    ee.hp -= amt;
    ee.iFrames = 5;
    spawnParticles(ee.x + ee.w/2, ee.y + ee.h/3, ee.color || '#ff4444', 8);
    shakeTimer = 4;
    if (ee.hp <= 0) {
      ee.dead = true;
      endless.totalKills++;
      spawnParticles(ee.x + ee.w/2, ee.y + ee.h/2, ee.color || '#ff4444', 20);
      spawnParticles(ee.x + ee.w/2, ee.y + ee.h/2, '#ffdd44', 10);
      shakeTimer = 8;
      if (endless.powerups.vampirism > 0 && player.alive) {
        player.hp = Math.min(player.hp + endless.powerups.vampirism, player.maxHp);
      }
    }
  }
}

function mpSendDamage(target, index, amount) {
  if (!mpEnabled || isHost || !currentRoom) return;
  db.ref('rooms/' + currentRoom + '/damageQueue').push({
    target: target, index: index || 0, amount: amount || 1
  });
}

function mpSendCutsceneEvent(type) {
  if (!mpEnabled || isHost || !currentRoom) return;
  db.ref('rooms/' + currentRoom + '/cutsceneAdvance').push({ type: type });
}

function mpVoteRetry() {
  if (!mpEnabled || !currentRoom) return;
  const uid = myUid();
  db.ref('rooms/' + currentRoom + '/retry/' + uid).set(true);
  mpRetryVotes[uid] = true;
}

function mpTriggerRetry() {
  if (!mpEnabled || !isHost || !currentRoom) return;

  db.ref('rooms/' + currentRoom + '/retry').remove();
  mpRetryVotes = {};

  db.ref('rooms/' + currentRoom + '/state').set('restarting');

  setTimeout(() => {
    if (currentRoom) {

      db.ref('rooms/' + currentRoom + '/matchSettings').set({
        difficulty: settings.difficulty,
        cheats: cheats,
        doubleJump: settings.doubleJump,
      });
      db.ref('rooms/' + currentRoom + '/state').set('playing');
      db.ref('rooms/' + currentRoom + '/enemies').set({});
    }
  }, 300);
}

function mpSyncLobbySettings() {
  if (!mpEnabled || !isHost || !currentRoom) return;
  db.ref('rooms/' + currentRoom + '/matchSettings').set({
    difficulty: settings.difficulty,
    cheats: cheats,
    doubleJump: settings.doubleJump,
    gameMode: mpGameMode,
  });
}

function getNearestPlayerTarget(bossX, bossY) {
  let nearest = player.alive ? player : null;
  let nearDist = player.alive ? Math.sqrt((player.x - bossX) ** 2 + (player.y - bossY) ** 2) : Infinity;

  if (mpEnabled) {
    const uid = myUid();
    for (const pid in roomPlayers) {
      if (pid === uid) continue;
      const rp = roomPlayers[pid];
      if (!rp || !rp.alive) continue;
      const d = Math.sqrt((rp.x - bossX) ** 2 + (rp.y - bossY) ** 2);
      if (d < nearDist) {
        nearDist = d;
        nearest = { x: rp.x, y: rp.y, w: 52, h: 80 };
      }
    }
  }
  return nearest || player;
}

function lerpRemotePlayers() {
  if (!mpEnabled) return;
  const uid = myUid();
  for (const pid in roomPlayers) {
    if (pid === uid) continue;
    const rp = roomPlayers[pid];
    if (!rp || rp._dx === undefined) continue;
    const dx = rp.x - rp._dx;
    const dy = rp.y - rp._dy;

    if (Math.abs(dx) > 300 || Math.abs(dy) > 300) {
      rp._dx = rp.x;
      rp._dy = rp.y;
    } else {
      rp._dx += dx * 0.35;
      rp._dy += dy * 0.35;
    }
  }
}

function drawOtherPlayers() {
  if (!mpEnabled) return;
  const uid = myUid();

  for (const pid in roomPlayers) {
    if (pid === uid) continue;
    const rp = roomPlayers[pid];
    if (!rp || !rp.alive) continue;

    const px = rp._dx !== undefined ? rp._dx : rp.x;
    const py = rp._dy !== undefined ? rp._dy : rp.y;
    const runBounce = rp.runFrame ? Math.sin(rp.runFrame * Math.PI / 2) * 2 : 0;

    ctx.save();
    ctx.globalAlpha = rp.iFrames > 0 ? 0.4 : 0.85;
    const rpDrawW = 52 * PLAYER_IMG_SCALE;
    const rpDrawH = 80 * PLAYER_IMG_SCALE;
    const rpOffX = (52 - rpDrawW) / 2;
    const rpOffY = 80 - rpDrawH;
    if (rp.facing < 0) {
      ctx.translate(px + 52, py - runBounce);
      ctx.scale(-1, 1);
      ctx.drawImage(playerImg, -rpOffX, rpOffY, rpDrawW, rpDrawH);
    } else {
      ctx.drawImage(playerImg, px + rpOffX, py + rpOffY - runBounce, rpDrawW, rpDrawH);
    }
    ctx.restore();

    ctx.save();
    ctx.fillStyle = '#88ccff';
    ctx.font = 'bold 11px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(rp.username || 'Player', px + 26, py - 18);

    if (rp.hp !== undefined && rp.maxHp) {
      const hpPct = rp.hp / rp.maxHp;
      const barW = 40;
      const barH = 4;
      const barX = px + 6;
      const barY = py - 10;
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = hpPct > 0.5 ? '#44ff44' : hpPct > 0.25 ? '#ffcc22' : '#ff4444';
      ctx.fillRect(barX, barY, barW * hpPct, barH);
    }
    ctx.restore();

    if (rp.projectiles) {
      ctx.save();
      ctx.globalAlpha = 0.7;
      for (const pj of rp.projectiles) {

        pj.x += pj.vx;
        pj.y += pj.vy;
        pj.vy += 0.12;
        const sz = pj.w || 28;
        ctx.fillStyle = '#ffcc44';
        ctx.beginPath();
        ctx.arc(pj.x + sz/2, pj.y + sz/2, sz/2 * 0.7, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'rgba(255, 200, 50, 0.3)';
        ctx.beginPath();
        ctx.arc(pj.x + sz/2, pj.y + sz/2, sz/2, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }
  }
}

async function loadFriendsList() {
  if (!currentUser) return;
  authSuccessMsg = '';
  const uid = currentUser.uid;

  try {

    const friendSnap = await db.ref('users/' + uid + '/friends').once('value');
    const friendData = friendSnap.val() || {};
    const friendIds = Object.keys(friendData);
    const friendProms = friendIds.map(fid =>
      Promise.all([
        db.ref('users/' + fid + '/username').once('value'),
        db.ref('users/' + fid + '/online').once('value'),
      ]).then(([usnap, oline]) => ({ uid: fid, username: usnap.val() || '???', online: oline.val() || false }))
    );
    friendsList = await Promise.all(friendProms);

    const reqSnap = await db.ref('users/' + uid + '/friendRequests').once('value');
    const reqData = reqSnap.val() || {};
    friendRequests = [];
    for (const rid in reqData) {
      friendRequests.push({ uid: rid, username: reqData[rid].username || '???' });
    }

    const blockSnap = await db.ref('users/' + uid + '/blocked').once('value');
    const blockData = blockSnap.val() || {};
    blockedUsers = [];
    for (const bid in blockData) {
      blockedUsers.push({ uid: bid, username: blockData[bid].username || '???' });
    }
  } catch (err) {
    authError = 'Failed to load friends list';
  }
}

async function addFriend(username) {
  if (!currentUser || !username.trim()) return;
  friendInput = '';
  authSuccessMsg = '';
  try {

    const snap = await db.ref('users').orderByChild('username').equalTo(username.trim()).once('value');
    const data = snap.val();
    if (!data) { authError = 'User not found!'; return; }
    const targetUid = Object.keys(data)[0];
    if (targetUid === currentUser.uid) { authError = "You can't add yourself!"; return; }

    const friendCheck = await db.ref('users/' + currentUser.uid + '/friends/' + targetUid).once('value');
    if (friendCheck.exists()) { authError = 'Already friends!'; return; }

    const blockCheck = await db.ref('users/' + targetUid + '/blocked/' + currentUser.uid).once('value');
    if (blockCheck.exists()) { authError = 'Cannot add this user.'; return; }

    const reqCheck = await db.ref('users/' + targetUid + '/friendRequests/' + currentUser.uid).once('value');
    if (reqCheck.exists()) { authError = 'Request already sent!'; return; }

    await db.ref('users/' + targetUid + '/friendRequests/' + currentUser.uid).set({
      username: playerUsername,
      time: firebase.database.ServerValue.TIMESTAMP,
    });
    authError = '';
    authSuccessMsg = 'Friend request sent!';
  } catch(e) { authError = 'Failed to send friend request'; }
}

async function acceptFriendRequest(friendUid) {
  if (!currentUser) return;
  try {
    const uid = currentUser.uid;
    await db.ref('users/' + uid + '/friends/' + friendUid).set(true);
    await db.ref('users/' + friendUid + '/friends/' + uid).set(true);
    await db.ref('users/' + uid + '/friendRequests/' + friendUid).remove();
    loadFriendsList();
  } catch(e) { authError = 'Failed to accept request'; }
}

async function declineFriendRequest(friendUid) {
  if (!currentUser) return;
  try {
    await db.ref('users/' + currentUser.uid + '/friendRequests/' + friendUid).remove();
    loadFriendsList();
  } catch(e) { authError = 'Failed to decline request'; }
}

async function removeFriend(friendUid) {
  if (!currentUser) return;
  try {
    const uid = currentUser.uid;
    await db.ref('users/' + uid + '/friends/' + friendUid).remove();
    await db.ref('users/' + friendUid + '/friends/' + uid).remove();
    loadFriendsList();
  } catch(e) { authError = 'Failed to remove friend'; }
}

async function blockUser(targetUid, username) {
  if (!currentUser) return;
  try {
    const uid = currentUser.uid;
    await db.ref('users/' + uid + '/blocked/' + targetUid).set({ username: username });
    await db.ref('users/' + uid + '/friends/' + targetUid).remove();
    await db.ref('users/' + targetUid + '/friends/' + uid).remove();
    await db.ref('users/' + uid + '/friendRequests/' + targetUid).remove();
    loadFriendsList();
  } catch(e) { authError = 'Failed to block user'; }
}

async function unblockUser(targetUid) {
  if (!currentUser) return;
  try {
    await db.ref('users/' + currentUser.uid + '/blocked/' + targetUid).remove();
    loadFriendsList();
  } catch(e) { authError = 'Failed to unblock user'; }
}

let touchControls = { left: false, right: false, up: false };

let touchAim = { active: false, cx: 0, cy: 0, dx: 0, dy: 0, angle: 0 };
function getAimCenterX() { return touchLayout.aimX; }
function getAimCenterY() { return touchLayout.aimY; }
function getAimRadius() { return touchLayout.aimR; }
const AIM_DEAD_ZONE = 8;

function getMoveCenterX() { return touchLayout.moveX; }
function getMoveCenterY() { return touchLayout.moveY; }
function getMoveRadius() { return touchLayout.moveR; }
const MOVE_DEAD_ZONE = 10;
let moveJoystick = { active: false, dx: 0, dy: 0, touchId: null, inJumpUp: false };
const MOVE_JUMP_THRESHOLD = -25;
let jumpFlashTimer = 0;

let _isTouchDev = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
let touchDashQueued = false;

window.addEventListener('touchstart', () => { _isTouchDev = true; }, { once: true, passive: true });
function drawTouchButtons() {
  if (!_isTouchDev || !settings.touchButtons) return;
  ctx.save();
  const MCX = getMoveCenterX(), MCY = getMoveCenterY(), MR = getMoveRadius();
  const ACX = getAimCenterX(), ACY = getAimCenterY(), AR = getAimRadius();

  ctx.globalAlpha = 0.25;
  ctx.strokeStyle = '#88bbff';
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.arc(MCX, MCY, MR, 0, Math.PI * 2); ctx.stroke();

  ctx.globalAlpha = 0.12;
  ctx.beginPath(); ctx.moveTo(MCX - MR, MCY); ctx.lineTo(MCX + MR, MCY); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(MCX, MCY - MR); ctx.lineTo(MCX, MCY + MR); ctx.stroke();

  ctx.globalAlpha = 0.2;
  ctx.fillStyle = '#88bbff';
  ctx.font = 'bold 22px monospace'; ctx.textAlign = 'center';
  ctx.fillText('\u25c4', MCX - MR - 14, MCY + 7);
  ctx.fillText('\u25ba', MCX + MR + 14, MCY + 7);

  if (moveJoystick.active) {
    const len = Math.min(Math.sqrt(moveJoystick.dx * moveJoystick.dx + moveJoystick.dy * moveJoystick.dy), MR);
    const dist = Math.sqrt(moveJoystick.dx * moveJoystick.dx + moveJoystick.dy * moveJoystick.dy) || 1;
    const nx = moveJoystick.dx / dist;
    const ny = moveJoystick.dy / dist;
    const _jFlash = moveJoystick.inJumpUp || jumpFlashTimer > 0;
    ctx.globalAlpha = 0.5;
    ctx.strokeStyle = _jFlash ? '#88ff88' : '#88bbff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(MCX, MCY);
    ctx.lineTo(MCX + nx * len, MCY + ny * len);
    ctx.stroke();
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = _jFlash ? '#aaffaa' : '#aaddff';
    ctx.beginPath(); ctx.arc(MCX + nx * len, MCY + ny * len, 22, 0, Math.PI * 2); ctx.fill();
  } else {
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#88bbff';
    ctx.beginPath(); ctx.arc(MCX, MCY, 22, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.font = 'bold 12px monospace';
    ctx.fillText('MOVE', MCX, MCY + 4);
  }

  const _jFlash2 = moveJoystick.inJumpUp || jumpFlashTimer > 0;
  ctx.globalAlpha = _jFlash2 ? 0.55 : 0.18;
  ctx.fillStyle = _jFlash2 ? '#88ff88' : '#88bbff';
  ctx.font = 'bold 22px monospace'; ctx.textAlign = 'center';
  ctx.fillText('\u25b2', MCX, MCY - MR - 14);

  ctx.globalAlpha = 0.25;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.arc(ACX, ACY, AR, 0, Math.PI * 2); ctx.stroke();
  ctx.globalAlpha = 0.12;
  ctx.beginPath(); ctx.moveTo(ACX - AR, ACY); ctx.lineTo(ACX + AR, ACY); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(ACX, ACY - AR); ctx.lineTo(ACX, ACY + AR); ctx.stroke();

  if (touchAim.active) {
    const len = Math.min(Math.sqrt(touchAim.dx * touchAim.dx + touchAim.dy * touchAim.dy), AR);
    const nx = Math.cos(touchAim.angle);
    const ny = Math.sin(touchAim.angle);
    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = '#ffaa44';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(ACX, ACY);
    ctx.lineTo(ACX + nx * len, ACY + ny * len);
    ctx.stroke();
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = '#ffcc66';
    ctx.beginPath(); ctx.arc(ACX + nx * len, ACY + ny * len, 18, 0, Math.PI * 2); ctx.fill();
  } else {
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath(); ctx.arc(ACX, ACY, 18, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.font = 'bold 14px monospace';
    ctx.fillText('AIM', ACX, ACY + 5);
  }

  if (state === 'endless' && endless.powerups && endless.powerups.dash > 0) {
    const dbx = W / 2, dby = MCY + 10, dbr = 38;
    const cdFrac = endless.dashCooldown > 0 ? endless.dashCooldown / (endless.powerups.dash >= 2 ? 50 : 80) : 0;

    ctx.globalAlpha = cdFrac > 0 ? 0.15 : 0.35;
    ctx.strokeStyle = '#88ffcc';
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(dbx, dby, dbr, 0, Math.PI * 2); ctx.stroke();

    ctx.globalAlpha = cdFrac > 0 ? 0.08 : 0.2;
    ctx.fillStyle = '#88ffcc';
    ctx.beginPath(); ctx.arc(dbx, dby, dbr, 0, Math.PI * 2); ctx.fill();

    if (cdFrac > 0) {
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.moveTo(dbx, dby);
      ctx.arc(dbx, dby, dbr, -Math.PI/2, -Math.PI/2 + cdFrac * Math.PI * 2);
      ctx.closePath(); ctx.fill();
    }

    ctx.globalAlpha = cdFrac > 0 ? 0.3 : 0.7;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('DASH', dbx, dby);
  }

  ctx.restore();
}
let cutscene = {
  active: false,
  timer: 0,
  phase: 0,
  dialogueIndex: 0,
  dialogues: [
    '...',
    'Well, well, well... Look who made it to the WALL.',
    'Welcome to MY border. The BEST wall. TREMENDOUS.',
    'Nobody gets through. NOBODY.',
    'I\'m gonna Make America Great Again!',
    'You think you can cross MY wall? NOT HAPPENING!',
    'Now get ready to be DEPORTED! BIGLY!',
  ],
  fadeAlpha: 0,
};

const bossPhaseDialogues = {
  2: [
    'That tickled. I\'ve survived TWO impeachments!',
    'You think you can beat ME? I have the best genes!',
    'This isn\'t even my final form... BELIEVE ME!',
  ],
  3: [
    'OK that\'s IT. You asked for this.',
    'I know people... VERY powerful people...',
    'Time to make a phone call!',
  ],
};

const epsteinDialogues = [
  '*ring ring* ... Jeff? I need a favor...',
  'Send the files. ALL of them.',
  '...he didn\'t unalive himself btw',
];
const epsteinPhaseDialogues = {
  2: [
    'You know too much already...',
    'These files will BURY you!',
    'The island sends its regards!',
  ],
};
let bossDialogue = { active: false, texts: [], index: 0, timer: 0 };

const keys = {};
const keysJustPressed = {};
window.addEventListener('keydown', e => {
  if (!keys[e.code]) keysJustPressed[e.code] = true;
  keys[e.code] = true;

  if (state === 'menu') {
    if (activeTextInput) return;
    if (menuState === 'main') {
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { menuSelection--; if (menuSelection < 0) menuSelection = 8; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { menuSelection++; if (menuSelection > 8) menuSelection = 0; }
      if (e.code === 'Space' || e.code === 'Enter') {
        if (menuSelection === 0) {
          if (tutorialDone) { startGame(); }
          else { state = 'tutorial'; tutorialPage = 0; }
        }
        else if (menuSelection === 1) { startEndless(); }
        else if (menuSelection === 2) { menuState = 'multiplayer'; mpMenuSelection = 0; authError = ''; }
        else if (menuSelection === 3) { menuState = 'difficulty'; menuSelection = 0; }
        else if (menuSelection === 4) { menuState = 'settings'; menuSelection = 0; }
        else if (menuSelection === 5) { menuState = 'controls'; menuSelection = 0; }
        else if (menuSelection === 6) { friendsBackTo = 'main'; menuState = 'friends'; friendMenuSelection = 0; authError = ''; loadFriendsList(); }
        else if (menuSelection === 7) { menuState = 'credits'; menuSelection = 0; }
        else if (menuSelection === 8) { menuState = 'cheats'; cheatSelection = 0; }
      }
    } else if (menuState === 'cheats') {
      const cheatKeys = Object.keys(cheats);
      const totalItems = cheatKeys.length + 4;
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { cheatSelection--; if (cheatSelection < 0) cheatSelection = totalItems - 1; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { cheatSelection++; if (cheatSelection >= totalItems) cheatSelection = 0; }
      if (e.code === 'Space' || e.code === 'Enter' || e.code === 'ArrowRight' || e.code === 'ArrowLeft') {
        if (cheatSelection < cheatKeys.length) {
          cheats[cheatKeys[cheatSelection]] = !cheats[cheatKeys[cheatSelection]];
        } else if (cheatSelection === cheatKeys.length) {

          const step = e.shiftKey ? 10 : 1;
          if (e.code === 'ArrowRight') endlessStartRound = Math.min(200, endlessStartRound + step);
          else if (e.code === 'ArrowLeft') endlessStartRound = Math.max(1, endlessStartRound - step);
          else endlessStartRound = 1;
        } else if (cheatSelection === cheatKeys.length + 1) {
          skipToFinalBoss();
        } else if (cheatSelection === cheatKeys.length + 2) {
          watchCutscene();
        } else {
          menuState = 'main'; menuSelection = 7;
        }
      }
      if (e.code === 'Escape' || e.code === 'Backspace') { menuState = 'main'; menuSelection = 7; }
    } else if (menuState === 'difficulty') {
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { menuSelection--; if (menuSelection < 0) menuSelection = 3; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { menuSelection++; if (menuSelection > 3) menuSelection = 0; }
      if (e.code === 'Space' || e.code === 'Enter') {
        const diffs = ['easy','normal','hard','insane'];
        settings.difficulty = diffs[menuSelection];
        menuState = 'main'; menuSelection = 2;
      }
      if (e.code === 'Escape' || e.code === 'Backspace') { menuState = 'main'; menuSelection = 2; }
    } else if (menuState === 'settings') {
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { menuSelection--; if (menuSelection < 0) menuSelection = 7; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { menuSelection++; if (menuSelection > 7) menuSelection = 0; }
      if (e.code === 'Space' || e.code === 'Enter' || e.code === 'ArrowRight' || e.code === 'ArrowLeft') {
        if (menuSelection === 0) settings.screenShake = !settings.screenShake;
        else if (menuSelection === 1) settings.particles = !settings.particles;
        else if (menuSelection === 2) settings.showFPS = !settings.showFPS;
        else if (menuSelection === 3) settings.doubleJump = !settings.doubleJump;
        else if (menuSelection === 4) settings.showTimer = !settings.showTimer;
        else if (menuSelection === 5) settings.colorblind = !settings.colorblind;
        else if (menuSelection === 6) { menuState = 'touchcontrols'; menuSelection = 0; }
        else if (menuSelection === 7) { menuState = 'main'; menuSelection = 3; }
      }
      if (e.code === 'Escape' || e.code === 'Backspace') { menuState = 'main'; menuSelection = 3; }
    } else if (menuState === 'touchcontrols') {
      const presetKeys = Object.keys(TOUCH_PRESETS);
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { menuSelection--; if (menuSelection < 0) menuSelection = presetKeys.length + 1; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { menuSelection++; if (menuSelection > presetKeys.length + 1) menuSelection = 0; }
      if (e.code === 'Space' || e.code === 'Enter') {
        if (menuSelection < presetKeys.length) {
          touchPresetName = presetKeys[menuSelection];
          touchLayout = Object.assign({}, TOUCH_PRESETS[touchPresetName]);
          saveTouchLayout();
        } else if (menuSelection === presetKeys.length) {

          touchPresetName = 'default';
          touchLayout = Object.assign({}, TOUCH_PRESETS.default);
          saveTouchLayout();
        } else {
          menuState = 'settings'; menuSelection = 6;
        }
      }
      if (e.code === 'Escape' || e.code === 'Backspace') { menuState = 'settings'; menuSelection = 6; }
    } else if (menuState === 'controls') {
      if (e.code === 'Escape' || e.code === 'Backspace' || e.code === 'Space' || e.code === 'Enter') { menuState = 'main'; menuSelection = 4; }
    } else if (menuState === 'credits') {
      if (e.code === 'Escape' || e.code === 'Backspace' || e.code === 'Space' || e.code === 'Enter') { menuState = 'main'; menuSelection = 6; }
    } else if (menuState === 'account') {
      if (e.code === 'Escape' || e.code === 'Backspace') { authError = ''; menuState = 'multiplayer'; mpMenuSelection = 0; }
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { authInputField--; if (authInputField < 0) authInputField = (authScreen === 'register' ? 3 : 2); }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { authInputField++; if (authInputField > (authScreen === 'register' ? 3 : 2)) authInputField = 0; }
      if (e.code === 'Space' || e.code === 'Enter') {

        const submitIdx = authScreen === 'register' ? 3 : 2;
        if (authInputField < submitIdx) {
          const fields = ['username', 'password', 'confirm'];
          activateTextInput(fields[authInputField]);
        } else {
          if (authScreen === 'register') registerAccount(authInputs.username, authInputs.password);
          else loginAccount(authInputs.username, authInputs.password);
        }
      }
    } else if (menuState === 'multiplayer') {
      if (e.code === 'Escape' || e.code === 'Backspace') { menuState = 'main'; menuSelection = 1; }
      const mpMax = playerUsername ? 4 : 3;
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { mpMenuSelection--; if (mpMenuSelection < 0) mpMenuSelection = mpMax; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { mpMenuSelection++; if (mpMenuSelection > mpMax) mpMenuSelection = 0; }
      if (e.code === 'Space' || e.code === 'Enter') {
        if (mpMenuSelection === 0) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else createRoom(); }
        else if (mpMenuSelection === 1) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else { activateTextInput('roomcode'); joinRoomInput = ''; } }
        else if (mpMenuSelection === 2) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else { friendsBackTo = 'multiplayer'; menuState = 'friends'; friendMenuSelection = 0; authError = ''; loadFriendsList(); } }
        else if (mpMenuSelection === 3) { menuState = 'main'; menuSelection = 1; }
        else if (mpMenuSelection === 4) { logoutAccount(); }
      }
    } else if (menuState === 'lobby') {
      if (e.code === 'Escape') { leaveRoom(); }
      if (e.code === 'Enter' && !chatOpen) { chatOpen = true; activateTextInput('chat'); chatInput = ''; }
      if (e.code === 'Space' && !chatOpen && isHost) { startMultiplayerGame(); }

      if (isHost && !chatOpen) {
        const settCount = 9;
        if (e.code === 'ArrowUp' || e.code === 'KeyW') { mpSettingsSelection = (mpSettingsSelection - 1 + settCount) % settCount; }
        if (e.code === 'ArrowDown' || e.code === 'KeyS') { mpSettingsSelection = (mpSettingsSelection + 1) % settCount; }
        if (e.code === 'ArrowLeft' || e.code === 'ArrowRight' || e.code === 'KeyA' || e.code === 'KeyD') {
          const dir = (e.code === 'ArrowRight' || e.code === 'KeyD') ? 1 : -1;
          if (mpSettingsSelection === 0) {
            const modes = ['story','endless'];
            let idx = modes.indexOf(mpGameMode);
            idx = (idx + dir + modes.length) % modes.length;
            mpGameMode = modes[idx];
          } else if (mpSettingsSelection === 1) {
            const diffs = ['easy','normal','hard','insane'];
            let idx = diffs.indexOf(settings.difficulty);
            idx = (idx + dir + diffs.length) % diffs.length;
            settings.difficulty = diffs[idx];
          } else if (mpSettingsSelection === 2) { settings.doubleJump = !settings.doubleJump; }
          else if (mpSettingsSelection === 3) { cheats.godMode = !cheats.godMode; }
          else if (mpSettingsSelection === 4) { cheats.oneHitKill = !cheats.oneHitKill; }
          else if (mpSettingsSelection === 5) { cheats.infiniteJumps = !cheats.infiniteJumps; }
          else if (mpSettingsSelection === 6) { cheats.speedBoost = !cheats.speedBoost; }
          else if (mpSettingsSelection === 7) { cheats.bigProjectiles = !cheats.bigProjectiles; }
          else if (mpSettingsSelection === 8) { cheats.noCooldown = !cheats.noCooldown; }
          mpSyncLobbySettings();
        }
      }
    } else if (menuState === 'friends') {
      if (e.code === 'Escape' || e.code === 'Backspace') {
        if (friendsBackTo === 'multiplayer') { menuState = 'multiplayer'; mpMenuSelection = 0; }
        else { menuState = 'main'; menuSelection = 5; }
      }
      if (e.code === 'ArrowLeft') { friendTab--; if (friendTab < 0) friendTab = 3; friendMenuSelection = 0; }
      if (e.code === 'ArrowRight') { friendTab++; if (friendTab > 3) friendTab = 0; friendMenuSelection = 0; }
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { friendMenuSelection--; if (friendMenuSelection < 0) friendMenuSelection = 0; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { friendMenuSelection++; }
      if (e.code === 'Space' || e.code === 'Enter') {
        if (friendTab === 1 && friendRequests[friendMenuSelection]) acceptFriendRequest(friendRequests[friendMenuSelection].uid);
        if (friendTab === 3) { activateTextInput('friendadd'); friendInput = ''; }
      }
      if (e.code === 'KeyX') {
        if (friendTab === 0 && friendsList[friendMenuSelection]) removeFriend(friendsList[friendMenuSelection].uid);
        if (friendTab === 1 && friendRequests[friendMenuSelection]) declineFriendRequest(friendRequests[friendMenuSelection].uid);
        if (friendTab === 2 && blockedUsers[friendMenuSelection]) unblockUser(blockedUsers[friendMenuSelection].uid);
      }
    }
    return;
  }

  if (state === 'tutorial') {
    if (e.code === 'Space' || e.code === 'Enter' || e.code === 'ArrowRight') {
      tutorialPage++;
      if (tutorialPage >= 5) { completeTutorial(); }
    }
    if (e.code === 'ArrowLeft' && tutorialPage > 0) tutorialPage--;
    return;
  }

  if (e.code === 'Escape' && state === 'cutscene') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { cutscene.phase = 3; cutscene.fadeAlpha = 1; cutscene.timer = 0; }
    return;
  }
  if (e.code === 'Escape' && state === 'phonecall') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { phonecallTimer = 1; }
    return;
  }
  if (e.code === 'Escape' && state === 'fusioncutscene') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { fusionCutsceneTimer = 1; }
    return;
  }
  if (e.code === 'Escape' && state === 'hawkingRefusal') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { hawkingRefusalTimer = 1129; }
    return;
  }
  if (e.code === 'Escape' && state === 'hawkingDeath') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { hawkingDeathTimer = 899; }
    return;
  }
  if (e.code === 'Escape' && state === 'winCutscene') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { winCutsceneTimer = 699; }
    return;
  }
  if (e.code === 'Escape' && state === 'bossdialogue') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { bossDialogue.index = bossDialogue.texts.length; advanceCutscene(); }
    return;
  }

  if (e.code === 'Escape' && (state === 'endless' || state === 'endlessShop')) {

    if (endless.round > endless.highScore) {
      endless.highScore = endless.round;
      localStorage.setItem('endlessHighScore', String(endless.highScore));
    }
    endless.round = 0;
    state = 'menu'; menuState = 'main'; menuSelection = 1;
    return;
  }
  if (state === 'endlessShop' && endless.shopChoices.length > 0 && !endless.shopPicked) {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
      endless.shopSelection = (endless.shopSelection - 1 + endless.shopChoices.length) % endless.shopChoices.length;
    }
    if (e.code === 'ArrowRight' || e.code === 'KeyD') {
      endless.shopSelection = (endless.shopSelection + 1) % endless.shopChoices.length;
    }
    if (e.code === 'Space' || e.code === 'Enter') {
      const key = endless.shopChoices[endless.shopSelection];
      if (mpEnabled) {

        db.ref('rooms/' + currentRoom + '/shopPicks/' + myUid()).set(key);
        endless.shopPicked = true;
      } else {

        endlessApplyPowerup(key);
        endlessNextRound();
      }
    }
    return;
  }

  if (mpSpectating) {
    const alive = getAlivePlayerList();
    if (alive.length > 0) {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
        mpSpectateIndex = (mpSpectateIndex - 1 + alive.length) % alive.length;
        mpSpectateTarget = alive[mpSpectateIndex].uid;
      }
      if (e.code === 'ArrowRight' || e.code === 'KeyD') {
        mpSpectateIndex = (mpSpectateIndex + 1) % alive.length;
        mpSpectateTarget = alive[mpSpectateIndex].uid;
      }
    }
    return;
  }

  if ((e.code === 'Space' || e.code === 'Enter') && (state === 'cutscene' || state === 'bossdialogue')) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('advance'); }
    else { advanceCutscene(); }
  } else if ((state === 'won' || state === 'dead') && restartCooldown <= 0) {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') { mpRetrySelection = 0; }
    if (e.code === 'ArrowRight' || e.code === 'KeyD') { mpRetrySelection = 1; }
    if (e.code === 'Space' || e.code === 'Enter') {
      if (mpRetrySelection === 0) {

        if (mpEnabled) {
          mpVoteRetry();

          if (isHost) {
            const totalPlayers = Object.keys(roomPlayers).length;
            const retryCount = Object.keys(mpRetryVotes).length;
            if (retryCount >= totalPlayers) {
              mpTriggerRetry();
            }
          }
        } else {

          if (endless.round > 0) { startEndless(); } else { startGame(); }
        }
      } else {

        if (mpEnabled) { leaveRoom(); }
        endless.round = 0;
        state = 'menu'; menuState = 'main'; menuSelection = 0;
      }
    }
  }
  if ((e.code === 'Space' || e.code === 'Enter') && state === 'intro' && introPhase >= 3) {
    introPhase = 6;
  }
  if ((e.code === 'KeyF' || e.code === 'KeyE') && (state === 'playing' || state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight' || state === 'endless') && player.alive) {
    throwProjectile();
  }
});
window.addEventListener('keyup', e => keys[e.code] = false);

canvas.addEventListener('mousemove', e => {
  const { x, y } = clientToCanvas(e.clientX, e.clientY);
  mouseX = x;
  mouseY = y;
  mouseActive = true;

  if (tcDragging && state === 'menu' && menuState === 'touchcontrols') {
    const cx = x, cy = y;
    const pvScaleX = (W - 80) / W;
    const newX = Math.max(60, Math.min(W - 60, (cx - tcDragOffX - 40) / pvScaleX));
    const newY = touchLayout[tcDragging === 'move' ? 'moveY' : 'aimY'];
    if (tcDragging === 'move') { touchLayout.moveX = Math.round(newX); }
    else if (tcDragging === 'aim') { touchLayout.aimX = Math.round(newX); }
    touchPresetName = 'custom';
    saveTouchLayout();
  }
});
canvas.addEventListener('mouseup', e => {
  if (tcDragging) { tcDragging = null; }
});

function toggleFullscreen() {
  const el = document.documentElement;
  const fsEl = document.fullscreenElement || document.webkitFullscreenElement;
  if (!fsEl) {
    if (el.requestFullscreen) el.requestFullscreen().catch(() => {});
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  } else {
    if (document.exitFullscreen) document.exitFullscreen().catch(() => {});
    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
  }
}

document.addEventListener('fullscreenchange', () => { setTimeout(resizeCanvas, 100); });
document.addEventListener('webkitfullscreenchange', () => { setTimeout(resizeCanvas, 100); });

canvas.addEventListener('click', e => {
  const { x: cx, y: cy } = clientToCanvas(e.clientX, e.clientY);

  if (_showBetaPopup && window._betaOkBtn) {
    const ob = window._betaOkBtn;
    if (cx >= ob.x && cx <= ob.x + ob.w && cy >= ob.y && cy <= ob.y + ob.h) { _dismissBetaPopup(); return; }
    return;
  }

  if (_showPerfPrompt && window._perfYesBtn && window._perfNoBtn) {
    const yb = window._perfYesBtn, nb = window._perfNoBtn;
    if (cx >= yb.x && cx <= yb.x + yb.w && cy >= yb.y && cy <= yb.y + yb.h) { _acceptPerfMode(); return; }
    if (cx >= nb.x && cx <= nb.x + nb.w && cy >= nb.y && cy <= nb.y + nb.h) { _declinePerfMode(); return; }
    return;
  }

  if (cx > W - 48 && cy < 48) {
    toggleFullscreen();
    return;
  }

  if (state === 'menu') {
    if (menuState === 'main') {
      const menuY = H * 0.35;
      const menuSpacing = Math.min(40, (H * 0.40) / 8);
      for (let i = 0; i < 9; i++) {
        const y = menuY + i * menuSpacing;
        if (cx > W/2 - 160 && cx < W/2 + 160 && cy > y - 18 && cy < y + 18) {
          menuSelection = i;
          if (i === 0) {
            if (tutorialDone) { startGame(); }
            else { state = 'tutorial'; tutorialPage = 0; }
          }
          else if (i === 1) { startEndless(); }
          else if (i === 2) { menuState = 'multiplayer'; mpMenuSelection = 0; authError = ''; }
          else if (i === 3) { menuState = 'difficulty'; menuSelection = 0; }
          else if (i === 4) { menuState = 'settings'; menuSelection = 0; }
          else if (i === 5) { menuState = 'controls'; menuSelection = 0; }
          else if (i === 6) { friendsBackTo = 'main'; menuState = 'friends'; friendMenuSelection = 0; authError = ''; loadFriendsList(); }
          else if (i === 7) { menuState = 'credits'; menuSelection = 0; }
          else if (i === 8) { menuState = 'cheats'; cheatSelection = 0; }
          return;
        }
      }
    } else if (menuState === 'difficulty') {
      const diffY = H * 0.42;
      for (let i = 0; i < 4; i++) {
        const y = diffY + i * 55;
        if (cx > W/2 - 200 && cx < W/2 + 200 && cy > y - 20 && cy < y + 25) {
          const diffs = ['easy','normal','hard','insane'];
          settings.difficulty = diffs[i];
          menuState = 'main'; menuSelection = 2;
          return;
        }
      }

      if (cy > H * 0.85) { menuState = 'main'; menuSelection = 2; return; }
    } else if (menuState === 'settings') {
      const setY = H * 0.36;
      for (let i = 0; i < 8; i++) {
        const y = setY + i * 40;
        if (cx > W/2 - 200 && cx < W/2 + 200 && cy > y - 14 && cy < y + 18) {
          if (i === 0) settings.screenShake = !settings.screenShake;
          else if (i === 1) settings.particles = !settings.particles;
          else if (i === 2) settings.showFPS = !settings.showFPS;
          else if (i === 3) settings.doubleJump = !settings.doubleJump;
          else if (i === 4) settings.showTimer = !settings.showTimer;
          else if (i === 5) settings.colorblind = !settings.colorblind;
          else if (i === 6) { menuState = 'touchcontrols'; menuSelection = 0; }
          else if (i === 7) { menuState = 'main'; menuSelection = 3; }
          return;
        }
      }
    } else if (menuState === 'touchcontrols') {

      const presetKeys = Object.keys(TOUCH_PRESETS);
      const tcY = H * 0.36;
      for (let i = 0; i < presetKeys.length; i++) {
        const y = tcY + i * 36;
        if (cx > W/2 - 200 && cx < W/2 + 200 && cy > y - 14 && cy < y + 18) {
          touchPresetName = presetKeys[i];
          touchLayout = Object.assign({}, TOUCH_PRESETS[touchPresetName]);
          saveTouchLayout();
          return;
        }
      }

      const sizeY = tcY + presetKeys.length * 36 + 10;
      if (cx > W/2 - 80 && cx < W/2 - 40 && cy > sizeY - 10 && cy < sizeY + 20) {
        touchLayout.moveR = Math.max(35, touchLayout.moveR - 5); touchPresetName = 'custom'; saveTouchLayout(); return;
      }
      if (cx > W/2 + 40 && cx < W/2 + 80 && cy > sizeY - 10 && cy < sizeY + 20) {
        touchLayout.moveR = Math.min(100, touchLayout.moveR + 5); touchPresetName = 'custom'; saveTouchLayout(); return;
      }

      const sizeY2 = sizeY + 32;
      if (cx > W/2 - 80 && cx < W/2 - 40 && cy > sizeY2 - 10 && cy < sizeY2 + 20) {
        touchLayout.aimR = Math.max(35, touchLayout.aimR - 5); touchPresetName = 'custom'; saveTouchLayout(); return;
      }
      if (cx > W/2 + 40 && cx < W/2 + 80 && cy > sizeY2 - 10 && cy < sizeY2 + 20) {
        touchLayout.aimR = Math.min(100, touchLayout.aimR + 5); touchPresetName = 'custom'; saveTouchLayout(); return;
      }

      const resetY = sizeY2 + 36;
      if (cx > W/2 - 60 && cx < W/2 + 60 && cy > resetY - 12 && cy < resetY + 18) {
        touchPresetName = 'default'; touchLayout = Object.assign({}, TOUCH_PRESETS.default); saveTouchLayout(); return;
      }

      const backY = resetY + 36;
      if (cx > W/2 - 60 && cx < W/2 + 60 && cy > backY - 12 && cy < backY + 18) {
        menuState = 'settings'; menuSelection = 6; return;
      }

      if (cy > H * 0.7) {
        const pvTop = H * 0.7;
        const pvH = H - pvTop - 10;
        const pvCenterY = pvTop + pvH / 2 + 8;
        const pvScaleX = (W - 80) / W;
        const pvScaleR = 0.5;
        const pvMCX = 40 + touchLayout.moveX * pvScaleX;
        const pvMCY = pvCenterY;
        const pvACX = 40 + touchLayout.aimX * pvScaleX;
        const pvACY = pvCenterY;
        const mdx = cx - pvMCX, mdy = cy - pvMCY;
        const adx = cx - pvACX, ady = cy - pvACY;
        if (Math.sqrt(mdx*mdx + mdy*mdy) < touchLayout.moveR * pvScaleR + 20) {
          tcDragging = 'move'; tcDragOffX = mdx; tcDragOffY = mdy; return;
        }
        if (Math.sqrt(adx*adx + ady*ady) < touchLayout.aimR * pvScaleR + 20) {
          tcDragging = 'aim'; tcDragOffX = adx; tcDragOffY = ady; return;
        }
      }
    } else if (menuState === 'cheats') {
      const cheatKeys = Object.keys(cheats);
      const cheatY = H * 0.28;
      const totalItems = cheatKeys.length + 4;
      for (let i = 0; i < totalItems; i++) {
        const y = cheatY + i * 38;
        if (cx > W/2 - 220 && cx < W/2 + 220 && cy > y - 14 && cy < y + 18) {
          if (i < cheatKeys.length) {
            cheats[cheatKeys[i]] = !cheats[cheatKeys[i]];
          } else if (i === cheatKeys.length) {

            if (cx < W/2 + 120) endlessStartRound = Math.max(1, endlessStartRound - 1);
            else endlessStartRound = Math.min(200, endlessStartRound + 1);
          } else if (i === cheatKeys.length + 1) {
            skipToFinalBoss();
          } else if (i === cheatKeys.length + 2) {
            watchCutscene();
          } else {
            menuState = 'main'; menuSelection = 7;
          }
          return;
        }
      }
      return;
    } else if (menuState === 'controls' || menuState === 'credits') {

      const wasCredits = menuState === 'credits';
      menuState = 'main'; menuSelection = wasCredits ? 6 : 4;
      return;
    } else if (menuState === 'multiplayer') {

      const mpItems = ['CREATE ROOM', 'JOIN ROOM', 'FRIENDS', 'BACK'];
      const mpY = H * 0.40;
      const mpSpacing = Math.min(50, (H * 0.28) / (mpItems.length - 1));
      for (let i = 0; i < mpItems.length; i++) {
        const y = mpY + i * mpSpacing;
        if (cx > W/2 - 180 && cx < W/2 + 180 && cy > y - 24 && cy < y + 24) {
          if (i === 0) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else createRoom(); }
          else if (i === 1) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else { activateTextInput('roomcode'); joinRoomInput = ''; } }
          else if (i === 2) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else { friendsBackTo = 'multiplayer'; menuState = 'friends'; friendMenuSelection = 0; authError = ''; loadFriendsList(); } }
          else if (i === 3) { menuState = 'main'; menuSelection = 1; }
          return;
        }
      }

      if (!playerUsername) {
        if (cy > H * 0.76 && cy < H * 0.87) { menuState = 'account'; authInputField = 0; authScreen = 'login'; authError = ''; return; }
      } else {

        if (cy > H * 0.72 && cy < H * 0.82) { logoutAccount(); return; }
      }
      return;
    } else if (menuState === 'account') {

      const accY = H * 0.38;

      if (cy > accY - 14 && cy < accY + 32) { activateTextInput('username'); return; }

      if (cy > accY + 34 && cy < accY + 78) { activateTextInput('password'); return; }
      if (authScreen === 'register' && cy > accY + 82 && cy < accY + 130) { activateTextInput('confirm'); return; }

      const btnY = authScreen === 'register' ? accY + 150 : accY + 100;
      if (cy > btnY - 14 && cy < btnY + 32) {
        if (authScreen === 'register') registerAccount(authInputs.username, authInputs.password);
        else loginAccount(authInputs.username, authInputs.password);
        return;
      }

      if (cy > btnY + 25 && cy < btnY + 60) {
        authScreen = authScreen === 'login' ? 'register' : 'login';
        return;
      }

      if (cy > btnY + 55 && cy < btnY + 90) { playAsGuest(); return; }

      if (cy > H * 0.88) { authError = ''; menuState = 'multiplayer'; return; }
      return;
    } else if (menuState === 'lobby') {

      if (cy > H * 0.58 && cy < H * 0.87) { chatOpen = true; activateTextInput('chat'); chatInput = ''; return; }

      if (isHost && cy > H * 0.87) { startMultiplayerGame(); return; }

      if (cx < 140 && cy < 50) { leaveRoom(); return; }
      return;
    } else if (menuState === 'friends') {

      const tabW = W / 4;
      if (cy > H * 0.25 && cy < H * 0.33) {
        friendTab = Math.floor(cx / tabW);
        if (friendTab > 3) friendTab = 3;
        friendMenuSelection = 0;
        return;
      }

      if (friendTab === 3 && cy > H * 0.38 && cy < H * 0.52) { activateTextInput('friendadd'); friendInput = ''; return; }

      const listY = H * 0.42;
      const items = friendTab === 0 ? friendsList : friendTab === 1 ? friendRequests : friendTab === 2 ? blockedUsers : [];
      for (let i = 0; i < items.length; i++) {
        const y = listY + i * 36;
        if (cy > y - 14 && cy < y + 24) {
          friendMenuSelection = i;

          if (cx > W - 120) {
            if (friendTab === 0) removeFriend(items[i].uid);
            else if (friendTab === 1) { if (cx > W - 60) declineFriendRequest(items[i].uid); else acceptFriendRequest(items[i].uid); }
            else if (friendTab === 2) unblockUser(items[i].uid);
          }
          return;
        }
      }

      if (cy > H * 0.88) {
        if (friendsBackTo === 'multiplayer') { menuState = 'multiplayer'; mpMenuSelection = 0; }
        else { menuState = 'main'; menuSelection = 5; }
        return;
      }
      return;
    }
    return;
  }

  if (state === 'cutscene' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { cutscene.phase = 3; cutscene.fadeAlpha = 1; cutscene.timer = 0; } return;
  }
  if (state === 'phonecall' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { phonecallTimer = 1; } return;
  }
  if (state === 'fusioncutscene' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { fusionCutsceneTimer = 1; } return;
  }
  if (state === 'hawkingRefusal' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { hawkingRefusalTimer = 1129; } return;
  }
  if (state === 'hawkingDeath' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { hawkingDeathTimer = 899; } return;
  }
  if (state === 'winCutscene' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { winCutsceneTimer = 699; } return;
  }
  if (state === 'bossdialogue' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { bossDialogue.index = bossDialogue.texts.length; advanceCutscene(); } return;
  }

  if (state === 'splitfight' && bossIntroTimer > 1) {
    bossIntroTimer = 1; return;
  }

  if (state === 'tutorial') { tutorialPage++; if (tutorialPage >= 5) completeTutorial(); return; }
  if (state === 'cutscene' || state === 'bossdialogue') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('advance'); } else { advanceCutscene(); } return;
  }

  if (state === 'endlessShop' && endless.shopChoices.length > 0 && !endless.shopPicked) {
    const cardW = Math.min(220, (W - 60) / 3);
    const cardH = 240;
    const cardGap = 16;
    const totalW2 = cardW * endless.shopChoices.length + cardGap * (endless.shopChoices.length - 1);
    const startX2 = W / 2 - totalW2 / 2;
    const cardY2 = H * 0.3;
    for (let ci = 0; ci < endless.shopChoices.length; ci++) {
      const cxCard = startX2 + ci * (cardW + cardGap);
      if (cx > cxCard && cx < cxCard + cardW && cy > cardY2 && cy < cardY2 + cardH) {
        endless.shopSelection = ci;
        const key = endless.shopChoices[ci];
        if (mpEnabled) {
          db.ref('rooms/' + currentRoom + '/shopPicks/' + myUid()).set(key);
          endless.shopPicked = true;
        } else {
          endlessApplyPowerup(key);
          endlessNextRound();
        }
        return;
      }
    }
    return;
  }
  if ((state === 'playing' || state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight' || state === 'endless') && player.alive) throwProjectile();

  if ((state === 'won' || state === 'dead') && restartCooldown <= 0) {
    const btnY = state === 'won' ? H/2 + 30 : H/2 + 20;
    const btnW2 = 160, btnH2 = 48;
    if (cy > btnY && cy < btnY + btnH2) {
      if (cx > W/2 - btnW2 - 10 && cx < W/2 - 10) {

        if (mpEnabled) { mpVoteRetry(); if (isHost) { const tc = Object.keys(roomPlayers).length; const rc = Object.keys(mpRetryVotes).length; if (rc >= tc) mpTriggerRetry(); } } else if (endless.round > 0) { startEndless(); } else { startGame(); }
      } else if (cx > W/2 + 10 && cx < W/2 + btnW2 + 10) {

        if (mpEnabled) { leaveRoom(); } endless.round = 0; state = 'menu'; menuState = 'main'; menuSelection = 0;
      }
    }
  }
});

window.addEventListener('keydown', e => {
  if (e.key === 'F11') { e.preventDefault(); toggleFullscreen(); }
});

let aimTouchId = null;

function isInMoveZone(cx, cy) {

  const mdx = cx - getMoveCenterX(), mdy = cy - getMoveCenterY();
  const adx = cx - getAimCenterX(), ady = cy - getAimCenterY();
  return (mdx*mdx + mdy*mdy) < (adx*adx + ady*ady);
}

function isInAimZone(cx, cy) {
  return !isInMoveZone(cx, cy);
}

function updateAimFromTouch(cx, cy) {
  const acx = getAimCenterX(), acy = getAimCenterY();
  touchAim.dx = cx - acx;
  touchAim.dy = cy - acy;
  const dist = Math.sqrt(touchAim.dx * touchAim.dx + touchAim.dy * touchAim.dy);
  if (dist > AIM_DEAD_ZONE) {
    touchAim.angle = Math.atan2(touchAim.dy, touchAim.dx);
    touchAim.active = true;
  }
}

let touchJumpQueued = false;
function updateTouchControlsFromActive() {

  if (moveJoystick.active) {
    const dist = Math.sqrt(moveJoystick.dx * moveJoystick.dx + moveJoystick.dy * moveJoystick.dy);
    touchControls.left = dist > MOVE_DEAD_ZONE && moveJoystick.dx < -MOVE_DEAD_ZONE;
    touchControls.right = dist > MOVE_DEAD_ZONE && moveJoystick.dx > MOVE_DEAD_ZONE;
  } else {
    touchControls.left = false;
    touchControls.right = false;
  }

  touchControls.up = moveJoystick.inJumpUp || touchJumpQueued;
}

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  mouseActive = false;
  for (const t of e.changedTouches) {
    const { x: cx, y: cy } = clientToCanvas(t.clientX, t.clientY);

    if (_showBetaPopup && window._betaOkBtn) {
      const ob = window._betaOkBtn;
      if (cx >= ob.x && cx <= ob.x + ob.w && cy >= ob.y && cy <= ob.y + ob.h) { _dismissBetaPopup(); return; }
      return;
    }

    if (_showPerfPrompt && window._perfYesBtn && window._perfNoBtn) {
      const yb = window._perfYesBtn, nb = window._perfNoBtn;
      if (cx >= yb.x && cx <= yb.x + yb.w && cy >= yb.y && cy <= yb.y + yb.h) { _acceptPerfMode(); return; }
      if (cx >= nb.x && cx <= nb.x + nb.w && cy >= nb.y && cy <= nb.y + nb.h) { _declinePerfMode(); return; }
      return;
    }

    if (cx > W - 48 && cy < 48) {
      toggleFullscreen();
      return;
    }

    if (activeTextInput === 'roomcode') {
      const overlayL = W/2 - 200, overlayT = H/2 - 60, overlayW = 400, overlayH = 120;

      const cancelY = overlayT + overlayH + 8, cancelH = 36;
      if (cx >= overlayL && cx <= overlayL + overlayW && cy >= cancelY && cy <= cancelY + cancelH) {
        deactivateTextInput(); return;
      }

      if (cx < overlayL || cx > overlayL + overlayW || cy < overlayT || cy > cancelY + cancelH) {
        deactivateTextInput(); return;
      }
      return;
    }

    if (activeTextInput === 'friendadd') {
      deactivateTextInput(); return;
    }

    if (state === 'menu') {
      if (menuState === 'main') {
        const menuY = H * 0.35;
        const menuSpacing = Math.min(40, (H * 0.40) / 8);
        for (let i = 0; i < 9; i++) {
          const y = menuY + i * menuSpacing;
          if (cx > W/2 - 160 && cx < W/2 + 160 && cy > y - 18 && cy < y + 18) {
            menuSelection = i;
            if (i === 0) {
              if (tutorialDone) { startGame(); }
              else { state = 'tutorial'; tutorialPage = 0; }
            }
            else if (i === 1) { startEndless(); }
            else if (i === 2) { menuState = 'multiplayer'; mpMenuSelection = 0; authError = ''; }
            else if (i === 3) { menuState = 'difficulty'; menuSelection = 0; }
            else if (i === 4) { menuState = 'settings'; menuSelection = 0; }
            else if (i === 5) { menuState = 'controls'; menuSelection = 0; }
            else if (i === 6) { friendsBackTo = 'main'; menuState = 'friends'; friendMenuSelection = 0; authError = ''; loadFriendsList(); }
            else if (i === 7) { menuState = 'credits'; menuSelection = 0; }
            else if (i === 8) { menuState = 'cheats'; cheatSelection = 0; }
            return;
          }
        }
      } else if (menuState === 'difficulty') {
        const diffY = H * 0.42;
        for (let i = 0; i < 4; i++) {
          const y = diffY + i * 55;
          if (cx > W/2 - 200 && cx < W/2 + 200 && cy > y - 22 && cy < y + 28) {
            const diffs = ['easy','normal','hard','insane'];
            settings.difficulty = diffs[i];
            menuState = 'main'; menuSelection = 2;
            return;
          }
        }
        if (cy > H * 0.85) { menuState = 'main'; menuSelection = 2; return; }
      } else if (menuState === 'settings') {
        const setY = H * 0.36;
        for (let i = 0; i < 8; i++) {
          const y = setY + i * 40;
          if (cx > W/2 - 200 && cx < W/2 + 200 && cy > y - 16 && cy < y + 20) {
            if (i === 0) settings.screenShake = !settings.screenShake;
            else if (i === 1) settings.particles = !settings.particles;
            else if (i === 2) settings.showFPS = !settings.showFPS;
            else if (i === 3) settings.doubleJump = !settings.doubleJump;
            else if (i === 4) settings.showTimer = !settings.showTimer;
            else if (i === 5) settings.colorblind = !settings.colorblind;
            else if (i === 6) { menuState = 'touchcontrols'; menuSelection = 0; }
            else if (i === 7) { menuState = 'main'; menuSelection = 3; }
            return;
          }
        }
      } else if (menuState === 'touchcontrols') {

        const presetKeys = Object.keys(TOUCH_PRESETS);
        const tcY = H * 0.36;
        for (let i = 0; i < presetKeys.length; i++) {
          const y = tcY + i * 36;
          if (cx > W/2 - 200 && cx < W/2 + 200 && cy > y - 14 && cy < y + 18) {
            touchPresetName = presetKeys[i];
            touchLayout = Object.assign({}, TOUCH_PRESETS[touchPresetName]);
            saveTouchLayout();
            return;
          }
        }

        const sizeY = tcY + presetKeys.length * 36 + 10;
        if (cx > W/2 - 80 && cx < W/2 - 40 && cy > sizeY - 10 && cy < sizeY + 20) {
          touchLayout.moveR = Math.max(35, touchLayout.moveR - 5); touchPresetName = 'custom'; saveTouchLayout(); return;
        }
        if (cx > W/2 + 40 && cx < W/2 + 80 && cy > sizeY - 10 && cy < sizeY + 20) {
          touchLayout.moveR = Math.min(100, touchLayout.moveR + 5); touchPresetName = 'custom'; saveTouchLayout(); return;
        }
        const sizeY2 = sizeY + 32;
        if (cx > W/2 - 80 && cx < W/2 - 40 && cy > sizeY2 - 10 && cy < sizeY2 + 20) {
          touchLayout.aimR = Math.max(35, touchLayout.aimR - 5); touchPresetName = 'custom'; saveTouchLayout(); return;
        }
        if (cx > W/2 + 40 && cx < W/2 + 80 && cy > sizeY2 - 10 && cy < sizeY2 + 20) {
          touchLayout.aimR = Math.min(100, touchLayout.aimR + 5); touchPresetName = 'custom'; saveTouchLayout(); return;
        }

        const resetY = sizeY2 + 36;
        if (cx > W/2 - 60 && cx < W/2 + 60 && cy > resetY - 12 && cy < resetY + 18) {
          touchPresetName = 'default'; touchLayout = Object.assign({}, TOUCH_PRESETS.default); saveTouchLayout(); return;
        }

        const backY = resetY + 36;
        if (cx > W/2 - 60 && cx < W/2 + 60 && cy > backY - 12 && cy < backY + 18) {
          menuState = 'settings'; menuSelection = 6; return;
        }

        if (cy > H * 0.7) {
          const pvTop = H * 0.7;
          const pvH = H - pvTop - 10;
          const pvCenterY = pvTop + pvH / 2 + 8;
          const pvScaleX = (W - 80) / W;
          const pvScaleR = 0.5;
          const pvMCX = 40 + touchLayout.moveX * pvScaleX;
          const pvMCY = pvCenterY;
          const pvACX = 40 + touchLayout.aimX * pvScaleX;
          const pvACY = pvCenterY;
          const mdx = cx - pvMCX, mdy = cy - pvMCY;
          const adx = cx - pvACX, ady = cy - pvACY;
          if (Math.sqrt(mdx*mdx + mdy*mdy) < touchLayout.moveR * pvScaleR + 30) {
            tcDragging = 'move'; tcDragOffX = mdx; tcDragOffY = mdy; return;
          }
          if (Math.sqrt(adx*adx + ady*ady) < touchLayout.aimR * pvScaleR + 30) {
            tcDragging = 'aim'; tcDragOffX = adx; tcDragOffY = ady; return;
          }
        }
      } else if (menuState === 'cheats') {
        const cheatKeys = Object.keys(cheats);
        const cheatY = H * 0.28;
        const totalItems = cheatKeys.length + 4;
        for (let i = 0; i < totalItems; i++) {
          const y = cheatY + i * 38;
          if (cx > W/2 - 220 && cx < W/2 + 220 && cy > y - 14 && cy < y + 18) {
            if (i < cheatKeys.length) cheats[cheatKeys[i]] = !cheats[cheatKeys[i]];
            else if (i === cheatKeys.length) {
              if (cx < W/2 + 120) endlessStartRound = Math.max(1, endlessStartRound - 1);
              else endlessStartRound = Math.min(200, endlessStartRound + 1);
            }
            else if (i === cheatKeys.length + 1) skipToFinalBoss();
            else if (i === cheatKeys.length + 2) watchCutscene();
            else { menuState = 'main'; menuSelection = 7; }
            return;
          }
        }
      } else if (menuState === 'multiplayer') {
        const mpItems = ['CREATE ROOM', 'JOIN ROOM', 'FRIENDS', 'BACK'];
        const mpY = H * 0.40;
        const mpSpacing = Math.min(50, (H * 0.28) / (mpItems.length - 1));
        for (let i = 0; i < mpItems.length; i++) {
          const y = mpY + i * mpSpacing;
          if (cx > W/2 - 180 && cx < W/2 + 180 && cy > y - 24 && cy < y + 24) {
            if (i === 0) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else createRoom(); }
            else if (i === 1) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else { activateTextInput('roomcode'); joinRoomInput = ''; } }
            else if (i === 2) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else { friendsBackTo = 'multiplayer'; menuState = 'friends'; friendMenuSelection = 0; authError = ''; loadFriendsList(); } }
            else if (i === 3) { menuState = 'main'; menuSelection = 1; }
            return;
          }
        }
        if (!playerUsername) {
          if (cy > H * 0.76 && cy < H * 0.87) { menuState = 'account'; authInputField = 0; authScreen = 'login'; authError = ''; return; }
        } else {
          if (cy > H * 0.72 && cy < H * 0.82) { logoutAccount(); return; }
        }
      } else if (menuState === 'account') {
        const accY = H * 0.38;
        if (cy > accY - 14 && cy < accY + 32) { activateTextInput('username'); return; }
        if (cy > accY + 34 && cy < accY + 78) { activateTextInput('password'); return; }
        if (authScreen === 'register' && cy > accY + 82 && cy < accY + 130) { activateTextInput('confirm'); return; }
        const btnY = authScreen === 'register' ? accY + 150 : accY + 100;
        if (cy > btnY - 14 && cy < btnY + 32) {
          if (authScreen === 'register') registerAccount(authInputs.username, authInputs.password);
          else loginAccount(authInputs.username, authInputs.password);
          return;
        }
        if (cy > btnY + 25 && cy < btnY + 60) { authScreen = authScreen === 'login' ? 'register' : 'login'; return; }
        if (cy > btnY + 55 && cy < btnY + 90) { playAsGuest(); return; }
        if (cy > H * 0.88) { authError = ''; menuState = 'multiplayer'; return; }
      } else if (menuState === 'lobby') {

        const colL = W/2 - 250;
        const colR = W/2 + 10;
        const colW = 230;
        const chatBoxY = H * 0.42;
        const chatBoxH = H * 0.40;
        if (cx > colL && cx < colL + colW && cy > chatBoxY && cy < chatBoxY + chatBoxH) {
          chatOpen = true; activateTextInput('chat'); chatInput = ''; return;
        }

        if (isHost && cx > colR && cx < colR + colW) {
          const settY = H * 0.26;
          for (let i = 0; i < 9; i++) {
            const SETT_SP = 34;
            const y = settY + i * SETT_SP;
            if (cy > y - 16 && cy < y + SETT_SP - 18) {
              mpSettingsSelection = i;
              if (i === 0) {
                mpGameMode = mpGameMode === 'story' ? 'endless' : 'story';
              } else if (i === 1) {
                const diffs = ['easy','normal','hard','insane'];
                let idx = diffs.indexOf(settings.difficulty);
                settings.difficulty = diffs[(idx + 1) % diffs.length];
              } else if (i === 2) { settings.doubleJump = !settings.doubleJump; }
              else if (i === 3) { cheats.godMode = !cheats.godMode; }
              else if (i === 4) { cheats.oneHitKill = !cheats.oneHitKill; }
              else if (i === 5) { cheats.infiniteJumps = !cheats.infiniteJumps; }
              else if (i === 6) { cheats.speedBoost = !cheats.speedBoost; }
              else if (i === 7) { cheats.bigProjectiles = !cheats.bigProjectiles; }
              else if (i === 8) { cheats.noCooldown = !cheats.noCooldown; }
              mpSyncLobbySettings();
              return;
            }
          }
        }
        if (isHost && cy > H * 0.84) { startMultiplayerGame(); return; }
        if (cx < 160 && cy < 60) { leaveRoom(); return; }
      } else if (menuState === 'friends') {
        const tabW = W / 4;
        if (cy > H * 0.25 && cy < H * 0.33) { friendTab = Math.min(3, Math.floor(cx / tabW)); friendMenuSelection = 0; return; }
        if (friendTab === 3 && cy > H * 0.38 && cy < H * 0.52) { activateTextInput('friendadd'); friendInput = ''; return; }
        const items = friendTab === 0 ? friendsList : friendTab === 1 ? friendRequests : friendTab === 2 ? blockedUsers : [];
        const listY = H * 0.42;
        for (let i = 0; i < items.length; i++) {
          const y = listY + i * 36;
          if (cy > y - 14 && cy < y + 24) {
            friendMenuSelection = i;
            if (cx > W - 120) {
              if (friendTab === 0) removeFriend(items[i].uid);
              else if (friendTab === 1) { if (cx > W - 60) declineFriendRequest(items[i].uid); else acceptFriendRequest(items[i].uid); }
              else if (friendTab === 2) unblockUser(items[i].uid);
            }
            return;
          }
        }
        if (cy > H * 0.88) {
          if (friendsBackTo === 'multiplayer') { menuState = 'multiplayer'; mpMenuSelection = 0; }
          else { menuState = 'main'; menuSelection = 5; }
          return;
        }
      } else if (menuState === 'controls' || menuState === 'credits') {
        const wasCredits = menuState === 'credits';
        menuState = 'main'; menuSelection = wasCredits ? 6 : 4;
        return;
      }
      return;
    }

    if (state === 'tutorial') {
      if (cx < W * 0.3 && tutorialPage > 0) { tutorialPage--; }
      else { tutorialPage++; if (tutorialPage >= 5) completeTutorial(); }
      return;
    }

    if ((state === 'cutscene' || state === 'phonecall' || state === 'fusioncutscene' || state === 'bossdialogue' || state === 'hawkingRefusal' || state === 'hawkingDeath' || state === 'winCutscene') && cx > W - 140 && cy < 60) {
      if (state === 'cutscene') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { cutscene.phase = 3; cutscene.fadeAlpha = 1; cutscene.timer = 0; } }
      else if (state === 'phonecall') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { phonecallTimer = 1; } }
      else if (state === 'fusioncutscene') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { fusionCutsceneTimer = 1; } }
      else if (state === 'hawkingRefusal') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { hawkingRefusalTimer = 1129; } }
      else if (state === 'hawkingDeath') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { hawkingDeathTimer = 899; } }
      else if (state === 'winCutscene') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { winCutsceneTimer = 699; } }
      else if (state === 'bossdialogue') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { bossDialogue.index = bossDialogue.texts.length; advanceCutscene(); } }
      return;
    }

    if (state === 'cutscene' || state === 'bossdialogue') {
      if (mpEnabled && !isHost) { mpSendCutsceneEvent('advance'); } else { advanceCutscene(); } return;
    }
    if ((state === 'won' || state === 'dead') && restartCooldown <= 0) {

      const btnY = state === 'won' ? H/2 + 30 : H/2 + 20;
      const btnW = 160, btnH = 48;
      if (cy > btnY && cy < btnY + btnH) {
        if (cx > W/2 - btnW - 10 && cx < W/2 - 10) {

          if (mpEnabled) { mpVoteRetry(); if (isHost) { const tc = Object.keys(roomPlayers).length; const rc = Object.keys(mpRetryVotes).length; if (rc >= tc) mpTriggerRetry(); } } else if (endless.round > 0) { startEndless(); } else { startGame(); }
        } else if (cx > W/2 + 10 && cx < W/2 + btnW + 10) {

          if (mpEnabled) { leaveRoom(); } endless.round = 0; state = 'menu'; menuState = 'main'; menuSelection = 0;
        }
      }
      return;
    }

    if (state === 'endlessShop' && endless.shopChoices.length > 0 && !endless.shopPicked) {
      const cardW = Math.min(220, (W - 60) / 3);
      const cardH = 240;
      const cardGap = 16;
      const totalW3 = cardW * endless.shopChoices.length + cardGap * (endless.shopChoices.length - 1);
      const startX3 = W / 2 - totalW3 / 2;
      const cardY3 = H * 0.3;
      for (let ci = 0; ci < endless.shopChoices.length; ci++) {
        const cxCard = startX3 + ci * (cardW + cardGap);
        if (cx > cxCard && cx < cxCard + cardW && cy > cardY3 && cy < cardY3 + cardH) {
          endless.shopSelection = ci;
          const key = endless.shopChoices[ci];
          if (mpEnabled) {
            db.ref('rooms/' + currentRoom + '/shopPicks/' + myUid()).set(key);
            endless.shopPicked = true;
          } else {
            endlessApplyPowerup(key);
            endlessNextRound();
          }
          return;
        }
      }
      return;
    }

    if (state === 'playing' || state === 'intro' || state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight' || state === 'endless') {

      if (mpSpectating) {
        const alive = getAlivePlayerList();
        if (alive.length > 0) {
          if (cx < W / 2) {
            mpSpectateIndex = (mpSpectateIndex - 1 + alive.length) % alive.length;
          } else {
            mpSpectateIndex = (mpSpectateIndex + 1) % alive.length;
          }
          mpSpectateTarget = alive[mpSpectateIndex].uid;
        }
        return;
      }

      const MCY_t = getMoveCenterY();
      const dashBtnX = W / 2, dashBtnY = MCY_t + 10, dashBtnR = 48;
      if (state === 'endless' && endless.powerups && endless.powerups.dash > 0 && endless.dashCooldown <= 0) {
        const ddx = cx - dashBtnX, ddy = cy - dashBtnY;
        if (Math.sqrt(ddx*ddx + ddy*ddy) < dashBtnR) {
          touchDashQueued = true;
          return;
        }
      }

      if (isInAimZone(cx, cy)) {
        aimTouchId = t.identifier;
        updateAimFromTouch(cx, cy);
        updateTouchControlsFromActive();
        throwProjectile();
      }

      else if (isInMoveZone(cx, cy)) {
        moveJoystick.touchId = t.identifier;
        moveJoystick.active = true;
        moveJoystick.dx = cx - getMoveCenterX();
        moveJoystick.dy = cy - getMoveCenterY();

        if (moveJoystick.dy < MOVE_JUMP_THRESHOLD) {
          moveJoystick.inJumpUp = true;
          touchJumpQueued = true;
          touchControls.up = true;
        }
        updateTouchControlsFromActive();
      }
    }
  }
}, { passive: false });

function clearTouch(id) {
  if (id === aimTouchId) { aimTouchId = null; touchAim.active = false; touchAim.dx = 0; touchAim.dy = 0; }
  if (id === moveJoystick.touchId) { moveJoystick.touchId = null; moveJoystick.active = false; moveJoystick.dx = 0; moveJoystick.dy = 0; moveJoystick.inJumpUp = false; }
}

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  if (tcDragging) { tcDragging = null; return; }
  for (const t of e.changedTouches) clearTouch(t.identifier);
  updateTouchControlsFromActive();
}, { passive: false });

canvas.addEventListener('touchcancel', e => {
  e.preventDefault();
  tcDragging = null;
  for (const t of e.changedTouches) clearTouch(t.identifier);
  updateTouchControlsFromActive();
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();

  if (tcDragging && state === 'menu' && menuState === 'touchcontrols') {
    const t = e.changedTouches[0];
    const { x: cx, y: cy } = clientToCanvas(t.clientX, t.clientY);
    const pvScaleX = (W - 80) / W;
    const newX = Math.max(60, Math.min(W - 60, (cx - tcDragOffX - 40) / pvScaleX));
    if (tcDragging === 'move') { touchLayout.moveX = Math.round(newX); }
    else if (tcDragging === 'aim') { touchLayout.aimX = Math.round(newX); }
    touchPresetName = 'custom';
    saveTouchLayout();
    return;
  }
  for (const t of e.changedTouches) {

    if (t.identifier === aimTouchId) {
      const { x: cx, y: cy } = clientToCanvas(t.clientX, t.clientY);
      updateAimFromTouch(cx, cy);
    }

    if (t.identifier === moveJoystick.touchId) {
      const { x: cx, y: cy } = clientToCanvas(t.clientX, t.clientY);
      moveJoystick.dx = cx - getMoveCenterX();
      moveJoystick.dy = cy - getMoveCenterY();

      if (moveJoystick.dy < MOVE_JUMP_THRESHOLD && !moveJoystick.inJumpUp) {
        moveJoystick.inJumpUp = true;
        touchJumpQueued = true;
        touchControls.up = true;
      } else if (moveJoystick.dy >= MOVE_JUMP_THRESHOLD) {
        moveJoystick.inJumpUp = false;
      }
      updateTouchControlsFromActive();
    }
  }
}, { passive: false });

let player = createPlayer();
function createPlayer() {
  return {
    x: 80, y: GROUND_Y - 80,
    w: 52, h: 80,
    vx: 0, vy: 0,
    onGround: false,
    onWall: false,
    wallDir: 0,
    climbingBigWall: false,
    jumpBuffer: 0,
    coyoteTime: 0,
    facing: 1,
    runFrame: 0,
    runTimer: 0,
    alive: true,
    won: false,
    trail: [],
    hp: 15,
    maxHp: 15,
    throwCooldown: 0,
    iFrames: 0,
    jumpsLeft: 2,
    maxJumps: 2,
    prevUp: false,
  };
}

let walls = [];
let guards = [];
let bigWall = null;
let decorations = [];

let _levelSeed = 0;
function _seedFromRoom() {

  if (currentRoom) {
    let h = 0;
    for (let i = 0; i < currentRoom.length; i++) {
      h = ((h << 5) - h + currentRoom.charCodeAt(i)) | 0;
    }
    _levelSeed = h >>> 0;
  } else {
    _levelSeed = (Math.random() * 0xFFFFFFFF) >>> 0;
  }
}
function _seededRandom() {
  _levelSeed |= 0; _levelSeed = (_levelSeed + 0x6D2B79F5) | 0;
  let t = Math.imul(_levelSeed ^ (_levelSeed >>> 15), 1 | _levelSeed);
  t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
  return ((t ^ (t >>> 14)) >>> 0) / 0x100000000;
}

function buildLevel() {
  walls = [];
  guards = [];
  decorations = [];
  _seedFromRoom();

  const wallPositions = [400, 800, 1300, 1800, 2400, 3000];
  wallPositions.forEach((x, i) => {
    const h = 70 + _seededRandom() * 40;
    walls.push({ x, y: GROUND_Y - h, w: 50, h, color: '#b08040' });
  });

  const platforms = [
    { x: 500, y: GROUND_Y - 140, w: 120 },
    { x: 1000, y: GROUND_Y - 150, w: 140 },
    { x: 1400, y: GROUND_Y - 130, w: 110 },
    { x: 1900, y: GROUND_Y - 160, w: 130 },
    { x: 2300, y: GROUND_Y - 140, w: 120 },
    { x: 2900, y: GROUND_Y - 170, w: 140 },
  ];
  platforms.forEach(p => {
    walls.push({ x: p.x, y: p.y, w: p.w, h: 20, color: '#666', isPlatform: true });
  });

  const dmGuards = getDiffMult();
  const guardSpots = [
    { x: 500, range: 100 },
    { x: 850, range: 90 },
    { x: 1200, range: 110 },
    { x: 1600, range: 100 },
    { x: 2000, range: 90 },
    { x: 2500, range: 110 },
    { x: 2900, range: 100 },
  ];
  guardSpots.forEach(g => {
    guards.push({
      x: g.x, y: GROUND_Y - 84,
      w: 56, h: 84,
      startX: g.x,
      range: g.range,
      speed: (1.2 + _seededRandom() * 0.7) * dmGuards.enemySpeed,
      dir: _seededRandom() > 0.5 ? 1 : -1,
      alert: false,
      alertTimer: 0,
      frame: 0,
      frameTimer: 0,
      hp: Math.ceil(3 * dmGuards.enemyHp),
      maxHp: Math.ceil(3 * dmGuards.enemyHp),
      climbing: false,
      shootCooldown: 60 + Math.floor(_seededRandom() * 60),
      dead: false,
    });
  });

  bigWall = {
    x: levelWidth - 900,
    y: GROUND_Y - 1200,
    w: 800,
    h: 1200,
  };

  for (let i = 0; i < 40; i++) {
    const rng = _seededRandom();
    let type;
    if (rng < 0.35) type = 'cactus';
    else if (rng < 0.55) type = 'tumbleweed';
    else if (rng < 0.75) type = 'rock';
    else type = 'scrub';
    decorations.push({
      x: _seededRandom() * levelWidth,
      y: GROUND_Y,
      type,
      size: 14 + _seededRandom() * 30,
    });
  }
}

function skipToFinalBoss() {

  player = createPlayer();
  buildLevel();
  particles = [];
  projectiles = [];
  epsteinProjectiles = [];
  epstein = null;
  phonecallTimer = 0;
  fusionBoss = null;
  fusionCutsceneTimer = 0;
  bullets = [];
  cameraX = 0;
  cameraY = 0;
  boss = null;
  bossMinions = [];
  bossVfx = [];
  bossDeathTimer = 0;
  screenFlash = 0;
  hawkingPhase2 = false;
  hawkingRefusalTimer = 0;
  hawkingRefusalPhase = 0;
  hawkingDeathTimer = 0;
  hawkingDeathPhase = 0;
  winCutsceneTimer = 0;
  winCutsceneOfficeX = 0;
  bossIntroTimer = 0;
  bossDialogue = { active: false, texts: [], index: 0, timer: 0 };
  gameTimer = 0;
  restartCooldown = 0;

  const dm = getDiffMult();

  const arenaW = 2400;
  const arenaH = 800;
  const arenaLeft = bigWall.x + bigWall.w / 2 - arenaW / 2;
  const arenaRight = arenaLeft + arenaW;
  const arenaTop = bigWall.y + 40;
  const arenaBottom = arenaTop + arenaH;
  arenaPlats = [
    { x: arenaLeft, y: arenaBottom, w: arenaW, h: 30, isArena: true, isFloor: true },
    { x: arenaLeft, y: arenaTop, w: arenaW, h: 20, isArena: true, isCeiling: true },
    { x: arenaLeft - 40, y: arenaTop, w: 40, h: arenaH + 30, isArena: true, isSideWall: true },
    { x: arenaRight, y: arenaTop, w: 40, h: arenaH + 30, isArena: true, isSideWall: true },
    { x: arenaLeft + 120, y: arenaBottom - 180, w: 200, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + 500, y: arenaBottom - 280, w: 220, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + arenaW / 2 - 120, y: arenaBottom - 400, w: 240, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 720, y: arenaBottom - 280, w: 220, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 320, y: arenaBottom - 180, w: 200, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + 300, y: arenaBottom - 100, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaLeft + arenaW / 2 - 60, y: arenaBottom - 150, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaRight - 420, y: arenaBottom - 100, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaLeft + 80, y: arenaBottom - 450, w: 160, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 240, y: arenaBottom - 450, w: 160, h: 18, isArena: true, isPlatform: true },
  ];

  const miniDefs = [
    { name: 'TRUMP', img: 'boss', color: '#ff4400', hp: Math.ceil(18 * dm.enemyHp), speed: 2.8 * dm.enemySpeed },
    { name: 'EPSTEIN', img: 'epstein', color: '#8844ff', hp: Math.ceil(15 * dm.enemyHp), speed: 3.2 * dm.enemySpeed },
    { name: 'MUSK', img: 'musk', color: '#4488ff', hp: Math.ceil(15 * dm.enemyHp), speed: 3.8 * dm.enemySpeed },
    { name: 'CLINTON', img: 'clinton', color: '#cc2222', hp: Math.ceil(12 * dm.enemyHp), speed: 2.5 * dm.enemySpeed },
    { name: 'HAWKING', img: 'hawking', color: '#44ff88', hp: Math.ceil(35 * dm.enemyHp), speed: 1.0 * dm.enemySpeed },
  ];
  miniBosses = [];
  for (let i = 0; i < miniDefs.length; i++) {
    const md = miniDefs[i];
    const bx = arenaLeft + arenaW * (0.55 + i * 0.08);
    const by = i === 4 ? (arenaBottom - 280) : (arenaBottom - 100 - Math.random() * 60);
    miniBosses.push({
      x: bx - 40, y: by - 50,
      w: 80, h: 100,
      hp: md.hp, maxHp: md.hp,
      name: md.name, imgKey: md.img, color: md.color,
      dir: -1,
      speed: md.speed,
      frame: 0, frameTimer: 0,
      dead: false,
      vy: 0, vx: 0,
      shootCooldown: 60 + i * 15,
      attackTimer: 0,
    });
  }

  player.maxHp = 50;
  player.hp = player.maxHp;
  player.x = arenaLeft + arenaW * 0.15;
  player.y = arenaBottom - player.h - 10;
  player.facing = 1;

  state = 'splitfight';
  bossIntroTimer = 0;
  screenFlash = 30;
  screenFlashColor = '#ffffff';
  shakeTimer = 20;
}

function watchCutscene() {

  player = createPlayer();
  buildLevel();
  particles = [];
  projectiles = [];
  epsteinProjectiles = [];
  epstein = null;
  phonecallTimer = 0;
  fusionBoss = null;
  fusionCutsceneTimer = 0;
  bullets = [];
  cameraX = 0;
  cameraY = 0;
  boss = null;
  bossMinions = [];
  bossVfx = [];
  bossDeathTimer = 0;
  screenFlash = 0;
  hawkingPhase2 = false;
  hawkingRefusalTimer = 0;
  hawkingRefusalPhase = 0;
  hawkingDeathTimer = 0;
  hawkingDeathPhase = 0;
  winCutsceneTimer = 0;
  winCutsceneOfficeX = 0;
  bossIntroTimer = 0;
  bossDialogue = { active: false, texts: [], index: 0, timer: 0 };
  gameTimer = 0;
  restartCooldown = 0;

  const arenaW = 2400;
  const arenaH = 800;
  const arenaLeft = bigWall.x + bigWall.w / 2 - arenaW / 2;
  const arenaRight = arenaLeft + arenaW;
  const arenaTop = bigWall.y + 40;
  const arenaBottom = arenaTop + arenaH;
  arenaPlats = [
    { x: arenaLeft, y: arenaBottom, w: arenaW, h: 30, isArena: true, isFloor: true },
    { x: arenaLeft, y: arenaTop, w: arenaW, h: 20, isArena: true, isCeiling: true },
    { x: arenaLeft - 40, y: arenaTop, w: 40, h: arenaH + 30, isArena: true, isSideWall: true },
    { x: arenaRight, y: arenaTop, w: 40, h: arenaH + 30, isArena: true, isSideWall: true },
    { x: arenaLeft + 120, y: arenaBottom - 180, w: 200, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + 500, y: arenaBottom - 280, w: 220, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + arenaW / 2 - 120, y: arenaBottom - 400, w: 240, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 720, y: arenaBottom - 280, w: 220, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 320, y: arenaBottom - 180, w: 200, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + 300, y: arenaBottom - 100, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaLeft + arenaW / 2 - 60, y: arenaBottom - 150, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaRight - 420, y: arenaBottom - 100, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaLeft + 80, y: arenaBottom - 450, w: 160, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 240, y: arenaBottom - 450, w: 160, h: 18, isArena: true, isPlatform: true },
  ];

  const dm2 = getDiffMult();
  const miniDefs = [
    { name: 'TRUMP', img: 'boss', color: '#ff4400', hp: Math.ceil(18 * dm2.enemyHp), speed: 2.8 * dm2.enemySpeed },
    { name: 'EPSTEIN', img: 'epstein', color: '#8844ff', hp: Math.ceil(15 * dm2.enemyHp), speed: 3.2 * dm2.enemySpeed },
    { name: 'MUSK', img: 'musk', color: '#4488ff', hp: Math.ceil(15 * dm2.enemyHp), speed: 3.8 * dm2.enemySpeed },
    { name: 'CLINTON', img: 'clinton', color: '#cc2222', hp: Math.ceil(12 * dm2.enemyHp), speed: 2.5 * dm2.enemySpeed },
    { name: 'HAWKING', img: 'hawking', color: '#44ff88', hp: Math.ceil(35 * dm2.enemyHp), speed: 1.0 * dm2.enemySpeed },
  ];
  const cx = arenaLeft + arenaW / 2;
  const cy = arenaTop + arenaH / 2;
  miniBosses = [];
  for (let i = 0; i < miniDefs.length; i++) {
    const angle = (i / miniDefs.length) * Math.PI * 2 - Math.PI / 2;
    const spawnDist = 120;
    const md = miniDefs[i];
    miniBosses.push({
      x: cx + Math.cos(angle) * spawnDist - 40,
      y: cy + Math.sin(angle) * spawnDist - 50,
      w: 80, h: 100,
      hp: md.hp, maxHp: md.hp,
      name: md.name, imgKey: md.img, color: md.color,
      dir: Math.random() > 0.5 ? 1 : -1,
      speed: md.speed,
      frame: 0, frameTimer: 0,
      dead: false,
      vy: 0, vx: 0,
      shootCooldown: 60 + i * 15,
      attackTimer: 0,
    });
  }

  player.maxHp = 50;
  player.hp = player.maxHp;
  player.x = arenaLeft + arenaW * 0.15;
  player.y = arenaBottom - player.h - 10;
  player.facing = 1;

  state = 'splitfight';
  bossIntroTimer = 1800;
  screenFlash = 40;
  screenFlashColor = '#ffffff';
  shakeTimer = 20;
}

function startGame() {
  player = createPlayer();
  buildLevel();
  particles = [];
  projectiles = [];
  epsteinProjectiles = [];

  moveJoystick.active = false; moveJoystick.touchId = null; moveJoystick.dx = 0; moveJoystick.dy = 0; moveJoystick.inJumpUp = false;
  touchAim.active = false; aimTouchId = null; touchControls.left = false; touchControls.right = false; touchControls.up = false;
  epstein = null;
  phonecallTimer = 0;
  fusionBoss = null;
  fusionCutsceneTimer = 0;
  miniBosses = [];
  bullets = [];
  cameraX = 0;
  cameraY = 0;
  mpDeathSynced = false;
  mpSpectating = false;
  mpSpectateTarget = null;
  mpSpectateIndex = 0;
  mpRetryVotes = {};
  mpRetrySelection = 0;

  boss = null;
  bossMinions = [];
  bossVfx = [];
  bossDeathTimer = 0;
  screenFlash = 0;
  hawkingPhase2 = false;
  hawkingRefusalTimer = 0;
  hawkingRefusalPhase = 0;
  hawkingDeathTimer = 0;
  hawkingDeathPhase = 0;
  winCutsceneTimer = 0;
  winCutsceneOfficeX = 0;
  bossIntroTimer = 0;
  bossDialogue = { active: false, texts: [], index: 0, timer: 0 };

  const arenaW = 2400;
  const arenaH = 800;
  const arenaLeft = bigWall.x + bigWall.w / 2 - arenaW / 2;
  const arenaRight = arenaLeft + arenaW;
  const arenaTop = bigWall.y + 40;
  const arenaBottom = arenaTop + arenaH;
  arenaPlats = [

    { x: arenaLeft, y: arenaBottom, w: arenaW, h: 30, isArena: true, isFloor: true },

    { x: arenaLeft, y: arenaTop, w: arenaW, h: 20, isArena: true, isCeiling: true },

    { x: arenaLeft - 40, y: arenaTop, w: 40, h: arenaH + 30, isArena: true, isSideWall: true },

    { x: arenaRight, y: arenaTop, w: 40, h: arenaH + 30, isArena: true, isSideWall: true },

    { x: arenaLeft + 120, y: arenaBottom - 180, w: 200, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + 500, y: arenaBottom - 280, w: 220, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + arenaW / 2 - 120, y: arenaBottom - 400, w: 240, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 720, y: arenaBottom - 280, w: 220, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 320, y: arenaBottom - 180, w: 200, h: 18, isArena: true, isPlatform: true },

    { x: arenaLeft + 300, y: arenaBottom - 100, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaLeft + arenaW / 2 - 60, y: arenaBottom - 150, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaRight - 420, y: arenaBottom - 100, w: 120, h: 14, isArena: true, isPlatform: true },

    { x: arenaLeft + 80, y: arenaBottom - 450, w: 160, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 240, y: arenaBottom - 450, w: 160, h: 18, isArena: true, isPlatform: true },
  ];

  cutscene = {
    active: false, timer: 0, phase: 0, dialogueIndex: 0,
    dialogues: [
      '...',
      'Well, well, well... Look who made it to the WALL.',
      'Welcome to MY border. The BEST wall. TREMENDOUS.',
      'Nobody gets through. NOBODY.',
      'I\'m gonna Make America Great Again!',
      'You think you can cross MY wall? NOT HAPPENING!',
      'Now get ready to be DEPORTED! BIGLY!',
    ],
    fadeAlpha: 0,
  };

  introTimer = 0;
  introPhase = 0;
  introParticles = [];
  gameTimer = 0;

  const dm = getDiffMult();
  player.hp = dm.playerHp;
  player.maxHp = dm.playerHp;
  state = 'intro';
  restartCooldown = 30;
}

function advanceCutscene() {

  if (state === 'bossdialogue') {
    bossDialogue.index++;
    if (bossDialogue.index >= bossDialogue.texts.length) {
      bossDialogue.active = false;

      if (fusionBoss && !fusionBoss.dead) state = 'fusionfight';
      else if (miniBosses.length > 0 && !miniBosses.every(m => m.dead)) state = 'splitfight';
      else if (epstein && !epstein.dead) state = 'epsteinfight';
      else state = 'bossfight';
    }
    bossDialogue.timer = 0;
    return;
  }
  if (cutscene.phase === 0) return;
  if (cutscene.phase === 1) {

    cutscene.phase = 2;
    cutscene.dialogueIndex = 0;
    cutscene.timer = 0;
  } else if (cutscene.phase === 2) {
    cutscene.dialogueIndex++;
    if (cutscene.dialogueIndex >= cutscene.dialogues.length) {
      cutscene.phase = 3;
      cutscene.timer = 0;
    }
  }
}

function throwProjectile() {
  if (!player.alive) return;
  if (state === 'hawkingDeath' || state === 'hawkingRefusal') return;
  const p = player;
  if (p.throwCooldown > 0 && !cheats.noCooldown) return;

  let baseCooldown = 18;
  if (state === 'endless' && endless.powerups.cooldownReduce > 0) {
    baseCooldown = Math.round(18 * Math.pow(0.85, endless.powerups.cooldownReduce));
  }
  p.throwCooldown = cheats.noCooldown ? 0 : baseCooldown;

  let vx, vy;
  let pjSpd = cheats.bigProjectiles ? 20 : 12;

  if (state === 'endless' && endless.powerups.projSpeed > 0) {
    pjSpd *= (1 + endless.powerups.projSpeed * 0.15);
  }

  const endlessExtraShots = (state === 'endless') ? endless.powerups.multiShot : 0;
  if (touchAim.active) {

    vx = Math.cos(touchAim.angle) * pjSpd;
    vy = Math.sin(touchAim.angle) * pjSpd;
    p.facing = vx > 0 ? 1 : -1;
  } else if (mouseActive) {

    const ez = ((state === 'endless' || state === 'endlessShop') && endless.endlessZoom < 0.99) ? endless.endlessZoom : 1;
    const px = (p.x + p.w/2 - cameraX) * ez;
    const py = (p.y + p.h/3 - cameraY) * ez;
    const dx = mouseX - px;
    const dy = mouseY - py;
    const dist = Math.sqrt(dx*dx + dy*dy) || 1;
    vx = (dx / dist) * pjSpd;
    vy = (dy / dist) * pjSpd;
    p.facing = vx > 0 ? 1 : -1;
  } else {
    vx = p.facing * pjSpd;
    vy = 0;
  }
  const pjSize = cheats.bigProjectiles ? 50 : 28;

  let endlessDmgMult = (state === 'endless') ? (1 + endless.powerups.dmgBoost * 0.20) : 1;

  if (state === 'endless' && endless.powerups.lastStand > 0 && p.hp <= p.maxHp * 0.25) {
    endlessDmgMult *= (1 + endless.powerups.lastStand * 0.5);
  }

  const isCrit = (state === 'endless' && endless.powerups.critChance > 0 && Math.random() < endless.powerups.critChance * 0.15);
  if (isCrit) endlessDmgMult *= 2;
  const isExplosive = (state === 'endless') && endless.powerups.explosiveShot > 0;
  const isStunning = (state === 'endless') && endless.powerups.heavyImpact > 0;
  projectiles.push({
    x: p.x + p.w / 2,
    y: p.y + p.h / 3,
    vx: vx,
    vy: vy,
    w: pjSize,
    h: pjSize,
    life: 100,
    dmgMult: endlessDmgMult,
    explosive: isExplosive,
    explosionRadius: isExplosive ? (80 + endless.powerups.explosiveShot * 40) : 0,
    stunning: isStunning,
    stunDuration: isStunning ? (20 + endless.powerups.heavyImpact * 15) : 0,
    crit: isCrit,
  });

  for (let es = 0; es < endlessExtraShots; es++) {
    const spreadAngle = (es + 1) * 0.22 * ((es % 2 === 0) ? 1 : -1);
    const cos = Math.cos(spreadAngle), sin = Math.sin(spreadAngle);
    projectiles.push({
      x: p.x + p.w / 2,
      y: p.y + p.h / 3,
      vx: vx * cos - vy * sin,
      vy: vx * sin + vy * cos,
      w: pjSize,
      h: pjSize,
      life: 100,
      dmgMult: endlessDmgMult,
      explosive: isExplosive,
      explosionRadius: isExplosive ? (80 + endless.powerups.explosiveShot * 40) : 0,
    });
  }
}

function rectsOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

const MAX_PARTICLES = 800;
function spawnParticles(x, y, color, count) {
  if (!settings.particles) return;
  if (particles.length >= MAX_PARTICLES) return;
  const allowed = Math.min(count, MAX_PARTICLES - particles.length);
  for (let i = 0; i < allowed; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 1) * 5,
      life: 30 + Math.random() * 30,
      color,
      size: 2 + Math.random() * 3,
    });
  }
}

function cbColor(normal, colorblindAlt) {
  return settings.colorblind ? colorblindAlt : normal;
}

function cbHP(pct) {
  if (settings.colorblind) {
    if (pct > 0.5) return { a: '#2299cc', b: '#44ddff' };
    if (pct > 0.25) return { a: '#aa8800', b: '#ffcc22' };
    return { a: '#cc4400', b: '#ff8800' };
  }
  if (pct > 0.5) return { a: '#22aa22', b: '#44ff44' };
  if (pct > 0.25) return { a: '#aa8800', b: '#ffcc22' };
  return { a: '#aa2222', b: '#ff4444' };
}

function update() {
  if (restartCooldown > 0) restartCooldown--;
  if (shakeTimer > 0 && settings.screenShake) shakeTimer--;
  else if (!settings.screenShake) shakeTimer = 0;

  if (state === 'deathAnim') {
    deathAnimTimer++;

    if (deathAnimTimer === 1 && !deathAnimVideoPlaying) {
      deathAnimVideoPlaying = true;
      _deathVid.currentTime = 0;
      _deathVid.play().catch(function() {});
    }

    if ((deathAnimVideoPlaying && _deathVid.ended) || deathAnimTimer > 300) {
      _deathVid.pause();
      state = 'dead';
      restartCooldown = 20;

      if (endless.round > 0 && endless.round > endless.highScore) {
        endless.highScore = endless.round;
        localStorage.setItem('endlessHighScore', String(endless.highScore));
      }
    }
  }

  for (let i = mpToasts.length - 1; i >= 0; i--) {
    mpToasts[i].life--;
    if (mpToasts[i].life <= 0) mpToasts.splice(i, 1);
  }

  if (mpEnabled && player) {
    syncMyPosition();
    if (isHost) syncEnemyData();
    if (!isHost) applyEnemyData();

    if (!player.alive && state === 'dead' && !mpDeathSynced) {
      mpDeathSynced = true;
      syncMyPositionImmediate();
    }
    if (player.alive) mpDeathSynced = false;

    if (isHost && !player.alive && state !== 'dead' && state !== 'won' && state !== 'menu') {
      const anyAlive = Object.keys(roomPlayers).some(pid => {
        const rp = roomPlayers[pid];
        return rp && rp.alive && rp.hp > 0;
      });
      if (!anyAlive) {
        state = 'dead';
        mpSpectating = false;
        restartCooldown = 60;
      }
    }

    if (isHost && (state === 'won' || state === 'dead') && restartCooldown <= 0) {
      const totalPlayers = Object.keys(roomPlayers).length;
      const retryCount = Object.keys(mpRetryVotes).length;
      if (retryCount > 0 && retryCount >= totalPlayers) {
        mpTriggerRetry();
      }
    }
  }
  textCursorBlink = (textCursorBlink + 1) % 60;

  if (cheats.godMode && player.alive) {
    player.hp = player.maxHp;
  }

  if (state === 'hawkingDeath' || (state === 'splitfight' && bossIntroTimer > 0)) {
    player.iFrames = Math.max(player.iFrames, 5);
  }

  if (state === 'menu' || state === 'tutorial') {
    menuBgTimer++;
    menuBgFloorY = H - 100;

    if (menuBgTimer % 40 === 0) {
      menuBgBullets.push({
        x: W + 10, y: menuBgFloorY - 20 - Math.random() * 60,
        vx: -3 - Math.random() * 3,
        size: 4 + Math.random() * 4,
      });
    }

    for (let i = menuBgBullets.length - 1; i >= 0; i--) {
      menuBgBullets[i].x += menuBgBullets[i].vx;
      if (menuBgBullets[i].x < -20) menuBgBullets.splice(i, 1);
    }

    for (const r of menuBgRunners) {
      r.frameTimer++;
      if (r.frameTimer > 6) { r.frameTimer = 0; r.frame = (r.frame + 1) % 4; }
      r.x += 2;
      if (r.x > W + 60) r.x = -60;

      r.jumpTimer--;
      let shouldJump = false;
      for (const b of menuBgBullets) {
        if (b.x > r.x && b.x < r.x + 80 && Math.abs(b.y - r.y) < 50) { shouldJump = true; break; }
      }
      if ((r.jumpTimer <= 0 || shouldJump) && r.onGround) {
        r.vy = -10 - Math.random() * 3;
        r.onGround = false;
        r.jumpTimer = 60 + Math.floor(Math.random() * 60);
      }
      r.vy += 0.5;
      r.y += r.vy;
      if (r.y >= menuBgFloorY - r.h) {
        r.y = menuBgFloorY - r.h;
        r.vy = 0;
        r.onGround = true;
      }
    }
    if (state === 'menu') return;
  }

  if (state === 'intro') {
    introTimer++;

    if (introPhase === 0 && introTimer > 60) {
      introPhase = 1; introTimer = 0;
    }

    if (introPhase === 1 && introTimer > 90) {
      introPhase = 2; introTimer = 0;
    }

    if (introPhase === 2 && introTimer > 80) {
      introPhase = 3; introTimer = 0;
    }

    if (introPhase === 3) {

      const sweepProgress = Math.min(1, introTimer / 160);
      const eased = sweepProgress < 0.5 ? 2 * sweepProgress * sweepProgress : 1 - Math.pow(-2 * sweepProgress + 2, 2) / 2;
      cameraX = eased * (levelWidth - W);
      cameraY = 0;

      if (introTimer % 3 === 0) {
        introParticles.push({
          x: cameraX + Math.random() * W, y: Math.random() * H,
          vx: -1 + Math.random() * 2, vy: -0.5 + Math.random(),
          life: 60, size: 1 + Math.random() * 3, color: `hsl(${40 + Math.random()*20}, 80%, ${50+Math.random()*30}%)`
        });
      }
      if (introTimer > 180) { introPhase = 4; introTimer = 0; }
    }

    if (introPhase === 4) {
      const zoomProgress = Math.min(1, introTimer / 50);
      const eased = 1 - Math.pow(1 - zoomProgress, 3);
      cameraX = (levelWidth - W) * (1 - eased);
      if (introTimer > 60) { introPhase = 5; introTimer = 0; }
    }

    if (introPhase === 5) {
      if (introTimer === 1) { screenFlash = 20; screenFlashColor = '#ffffff'; shakeTimer = 10; }
      if (introTimer > 50) { introPhase = 6; }
    }

    if (introPhase >= 6) {
      cameraX = 0; cameraY = 0;
      state = 'playing';
    }

    for (let i = introParticles.length - 1; i >= 0; i--) {
      const ip = introParticles[i];
      ip.x += ip.vx; ip.y += ip.vy; ip.life--;
      if (ip.life <= 0) introParticles.splice(i, 1);
    }

    if (screenFlash > 0) screenFlash--;
    if (shakeTimer > 0) shakeTimer--;
    particles = particles.filter(pt => { pt.x += pt.vx; pt.y += pt.vy; pt.vy += 0.15; pt.life--; pt.size *= 0.97; return pt.life > 0; });
    return;
  }

  if (state === 'cutscene') {
    if (mpEnabled && !isHost) {

      if (cutscene.phase === 3) {
        cutscene.fadeAlpha -= 0.03;
        if (cutscene.fadeAlpha <= 0) {
          cutscene.fadeAlpha = 0;
          cutscene.active = false;
        }
      }
    } else {
    cutscene.timer++;
    if (cutscene.phase === 0) {

      cutscene.fadeAlpha += 0.025;
      if (cutscene.fadeAlpha >= 1) { cutscene.fadeAlpha = 1; cutscene.phase = 1; cutscene.timer = 0; }
    } else if (cutscene.phase === 1 && cutscene.timer > 120) {

      cutscene.phase = 2; cutscene.dialogueIndex = 0; cutscene.timer = 0;
    } else if (cutscene.phase === 2 && cutscene.timer > 180) {

      advanceCutscene();
      cutscene.timer = 0;
    } else if (cutscene.phase === 3) {

      cutscene.fadeAlpha -= 0.03;
      if (cutscene.fadeAlpha <= 0) {
        cutscene.fadeAlpha = 0;
        cutscene.active = false;

        const arenaTop2 = bigWall.y + 40;
        const arenaH2 = 800;
        const arenaBottom2 = arenaTop2 + arenaH2;
        const dmBoss = getDiffMult();
        const bossBaseHp = Math.ceil(40 * dmBoss.enemyHp);
        boss = {
          x: bigWall.x + bigWall.w / 2 - 60,
          y: arenaBottom2 - 160,
          w: 120,
          h: 160,
          hp: bossBaseHp,
          maxHp: bossBaseHp,
          dir: -1,
          frame: 0,
          frameTimer: 0,
          shootCooldown: 50,
          dead: false,
          alert: true,
          phase: 1,
          phaseTriggered2: false,
          phaseTriggered3: false,
          attackTimer: 0,
          currentAttack: 'shoot',
          chargeVx: 0,
          charging: false,
          slamming: false,
          slamTimer: 0,
          summonCooldown: 300,
          speed: 1.5 * dmBoss.enemySpeed,
          vy: 0,
        };
        bossMinions = [];
        bossIntroTimer = 120;

        const arenaW2 = 2400;
        const arenaLeft2 = bigWall.x + bigWall.w/2 - arenaW2/2;
        player.x = arenaLeft2 + 100;
        player.y = arenaBottom2 - player.h;
        player.vy = 0;
        player.vx = 0;
        player.onGround = true;
        player.climbingBigWall = false;
        player.onWall = false;

        screenFlash = 45;
        screenFlashColor = '#ff4444';
        shakeTimer = 30;

        for (let r = 0; r < 3; r++) {
          bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h/2, radius: 30 + r*40, maxRadius: 250 + r*60, color: r===0?'#ff0000':r===1?'#ff8800':'#ffffff', life: 60, maxLife: 60 });
        }
        bossVfx.push({ type: 'text', x: boss.x + boss.w/2, y: boss.y - 40, text: '🤥 TRUMP AWAITS 🤥', color: '#ff4444', size: 38, life: 180, maxLife: 180, vy: -0.3 });
        state = 'bossfight';
      }
    }
    }

    if (screenFlash > 0) screenFlash--;
    if (bossIntroTimer > 0) bossIntroTimer--;
    particles = particles.filter(pt => { pt.x += pt.vx; pt.y += pt.vy; pt.vy += 0.15; pt.life--; pt.size *= 0.97; return pt.life > 0; });
    return;
  }

  if (state === 'bossdialogue') {
    bossDialogue.timer++;

    if (bossDialogue.timer > 180) {
      advanceCutscene();
    }
    if (screenFlash > 0) screenFlash--;

    for (let i = bossVfx.length - 1; i >= 0; i--) {
      bossVfx[i].life--;
      if (bossVfx[i].vy) bossVfx[i].y += bossVfx[i].vy;
      if (bossVfx[i].type === 'ring') {
        const prog = 1 - bossVfx[i].life / bossVfx[i].maxLife;
        bossVfx[i].radius = bossVfx[i].maxRadius * prog;
      }
      if (bossVfx[i].life <= 0) bossVfx.splice(i, 1);
    }
    particles = particles.filter(pt => { pt.x += pt.vx; pt.y += pt.vy; pt.vy += 0.15; pt.life--; pt.size *= 0.97; return pt.life > 0; });
    return;
  }

  if (state === 'phonecall') {
    phonecallTimer--;

    if (bossDialogue.active) {
      bossDialogue.timer++;
      if (bossDialogue.timer > 80) {
        bossDialogue.timer = 0;
        bossDialogue.index++;
        if (bossDialogue.index >= bossDialogue.texts.length) {
          bossDialogue.active = false;
        }
      }
    }
    if (phonecallTimer <= 0) {

      const bArenaW2 = 2400;
      const arenaLeft2 = bigWall.x + bigWall.w/2 - bArenaW2/2;
      const arenaTop2 = bigWall.y + 40;
      const arenaFloor2 = arenaTop2 + 800;
      const dmEps = getDiffMult();
      const epsBaseHp = Math.ceil(30 * dmEps.enemyHp);
      epstein = {
        x: arenaLeft2 + bArenaW2/2 - 50,
        y: arenaTop2 + 30,
        w: 100, h: 140,
        hp: epsBaseHp, maxHp: epsBaseHp,
        dir: -1, speed: 2.8 * dmEps.enemySpeed,
        frame: 0, frameTimer: 0,
        dead: false, phase: 1,
        phaseTriggered2: false,
        attackTimer: 0,
        shootCooldown: 40,
        teleportCooldown: 200,
        vy: 0,
        charging: false, chargeVx: 0,
      };
      state = 'epsteinfight';
      screenFlash = 40;
      screenFlashColor = '#8844ff';
      shakeTimer = 30;
      bossIntroTimer = 120;

      player.maxHp += 5;
      player.hp = player.maxHp;
      bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 500, life: 50, maxLife: 50, color: '#8844ff' });
      bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 300, life: 40, maxLife: 40, color: '#ff44ff' });
      bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 150, life: 30, maxLife: 30, color: '#ffffff' });
      bossVfx.push({ type: 'text', x: epstein.x+epstein.w/2, y: epstein.y - 30, text: '\u2620 EPSTEIN HAS ARRIVED \u2620', life: 180, maxLife: 180, color: '#ff44ff' });
    }

    if (screenFlash > 0) screenFlash--;
    if (bossIntroTimer > 0) bossIntroTimer--;
    for (let i = bossVfx.length - 1; i >= 0; i--) {
      bossVfx[i].life--;
      if (bossVfx[i].vy) bossVfx[i].y += bossVfx[i].vy;
      if (bossVfx[i].type === 'ring') {
        const prog = 1 - bossVfx[i].life / bossVfx[i].maxLife;
        bossVfx[i].radius = bossVfx[i].maxRadius * prog;
      }
      if (bossVfx[i].life <= 0) bossVfx.splice(i, 1);
    }
    particles = particles.filter(pt => { pt.x += pt.vx; pt.y += pt.vy; pt.vy += 0.15; pt.life--; pt.size *= 0.97; return pt.life > 0; });
    return;
  }

  if (state === 'fusioncutscene') {
    fusionCutsceneTimer--;
    const bArenaW = 2400;
    const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
    const arenaFloor = bigWall.y + 40 + 800;
    const centerX = arenaLeft + bArenaW/2;
    const centerY = arenaFloor - 200;
    const prog = 1 - fusionCutsceneTimer / 360;

    if (boss) {
      const targetX = centerX - 80;
      boss.x += (targetX - boss.x) * 0.04;
      boss.y += (centerY - boss.h/2 - boss.y) * 0.04;
      boss.dead = false;
    }
    if (epstein) {
      const targetX = centerX + 80 - epstein.w;
      epstein.x += (targetX - epstein.x) * 0.04;
      epstein.y += (centerY - epstein.h/2 - epstein.y) * 0.04;
      epstein.dead = false;
    }

    if (Math.random() < 0.5) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 200 + Math.random() * 200;
      particles.push({
        x: centerX + Math.cos(angle) * dist,
        y: centerY + Math.sin(angle) * dist,
        vx: -Math.cos(angle) * 3, vy: -Math.sin(angle) * 3,
        life: 40, color: ['#ff4400','#8844ff','#ffffff','#ffdd44'][Math.floor(Math.random()*4)],
        size: 3 + Math.random() * 5,
      });
    }

    if (fusionCutsceneTimer % 60 === 0 && fusionCutsceneTimer > 60) {
      bossVfx.push({ type: 'ring', x: centerX, y: centerY, radius: 10, maxRadius: 300, life: 30, maxLife: 30, color: '#ff8844' });
      shakeTimer = 10;
    }

    if (fusionCutsceneTimer <= 0) {
      screenFlash = 60;
      screenFlashColor = '#ffffff';
      shakeTimer = 50;
      const dmFus = getDiffMult();
      const fusBaseHp = Math.ceil(55 * dmFus.enemyHp);
      fusionBoss = {
        x: centerX - 75, y: centerY - 100,
        w: 150, h: 200,
        hp: fusBaseHp, maxHp: fusBaseHp,
        dir: -1, speed: 3.3 * dmFus.enemySpeed,
        frame: 0, frameTimer: 0,
        dead: false, phase: 1,
        phaseTriggered2: false,
        attackTimer: 0,
        shootCooldown: 30,
        slamCooldown: 200,
        dashCooldown: 150,
        vy: 0,
        charging: false, chargeVx: 0,
        mergeGlow: 1.0,
      };
      if (boss) { boss.x = -9999; boss.dead = true; }
      if (epstein) { epstein.x = -9999; epstein.dead = true; }
      state = 'fusionfight';
      bossIntroTimer = 120;

      player.maxHp = 40;
      player.hp = player.maxHp;
      bossVfx.push({ type: 'ring', x: centerX, y: centerY, radius: 10, maxRadius: 800, life: 60, maxLife: 60, color: '#ff4400' });
      bossVfx.push({ type: 'ring', x: centerX, y: centerY, radius: 10, maxRadius: 600, life: 50, maxLife: 50, color: '#8844ff' });
      bossVfx.push({ type: 'ring', x: centerX, y: centerY, radius: 10, maxRadius: 400, life: 40, maxLife: 40, color: '#ffffff' });
      bossVfx.push({ type: 'text', x: centerX, y: centerY - 130, text: '\u2605 TRUMPSTEIN AWAKENS \u2605', life: 180, maxLife: 180, color: '#ff4444' });
    }

    if (screenFlash > 0) screenFlash--;
    if (shakeTimer > 0) shakeTimer--;
    for (let i = bossVfx.length - 1; i >= 0; i--) {
      bossVfx[i].life--;
      if (bossVfx[i].vy) bossVfx[i].y += bossVfx[i].vy;
      if (bossVfx[i].type === 'ring') {
        const prog2 = 1 - bossVfx[i].life / bossVfx[i].maxLife;
        bossVfx[i].radius = bossVfx[i].maxRadius * prog2;
      }
      if (bossVfx[i].life <= 0) bossVfx.splice(i, 1);
    }
    particles = particles.filter(pt => { pt.x += pt.vx; pt.y += pt.vy; pt.vy += 0.15; pt.life--; pt.size *= 0.97; return pt.life > 0; });
    return;
  }

  if (state !== 'playing' && state !== 'bossfight' && state !== 'epsteinfight' && state !== 'fusionfight' && state !== 'splitfight' && state !== 'hawkingRefusal' && state !== 'hawkingDeath' && state !== 'winCutscene' && state !== 'endless' && state !== 'endlessShop') return;

  gameTimer++;
  const p = player;

  if (p.alive && p.hp < p.maxHp && gameTimer % 600 === 0) {
    p.hp++;
    spawnParticles(p.x + p.w/2, p.y + p.h/2, hawkingPhase2 ? '#ffd700' : '#44ff88', 3);
  }

  if (p.alive) {

  const shopFrozen = state === 'endlessShop';
  const left = shopFrozen ? false : (keys['ArrowLeft'] || keys['KeyA'] || touchControls.left);
  const right = shopFrozen ? false : (keys['ArrowRight'] || keys['KeyD'] || touchControls.right);
  const up = shopFrozen ? false : (keys['ArrowUp'] || keys['KeyW'] || keys['Space'] || touchControls.up);

  if (touchJumpQueued) p.prevUp = false;

  touchControls.up = (moveJoystick.active && moveJoystick.dy < MOVE_JUMP_THRESHOLD);
  touchJumpQueued = false;
  if (jumpFlashTimer > 0) jumpFlashTimer--;

  let pSpeed = cheats.speedBoost ? PLAYER_SPEED * 2 : PLAYER_SPEED;

  if ((state === 'endless' || state === 'endlessShop') && endless.powerups.speedBoost > 0) {
    pSpeed *= (1 + endless.powerups.speedBoost * 0.12);
  }
  if (left) { p.vx = -pSpeed; p.facing = -1; }
  else if (right) { p.vx = pSpeed; p.facing = 1; }
  else { p.vx *= 0.7; }

  if (state === 'endless' && endless.powerups.dash > 0 && endless.dashCooldown <= 0) {
    let doDash = false;
    let dashDir = 0;

    if (_isTouchDev && touchDashQueued) {

      doDash = true;
      dashDir = left ? -1 : right ? 1 : p.facing;
      touchDashQueued = false;
    } else if (!_isTouchDev) {

      if (!endless._dashState) endless._dashState = { lastDir: 0, lastTime: 0 };
      const now = Date.now();
      const leftJust = keysJustPressed['ArrowLeft'] || keysJustPressed['KeyA'];
      const rightJust = keysJustPressed['ArrowRight'] || keysJustPressed['KeyD'];
      dashDir = leftJust ? -1 : rightJust ? 1 : 0;
      if (dashDir !== 0) {
        if (dashDir === endless._dashState.lastDir && now - endless._dashState.lastTime < 250) {
          doDash = true;
          endless._dashState.lastDir = 0;
        } else {
          endless._dashState.lastDir = dashDir;
          endless._dashState.lastTime = now;
        }
      }
    }

    if (doDash && dashDir !== 0) {
      const dashDist = endless.powerups.dash >= 2 ? 180 : 120;
      p.x += dashDir * dashDist;

      p.x = Math.max(endless.arenaX + 5, Math.min(endless.arenaX + endless.arenaW - p.w - 5, p.x));
      p.iFrames = 20;
      endless.dashCooldown = endless.powerups.dash >= 2 ? 50 : 80;
      spawnParticles(p.x + p.w/2, p.y + p.h/2, '#88ffcc', 12);
    }
  }
  touchDashQueued = false;

  if (up && !p.prevUp) p.jumpBuffer = 8;
  else if (!up) p.jumpBuffer--;
  p.prevUp = up;

  if (p.onGround) { p.coyoteTime = 6; p.jumpsLeft = p.maxJumps; }
  else p.coyoteTime--;

  if (p.jumpBuffer > 0) {
    if (p.coyoteTime > 0 || p.onGround) {

      p.vy = JUMP_FORCE;
      p.jumpBuffer = 0;
      p.coyoteTime = 0;
      p.onGround = false;
      p.jumpsLeft = p.maxJumps - 1;
      jumpFlashTimer = 8;
      spawnParticles(p.x + p.w / 2, p.y + p.h, '#c9a96e', 5);
    } else if ((p.jumpsLeft > 0 || cheats.infiniteJumps) && settings.doubleJump && !p.onGround) {

      p.vy = JUMP_FORCE * 0.85;
      p.jumpBuffer = 0;
      jumpFlashTimer = 8;
      if (!cheats.infiniteJumps) p.jumpsLeft = 0;
      spawnParticles(p.x + p.w / 2, p.y + p.h, '#88ccff', 8);

      bossVfx.push({ type: 'ring', x: p.x+p.w/2, y: p.y+p.h, radius: 5, maxRadius: 40, life: 15, maxLife: 15, color: '#88ccff' });
    }
  }

  const _onBigWall = bigWall && state !== 'bossfight' && state !== 'bossdialogue' && rectsOverlap(
    { x: p.x - 4, y: p.y, w: p.w + 8, h: p.h }, bigWall
  );
  if (p.jumpBuffer > 0 && p.onWall && !p.onGround && !_onBigWall) {
    p.vy = JUMP_FORCE * 0.9;
    p.vx = -p.wallDir * 6;
    p.jumpBuffer = 0;
    p.onWall = false;
    spawnParticles(p.x + p.w / 2, p.y + p.h / 2, '#aaa', 4);
  }

  if (bigWall && p.onWall && state !== 'bossfight' && state !== 'bossdialogue' && state !== 'endless' && state !== 'endlessShop' && rectsOverlap(
    { x: p.x - 4, y: p.y, w: p.w + 8, h: p.h },
    bigWall
  )) {
    p.climbingBigWall = true;
    if (up) {
      p.vy = -WALL_CLIMB_SPEED;
      p.y += p.vy;
      spawnParticles(p.x + p.w / 2, p.y + p.h, '#c9a96e', 1);
    } else {
      p.vy = 0.5;
    }
  } else {
    p.climbingBigWall = false;
  }

  if (!p.climbingBigWall) {
    const gravMod = ((state === 'endless' || state === 'endlessShop') && endless.modifier && endless.modifier.name === 'GRAVITY') ? 0.5 : 1;
    p.vy += GRAVITY * gravMod;
    if (p.onWall && p.vy > 1.5) p.vy = 1.5;
  }

  p.x += p.vx;
  p.y += p.vy;

  p.onGround = false;
  p.onWall = false;
  p.wallDir = 0;

  if (p.y + p.h >= GROUND_Y) {
    p.y = GROUND_Y - p.h;
    p.vy = 0;
    p.onGround = true;
  }

  const inArena = state === 'bossfight' || state === 'bossdialogue' || state === 'cutscene' || state === 'epsteinfight' || state === 'phonecall' || state === 'fusioncutscene' || state === 'fusionfight' || state === 'splitfight' || state === 'hawkingRefusal' || state === 'hawkingDeath' || state === 'endless' || state === 'endlessShop';
  const allSolids = [...walls, ...(inArena ? (state === 'endless' || state === 'endlessShop' ? endless.platforms : arenaPlats) : [bigWall])].filter(Boolean);
  for (const wall of allSolids) {
    if (!rectsOverlap(p, wall)) continue;

    const overlapLeft = (p.x + p.w) - wall.x;
    const overlapRight = (wall.x + wall.w) - p.x;
    const overlapTop = (p.y + p.h) - wall.y;
    const overlapBottom = (wall.y + wall.h) - p.y;

    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

    if (minOverlap === overlapTop && p.vy >= 0) {
      p.y = wall.y - p.h;
      p.vy = 0;
      p.onGround = true;
    } else if (minOverlap === overlapBottom && p.vy < 0 && !wall.isPlatform) {
      p.y = wall.y + wall.h;
      p.vy = 0;
    } else if (minOverlap === overlapLeft && !wall.isPlatform) {
      p.x = wall.x - p.w;
      p.onWall = true;
      p.wallDir = 1;
    } else if (minOverlap === overlapRight && !wall.isPlatform) {
      p.x = wall.x + wall.w;
      p.onWall = true;
      p.wallDir = -1;
    }
  }

  if (state === 'playing' && (!mpEnabled || isHost) && bigWall && !boss && !cutscene.active) {
  let anyPlayerAtWall = p.y < bigWall.y + 80 && p.x > bigWall.x - 100 && p.x < bigWall.x + bigWall.w + 100;
  if (!anyPlayerAtWall && mpEnabled) {
    for (const uid of Object.keys(roomPlayers)) {
      if (uid === myUid()) continue;
      const rp = roomPlayers[uid];
      if (rp && rp.y < bigWall.y + 80 && rp.x > bigWall.x - 100 && rp.x < bigWall.x + bigWall.w + 100) {
        anyPlayerAtWall = true; break;
      }
    }
  }
  if (anyPlayerAtWall) {
    state = 'cutscene';
    cutscene.active = true;
    cutscene.timer = 0;
    cutscene.phase = 0;
    cutscene.fadeAlpha = 0;
    cutscene.dialogueIndex = 0;
  }
  }

  if (state !== 'winCutscene' && state !== 'won' && bigWall && p.x > bigWall.x + bigWall.w && p.y < bigWall.y + 40 && boss && boss.dead) {
    state = 'winCutscene';
    winCutsceneTimer = 0;
    p.won = true;
    p.alive = true;
    p.hp = p.maxHp;
    p.iFrames = 99999;
    mpSpectating = false;
    spawnParticles(p.x, p.y, '#ffdd44', 40);
    spawnParticles(p.x, p.y, '#ff6644', 30);
    restartCooldown = 60;
  }

  if (p.x < 0) p.x = 0;

  if (Math.abs(p.vx) > 0.5 && p.onGround) {
    p.runTimer++;
    if (p.runTimer > 6) { p.runTimer = 0; p.runFrame = (p.runFrame + 1) % 4; }
  } else {
    p.runFrame = 0;
  }

  if (Math.abs(p.vx) > 2 || Math.abs(p.vy) > 2) {
    p.trail.push({ x: p.x + p.w / 2, y: p.y + p.h / 2, life: 10 });
  }
  p.trail = p.trail.filter(t => { t.life--; return t.life > 0; });
  } else {

    touchControls.up = false;
    touchJumpQueued = false;
    moveJoystick.inJumpUp = false;
  }

  const _mpHost = !mpEnabled || isHost;
  for (const g of guards) {
    if (g.dead) continue;

    if (_mpHost) {

    const _gTarget = mpEnabled ? getNearestPlayerTarget(g.x + g.w/2, g.y + g.h/2) : p;

    let playerOnWall = _gTarget.climbingBigWall || (bigWall && _gTarget.x >= bigWall.x - 100 && _gTarget.y < bigWall.y + bigWall.h - 100);
    if (!playerOnWall && mpEnabled) {
      for (const _pid in roomPlayers) {
        const _rp = roomPlayers[_pid];
        if (_rp && _rp.alive && (_rp.climbingBigWall || (bigWall && _rp.x >= bigWall.x - 100 && _rp.y < bigWall.y + bigWall.h - 100))) {
          playerOnWall = true; break;
        }
      }
    }

    if (playerOnWall && bigWall && !g.climbing) {

      if (Math.abs(g.x - bigWall.x) < 60) {
        g.climbing = true;
        g.x = bigWall.x - g.w - 5;
      } else {
        if (g.x < bigWall.x) g.dir = 1;
        else g.dir = -1;
        g.speed = 2.5;
        g.alert = true;
      }
    }

    if (g.climbing && bigWall) {

      g.x = bigWall.x - g.w - 5;
      const targetY = Math.min(_gTarget.y + 80, GROUND_Y - g.h);
      if (g.y > targetY) {
        g.y -= 1.6;
      } else if (g.y < targetY - 20) {
        g.y += 0.5;
      }
      g.alert = true;
    } else {

      g.x += g.speed * g.dir;
      if (g.x < g.startX - g.range || g.x > g.startX + g.range) {
        g.dir *= -1;
      }
      g.y = GROUND_Y - g.h;

      const dist = Math.abs(_gTarget.x - g.x);
      if (dist < 150) {
        g.alert = true;
        g.alertTimer = 50;
        if (_gTarget.x < g.x) g.dir = -1;
        else g.dir = 1;
        g.speed = 1.8;
      } else {
        if (g.alertTimer > 0) g.alertTimer--;
        else {
          g.alert = false;
          g.speed = 1.0 + Math.random() * 0.3;
        }
      }
    }

    g.frameTimer++;
    if (g.frameTimer > 8) { g.frameTimer = 0; g.frame = (g.frame + 1) % 4; }
    }

    if (p.alive && !p.won && p.iFrames <= 0 && rectsOverlap(p, g)) {
      p.hp--;
      p.iFrames = 40;
      shakeTimer = 10;
      spawnParticles(p.x + p.w / 2, p.y + p.h / 2, '#ff4444', 10);
      if (p.hp <= 0) {
        handlePlayerDeath();
      }
    }
  }

  if (!mpEnabled) {
    for (let i = guards.length - 1; i >= 0; i--) {
      if (guards[i].dead) guards.splice(i, 1);
    }
  }

  if (boss && !boss.dead) {
   if (_mpHost) {
    const bArenaW = 2400;
    const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
    const arenaRight = arenaLeft + bArenaW;
    const arenaTop = bigWall.y + 40;
    const arenaFloor = arenaTop + 800;

    const hpPct = boss.hp / boss.maxHp;
    if (hpPct <= 0.6 && !boss.phaseTriggered2) {
      boss.phaseTriggered2 = true;
      boss.phase = 2;
      boss.speed = 1.8;
      bossDialogue = { active: true, texts: bossPhaseDialogues[2], index: 0, timer: 0 };
      state = 'bossdialogue';
      shakeTimer = 30;
      screenFlash = 25;
      screenFlashColor = '#ff6600';

      bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h/2, radius: 10, maxRadius: 350, life: 40, maxLife: 40, color: '#ff8800' });
      bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h/2, radius: 10, maxRadius: 250, life: 30, maxLife: 30, color: '#ffcc00' });
      for (let a = 0; a < Math.PI * 2; a += 0.3) {
        spawnParticles(boss.x + boss.w/2 + Math.cos(a)*60, boss.y + boss.h/2 + Math.sin(a)*60, '#ff8800', 3);
      }
      spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ff8800', 40);
      spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ffdd44', 30);
    }
    if (hpPct <= 0.25 && !boss.phaseTriggered3) {
      boss.phaseTriggered3 = true;
      boss.phase = 3;
      boss.speed = 2.5;
      bossDialogue = { active: true, texts: bossPhaseDialogues[3], index: 0, timer: 0 };
      state = 'bossdialogue';
      shakeTimer = 35;
      screenFlash = 30;
      screenFlashColor = '#ff0000';

      bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h/2, radius: 10, maxRadius: 500, life: 50, maxLife: 50, color: '#ff0000' });
      bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h/2, radius: 10, maxRadius: 350, life: 40, maxLife: 40, color: '#ff4400' });
      bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h/2, radius: 10, maxRadius: 200, life: 30, maxLife: 30, color: '#ffcc00' });
      for (let a = 0; a < Math.PI * 2; a += 0.2) {
        spawnParticles(boss.x + boss.w/2 + Math.cos(a)*80, boss.y + boss.h/2 + Math.sin(a)*80, '#ff0000', 4);
      }
      spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ff0000', 50);
      spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ffdd44', 35);
      spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ffffff', 25);
    }

    boss.frameTimer++;
    if (boss.frameTimer > 8) { boss.frameTimer = 0; boss.frame = (boss.frame + 1) % 4; }
    boss.attackTimer++;
    boss.alert = true;

    boss.vy += GRAVITY * 0.8;
    boss.y += boss.vy;

    for (const plat of arenaPlats) {
      if (rectsOverlap(boss, plat) && boss.vy >= 0) {
        const oTop = (boss.y + boss.h) - plat.y;
        if (oTop > 0 && oTop < 40) {
          boss.y = plat.y - boss.h;
          boss.vy = 0;
        }
      }
    }

    const bossTarget = mpEnabled ? getNearestPlayerTarget(boss.x + boss.w/2, boss.y + boss.h/2) : p;
    if (!boss.charging && !boss.slamming) {

      if (boss.phase === 1) {
        boss.x += boss.dir * boss.speed;
        if (boss.x < arenaLeft + 30) { boss.x = arenaLeft + 30; boss.dir = 1; }
        if (boss.x + boss.w > arenaRight - 30) { boss.x = arenaRight - boss.w - 30; boss.dir = -1; }

        boss.shootCooldown--;
        if (boss.shootCooldown <= 0) {
          boss.shootCooldown = 60 + Math.floor(Math.random() * 40);
          const dx = bossTarget.x + (bossTarget.w||52)/2 - (boss.x + boss.w/2);
          const dy = bossTarget.y + (bossTarget.h||80)/2 - (boss.y + boss.h/2);
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist > 0) {
            bullets.push({ x: boss.x + boss.w/2, y: boss.y + boss.h/3, vx: (dx/dist)*4, vy: (dy/dist)*4, life: 160 });
            spawnParticles(boss.x + boss.w/2, boss.y + boss.h/3, '#ff4444', 4);
          }
        }
      }

      if (boss.phase === 2) {
        if (bossTarget.x < boss.x) boss.dir = -1; else boss.dir = 1;
        boss.x += boss.dir * boss.speed;
        if (boss.x < arenaLeft + 30) { boss.x = arenaLeft + 30; boss.dir = 1; }
        if (boss.x + boss.w > arenaRight - 30) { boss.x = arenaRight - boss.w - 30; boss.dir = -1; }

        if (boss.attackTimer % 180 === 0 && Math.random() < 0.4) {
          boss.charging = true;
          boss.chargeVx = (bossTarget.x < boss.x ? -1 : 1) * 8;
          spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ff8800', 10);
        }

        boss.shootCooldown--;
        if (boss.shootCooldown <= 0) {
          boss.shootCooldown = 70 + Math.floor(Math.random() * 30);
          for (let angle = -0.3; angle <= 0.3; angle += 0.3) {
            const baseDir = bossTarget.x < boss.x ? -1 : 1;
            bullets.push({ x: boss.x + boss.w/2, y: boss.y + boss.h/3, vx: baseDir * 4 * Math.cos(angle), vy: 4 * Math.sin(angle), life: 120 });
          }
          spawnParticles(boss.x + boss.w/2, boss.y + boss.h/3, '#ffaa00', 6);
        }

        boss.summonCooldown--;
        if (boss.summonCooldown <= 0 && bossMinions.length < 2) {
          boss.summonCooldown = 350;
          const spawnX = arenaLeft + 50 + Math.random() * (arenaRight - arenaLeft - 100);
          bossMinions.push({
            x: spawnX, y: arenaFloor - 84, w: 48, h: 72, hp: 2, maxHp: 2, vy: 0,
            dir: Math.random() > 0.5 ? 1 : -1, speed: 1.2 + Math.random() * 0.5,
            frame: 0, frameTimer: 0, dead: false,
            startX: spawnX, range: 160,
          });
          spawnParticles(spawnX, arenaFloor - 40, '#ffdd44', 12);
        }
      }

      if (boss.phase === 3) {
        if (bossTarget.x < boss.x) boss.dir = -1; else boss.dir = 1;
        boss.x += boss.dir * boss.speed;
        if (boss.x < arenaLeft + 30) { boss.x = arenaLeft + 30; boss.dir = 1; }
        if (boss.x + boss.w > arenaRight - 30) { boss.x = arenaRight - boss.w - 30; boss.dir = -1; }

        if (boss.attackTimer % 120 === 0 && Math.random() < 0.5) {
          boss.charging = true;
          boss.chargeVx = (bossTarget.x < boss.x ? -1 : 1) * 10;
          spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ff0000', 12);
        }

        if (boss.attackTimer % 150 === 0 && !boss.slamming) {
          boss.slamming = true;
          boss.slamTimer = 0;
          boss.vy = -14;
          spawnParticles(boss.x + boss.w/2, boss.y + boss.h, '#ff4444', 8);
        }

        boss.shootCooldown--;
        if (boss.shootCooldown <= 0) {
          boss.shootCooldown = 30 + Math.floor(Math.random() * 20);
          const dx = bossTarget.x + (bossTarget.w||52)/2 - (boss.x + boss.w/2);
          const dy = bossTarget.y + (bossTarget.h||80)/2 - (boss.y + boss.h/2);
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist > 0) {
            bullets.push({ x: boss.x + boss.w/2, y: boss.y + boss.h/3, vx: (dx/dist)*5.5, vy: (dy/dist)*5.5, life: 150 });
          }

          if (Math.random() < 0.2) {
            for (let a = -0.4; a <= 0.4; a += 0.4) {
              bullets.push({ x: boss.x + boss.w/2, y: boss.y + boss.h/3, vx: boss.dir * 5 * Math.cos(a), vy: 5 * Math.sin(a) - 1, life: 100 });
            }
          }
          spawnParticles(boss.x + boss.w/2, boss.y + boss.h/3, '#ff2222', 4);
        }

        boss.summonCooldown--;
        if (boss.summonCooldown <= 0 && bossMinions.length < 3) {
          boss.summonCooldown = 250;
          for (let m = 0; m < 1; m++) {
            const spawnX = arenaLeft + 50 + Math.random() * (arenaRight - arenaLeft - 100);
            bossMinions.push({
              x: spawnX, y: arenaFloor - 84, w: 48, h: 72, hp: 2, maxHp: 2, vy: 0,
              dir: Math.random() > 0.5 ? 1 : -1, speed: 1.5 + Math.random() * 0.5,
              frame: 0, frameTimer: 0, dead: false,
              startX: spawnX, range: 180,
            });
            spawnParticles(spawnX, arenaFloor - 40, '#ff4444', 10);
          }
        }
      }
    }

    if (boss.charging) {
      boss.x += boss.chargeVx;
      spawnParticles(boss.x + (boss.chargeVx > 0 ? 0 : boss.w), boss.y + boss.h/2, '#ff880088', 2);
      if (boss.x < arenaLeft + 10 || boss.x + boss.w > arenaRight - 10) {
        boss.charging = false;
        boss.chargeVx = 0;
        shakeTimer = 15;
        screenFlash = 8;
        screenFlashColor = '#ff880088';

        const impactX = boss.x < arenaLeft + 50 ? arenaLeft + 20 : arenaRight - 20;
        bossVfx.push({ type: 'ring', x: impactX, y: boss.y + boss.h/2, radius: 5, maxRadius: 120, life: 20, maxLife: 20, color: '#ffaa44' });
        spawnParticles(impactX, boss.y + boss.h/2, '#ffaa44', 25);
        spawnParticles(impactX, boss.y + boss.h/2, '#ffffff', 10);

        for (let d = 0; d < 8; d++) {
          spawnParticles(impactX, boss.y + boss.h * Math.random(), '#999', 2);
        }
      }
    }

    if (boss.slamming) {
      boss.slamTimer++;

      if (boss.slamTimer > 90) {
        boss.slamming = false;
        boss.vy = 0;
        boss.y = arenaFloor - boss.h;
        boss._slamShock = 25;
        shakeTimer = 25;
      }
      else if (boss.vy >= 0 && boss.slamTimer > 10) {

        for (const plat of arenaPlats) {
          if (rectsOverlap(boss, plat)) {
            boss.slamming = false;
            shakeTimer = 25;
            screenFlash = 12;
            screenFlashColor = '#ff440088';
            boss._slamShock = 25;

            bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h, radius: 5, maxRadius: 300, life: 30, maxLife: 30, color: '#ff4400' });
            bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h, radius: 5, maxRadius: 200, life: 25, maxLife: 25, color: '#ff8800' });

            bossVfx.push({ type: 'crack', x: boss.x + boss.w/2, y: boss.y + boss.h, life: 60, maxLife: 60 });

            const shockRange = 250;
            for (let sx = -shockRange; sx <= shockRange; sx += 12) {
              spawnParticles(boss.x + boss.w/2 + sx, boss.y + boss.h, '#ff8800', 3);
            }

            for (let d = 0; d < 15; d++) {
              particles.push({ x: boss.x + boss.w/2 + (Math.random()-0.5)*shockRange, y: boss.y + boss.h, vx: (Math.random()-0.5)*8, vy: -Math.random()*12-3, life: 40+Math.random()*30, color: '#888', size: 3+Math.random()*4 });
            }
            break;
          }
        }
      }
    }
   }

    if (boss._slamShock > 0) {
      boss._slamShock--;
      if (boss._slamShock > 20) {
        shakeTimer = Math.max(shakeTimer, boss._slamShock);
        const shockRange2 = 250;
        if (p.alive && Math.abs(p.x - boss.x) < shockRange2 && p.y > boss.y - 50 && p.iFrames <= 0) {
          p.hp -= 1;
          p.iFrames = 30;
          p.vy = -12;
          p.vx = (p.x < boss.x ? -1 : 1) * 8;
          spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4444', 15);
        }
      }
    }

    if (boss.charging && p.alive && !p.won && p.iFrames <= 0 && rectsOverlap(p, boss)) {
      p.hp -= 1;
      p.iFrames = 60;
      p.vx = (boss.chargeVx || boss.dir * 8) * 0.8;
      p.vy = -8;
      shakeTimer = 12;
      spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4444', 15);
    } else if (!boss.charging && p.alive && !p.won && p.iFrames <= 0 && rectsOverlap(p, boss)) {
      p.hp -= 1;
      p.iFrames = 40;
      p.vx = (p.x < boss.x ? -1 : 1) * 5;
      p.vy = -6;
      shakeTimer = 8;
      spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4444', 10);
    }

    if (p.hp <= 0) {
      handlePlayerDeath();
    }
  }

  if (bigWall) {

  const mArenaH = 800;
  const mArenaTopY = bigWall.y + 40;
  const mArenaFloorY = mArenaTopY + mArenaH;
  for (const m of bossMinions) {
    if (m.dead) continue;
    if (_mpHost) {

    if (m.vy === undefined || m.vy === null) m.vy = 0;
    m.vy += GRAVITY;
    m.y += m.vy;

    let onPlatform = false;
    let platformY = mArenaFloorY;
    for (const plat of arenaPlats) {
      if (plat.isFloor && rectsOverlap(m, plat) && m.vy >= 0) {
        const oTop = (m.y + m.h) - plat.y;
        if (oTop > 0 && oTop < 50) {
          m.y = plat.y - m.h;
          m.vy = 0;
          onPlatform = true;
        }
      }
    }

    if (m.y + m.h > mArenaFloorY) { m.y = mArenaFloorY - m.h; m.vy = 0; }
    if (m.y < mArenaTopY + 20) { m.y = mArenaTopY + 20; if (m.vy < 0) m.vy = 0; }

    const mTarget = mpEnabled ? getNearestPlayerTarget(m.x + m.w/2, m.y + m.h/2) : p;
    const mDist = Math.abs(mTarget.x - m.x);
    m.dir = mTarget.x < m.x ? -1 : 1;
    if (mDist < 250) {
      m.speed = 2.2;
    } else {
      m.speed = 1.5;
    }
    m.x += m.speed * m.dir;

    const mArenaW = 2400;
    const mArenaLeft = bigWall.x + bigWall.w/2 - mArenaW/2;
    const mArenaRight = mArenaLeft + mArenaW;
    if (m.x < mArenaLeft + 20) m.x = mArenaLeft + 20;
    if (m.x + m.w > mArenaRight - 20) m.x = mArenaRight - m.w - 20;
    m.frameTimer++;
    if (m.frameTimer > 8) { m.frameTimer = 0; m.frame = (m.frame + 1) % 4; }
    }

    if (p.alive && !p.won && p.iFrames <= 0 && rectsOverlap(p, m)) {
      p.hp--;
      p.iFrames = 35;
      shakeTimer = 6;
      spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4444', 8);
      if (p.hp <= 0) {
        handlePlayerDeath();
      }
    }
  }

  if (!mpEnabled) {
    for (let i = bossMinions.length - 1; i >= 0; i--) {
      if (bossMinions[i].dead) bossMinions.splice(i, 1);
    }
  }
  }

  if (p.throwCooldown > 0) p.throwCooldown--;
  if (p.iFrames > 0 && p.alive) p.iFrames--;

  if (touchAim.active && p.throwCooldown <= 0 && p.alive) {
    throwProjectile();
  }

  for (let i = projectiles.length - 1; i >= 0; i--) {
    const proj = projectiles[i];
    if (!proj) continue;
    proj.x += proj.vx;
    proj.y += proj.vy;
    proj.vy += 0.07;
    proj.life--;

    let hit = false;

    if (mpEnabled && !isHost) {
      for (let gi = 0; gi < guards.length; gi++) {
        const gg = guards[gi];
        if (gg.dead) continue;
        if (rectsOverlap(proj, gg)) {
          spawnParticles(gg.x + gg.w/2, gg.y + gg.h/3, '#ffaa00', 8);
          shakeTimer = 5;
          mpSendDamage('guard', gi, 1);
          hit = true; break;
        }
      }
      if (!hit && boss && !boss.dead && rectsOverlap(proj, boss)) {
        spawnParticles(boss.x + boss.w/2, boss.y + boss.h/3, '#ff6600', 12);
        shakeTimer = 8;
        mpSendDamage('boss', 0, 1);
        hit = true;
      }
      if (!hit && epstein && !epstein.dead && rectsOverlap(proj, epstein)) {
        spawnParticles(epstein.x + epstein.w/2, epstein.y + epstein.h/3, '#8844ff', 12);
        shakeTimer = 8;
        mpSendDamage('epstein', 0, 1);
        hit = true;
      }
      if (!hit && fusionBoss && !fusionBoss.dead && rectsOverlap(proj, fusionBoss)) {
        spawnParticles(fusionBoss.x + fusionBoss.w/2, fusionBoss.y + fusionBoss.h/3, '#ff8844', 12);
        shakeTimer = 8;
        mpSendDamage('fusion', 0, 1);
        hit = true;
      }
      if (!hit && miniBosses.length > 0) {
        for (let mi = 0; mi < miniBosses.length; mi++) {
          const mmb = miniBosses[mi];
          if (mmb.dead) continue;
          if (mmb.name === 'HAWKING' && state === 'hawkingDeath') continue;
          if (rectsOverlap(proj, mmb)) {
            spawnParticles(mmb.x + mmb.w/2, mmb.y + mmb.h/3, mmb.color, 10);
            shakeTimer = 6;
            mpSendDamage('mini', mi, 1);
            hit = true; break;
          }
        }
      }
      if (!hit) {
        for (let bi = 0; bi < bossMinions.length; bi++) {
          const bm2 = bossMinions[bi];
          if (bm2.dead) continue;
          if (rectsOverlap(proj, bm2)) {
            spawnParticles(bm2.x + bm2.w/2, bm2.y + bm2.h/3, '#ffaa00', 8);
            shakeTimer = 4;
            mpSendDamage('bossMinion', bi, 1);
            hit = true; break;
          }
        }
      }

      if (!hit && state === 'endless') {
        for (let ei = 0; ei < endless.enemies.length; ei++) {
          const ee = endless.enemies[ei];
          if (ee.dead) continue;
          if (rectsOverlap(proj, ee)) {
            spawnParticles(ee.x + ee.w/2, ee.y + ee.h/3, ee.color || '#ff4444', 8);
            shakeTimer = ee.isBoss ? 6 : 4;
            mpSendDamage('endlessEnemy', ei, Math.ceil(proj.dmgMult || 1));
            hit = true; break;
          }
        }
      }
      if (hit || proj.life <= 0) { projectiles.splice(i, 1); }
      continue;
    }

    for (const g of guards) {
      if (g.dead) continue;
      if (rectsOverlap(proj, g)) {
        g.hp = cheats.oneHitKill ? 0 : g.hp - 1;
        spawnParticles(g.x + g.w / 2, g.y + g.h / 3, '#ffaa00', 8);
        shakeTimer = 5;
        if (g.hp <= 0) {
          g.dead = true;
          spawnParticles(g.x + g.w / 2, g.y + g.h / 2, '#ff4444', 15);
        }
        hit = true;
        break;
      }
    }

    if (!hit && boss && !boss.dead && rectsOverlap(proj, boss)) {
      boss.hp = cheats.oneHitKill ? 0 : boss.hp - 1;
      spawnParticles(boss.x + boss.w / 2, boss.y + boss.h / 3, '#ff6600', 12);
      shakeTimer = 8;
      if (boss.hp <= 0) {
        boss.dead = true;
        bossDeathTimer = 180;
        bossMinions = [];
        bullets = [];
        shakeTimer = 60;
        screenFlash = 40;
        screenFlashColor = '#ffffff';
        for (let wave = 0; wave < 5; wave++) {
          const ox = (Math.random()-0.5) * boss.w;
          const oy = (Math.random()-0.5) * boss.h;
          spawnParticles(boss.x + boss.w/2 + ox, boss.y + boss.h/2 + oy, '#ff4444', 20);
          spawnParticles(boss.x + boss.w/2 + ox, boss.y + boss.h/2 + oy, '#ffdd44', 15);
        }
        bossVfx.push({ type: 'ring', x: boss.x+boss.w/2, y: boss.y+boss.h/2, radius: 10, maxRadius: 600, life: 60, maxLife: 60, color: '#ff4400' });
        bossVfx.push({ type: 'ring', x: boss.x+boss.w/2, y: boss.y+boss.h/2, radius: 10, maxRadius: 400, life: 50, maxLife: 50, color: '#ffcc00' });
      }
      hit = true;
    }

    if (!hit && epstein && !epstein.dead && rectsOverlap(proj, epstein)) {
      epstein.hp = cheats.oneHitKill ? 0 : epstein.hp - 1;
      spawnParticles(epstein.x + epstein.w/2, epstein.y + epstein.h/3, '#8844ff', 12);
      shakeTimer = 8;
      if (epstein.hp <= 0) {
        epstein.dead = true;
        bossDeathTimer = 200;
        bullets = [];
        epsteinProjectiles = [];
        shakeTimer = 60;
        screenFlash = 50;
        screenFlashColor = '#ffffff';
        for (let wave = 0; wave < 8; wave++) {
          const ox = (Math.random()-0.5) * epstein.w * 2;
          const oy = (Math.random()-0.5) * epstein.h * 2;
          spawnParticles(epstein.x + epstein.w/2 + ox, epstein.y + epstein.h/2 + oy, '#8844ff', 20);
          spawnParticles(epstein.x + epstein.w/2 + ox, epstein.y + epstein.h/2 + oy, '#ffdd44', 15);
          spawnParticles(epstein.x + epstein.w/2 + ox, epstein.y + epstein.h/2 + oy, '#ffffff', 10);
        }
        bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 700, life: 60, maxLife: 60, color: '#8844ff' });
        bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 500, life: 50, maxLife: 50, color: '#ffcc00' });
        bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 300, life: 40, maxLife: 40, color: '#ffffff' });
        bossVfx.push({ type: 'text', x: epstein.x+epstein.w/2, y: epstein.y - 20, text: 'EXPOSED!', life: 150, maxLife: 150, color: '#ffdd44' });
      }
      hit = true;
    }

    if (!hit && fusionBoss && !fusionBoss.dead && rectsOverlap(proj, fusionBoss)) {
      fusionBoss.hp = cheats.oneHitKill ? 0 : fusionBoss.hp - 1;
      spawnParticles(fusionBoss.x + fusionBoss.w/2, fusionBoss.y + fusionBoss.h/3, '#ff8844', 12);
      shakeTimer = 8;
      if (fusionBoss.hp <= 0) {
        fusionBoss.dead = true;
        bossDeathTimer = 200;
        bullets = [];
        epsteinProjectiles = [];
        shakeTimer = 60;
        screenFlash = 60;
        screenFlashColor = '#ffffff';
        for (let wave = 0; wave < 10; wave++) {
          const ox = (Math.random()-0.5) * fusionBoss.w * 2;
          const oy = (Math.random()-0.5) * fusionBoss.h * 2;
          spawnParticles(fusionBoss.x + fusionBoss.w/2 + ox, fusionBoss.y + fusionBoss.h/2 + oy, '#ff4400', 20);
          spawnParticles(fusionBoss.x + fusionBoss.w/2 + ox, fusionBoss.y + fusionBoss.h/2 + oy, '#8844ff', 15);
          spawnParticles(fusionBoss.x + fusionBoss.w/2 + ox, fusionBoss.y + fusionBoss.h/2 + oy, '#ffffff', 10);
        }
        bossVfx.push({ type: 'ring', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y+fusionBoss.h/2, radius: 10, maxRadius: 800, life: 60, maxLife: 60, color: '#ff4400' });
        bossVfx.push({ type: 'ring', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y+fusionBoss.h/2, radius: 10, maxRadius: 600, life: 50, maxLife: 50, color: '#8844ff' });
        bossVfx.push({ type: 'ring', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y+fusionBoss.h/2, radius: 10, maxRadius: 400, life: 40, maxLife: 40, color: '#ffffff' });
        bossVfx.push({ type: 'text', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y - 30, text: 'UNFUSED!', life: 180, maxLife: 180, color: '#ffdd44' });
      }
      hit = true;
    }

    if (!hit && miniBosses.length > 0) {
      for (const mb of miniBosses) {
        if (mb.dead) continue;

        if (mb.name === 'HAWKING' && state === 'hawkingDeath') continue;
        if (rectsOverlap(proj, mb)) {

          const othersAlive = miniBosses.filter(m => !m.dead && m.name !== 'HAWKING').length;
          if (mb.name === 'HAWKING' && othersAlive > 0) {

            const shieldCol = hawkingPhase2 ? '#ffd700' : '#44ff88';
            spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, shieldCol, 6);
            bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 20, text: 'SHIELDED', life: 40, maxLife: 40, color: shieldCol });
            hit = true;
            break;
          }
          mb.hp = cheats.oneHitKill ? 0 : mb.hp - 1;
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, mb.color, 10);
          shakeTimer = 6;
          if (mb.hp <= 0) {

            if (mb.name === 'HAWKING' && !hawkingPhase2) {
              mb.hp = 1;
              hawkingRefusalTimer = 0;
              hawkingRefusalPhase = 0;

              mb._savedX = mb.x;
              mb._savedY = mb.y;
              state = 'hawkingRefusal';
              epsteinProjectiles = [];
              bossMinions = [];
              bossVfx = [];
              screenFlash = 40;
              screenFlashColor = '#44ff88';
              shakeTimer = 30;
              spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#44ff88', 40);
              hit = true;
              break;
            }

            if (mb.name === 'HAWKING' && hawkingPhase2) {
              mb.hp = 1;
              hawkingDeathTimer = 0;
              hawkingDeathPhase = 0;
              mb._deathX = mb.x + mb.w/2;
              mb._deathY = mb.y + mb.h/2;
              state = 'hawkingDeath';
              projectiles = [];
              epsteinProjectiles = [];
              bossMinions = [];
              bossVfx = [];
              screenFlash = 60;
              screenFlashColor = '#ffd700';
              shakeTimer = 40;
              spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffd700', 60);
              spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffffff', 40);
              hit = true;
              break;
            }
            mb.dead = true;
            spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, mb.color, 25);
            spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffffff', 15);
            bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 250, life: 30, maxLife: 30, color: mb.color });
            bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 20, text: mb.name + ' DOWN!', life: 120, maxLife: 120, color: mb.color });
            screenFlash = 15;
            screenFlashColor = mb.color;

            const nowOthersAlive = miniBosses.filter(m => !m.dead && m.name !== 'HAWKING').length;
            if (nowOthersAlive === 0) {
              const hawk = miniBosses.find(m => m.name === 'HAWKING' && !m.dead);
              if (hawk) {
                const hawkCol = hawkingPhase2 ? '#ffd700' : '#44ff88';
                bossVfx.push({ type: 'text', x: hawk.x+hawk.w/2, y: hawk.y - 40, text: 'NOW IT\'S JUST US.', life: 180, maxLife: 180, color: hawkCol });
                bossVfx.push({ type: 'ring', x: hawk.x+hawk.w/2, y: hawk.y+hawk.h/2, radius: 10, maxRadius: 500, life: 50, maxLife: 50, color: hawkCol });
                screenFlash = 30;
                screenFlashColor = hawkCol;
                shakeTimer = 20;
              }
            }
          }
          hit = true;
          break;
        }
      }
    }

    if (!hit) {
      for (const m of bossMinions) {
        if (m.dead) continue;
        if (rectsOverlap(proj, m)) {
          m.hp = cheats.oneHitKill ? 0 : m.hp - 1;
          spawnParticles(m.x + m.w/2, m.y + m.h/3, '#ffaa00', 8);
          shakeTimer = 4;
          if (m.hp <= 0) {
            m.dead = true;
            spawnParticles(m.x + m.w/2, m.y + m.h/2, '#ff4444', 12);
          }
          hit = true;
          break;
        }
      }
    }
    if (hit || proj.life <= 0) {
      projectiles.splice(i, 1);
    }
  }

  if (state !== 'endless' && state !== 'endlessShop') {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;
    b.life--;

    if (p.iFrames <= 0 && p.alive && !p.won && rectsOverlap({ x: b.x - 5, y: b.y - 5, w: 10, h: 10 }, p)) {
      p.hp--;
      p.iFrames = 40;
      shakeTimer = 8;
      spawnParticles(p.x + p.w / 2, p.y + p.h / 2, '#ff4444', 8);
      bullets.splice(i, 1);
      if (p.hp <= 0) {
        handlePlayerDeath();
      }
      continue;
    }

    if (b.life <= 0) {
      bullets.splice(i, 1);
    }
  }
  }

  let targetCamX = p.x - W / 3;

  const isEndlessMode = state === 'endless' || state === 'endlessShop';

  const inArenaState = state === 'bossfight' || state === 'bossdialogue' || state === 'epsteinfight' || state === 'phonecall' || state === 'cutscene' || state === 'fusioncutscene' || state === 'fusionfight' || state === 'splitfight' || state === 'hawkingRefusal' || state === 'hawkingDeath';
  if (!isEndlessMode && inArenaState && bigWall) {
    const bArenaW = 2400;
    const arenaLeftCam = bigWall.x + bigWall.w/2 - bArenaW/2;
    const arenaRightCam = arenaLeftCam + bArenaW;

    let bossX = null;
    if (boss && !boss.dead) bossX = boss.x + boss.w/2;
    else if (epstein && !epstein.dead) bossX = epstein.x + epstein.w/2;
    else if (fusionBoss && !fusionBoss.dead) bossX = fusionBoss.x + fusionBoss.w/2;
    else if (miniBosses.length > 0) {
      let sumX = 0, count = 0;
      for (const mb of miniBosses) { if (!mb.dead) { sumX += mb.x + mb.w/2; count++; } }
      if (count > 0) bossX = sumX / count;
    }

    if (bossX !== null) {

      const midX = p.x * 0.5 + bossX * 0.5;
      targetCamX = midX - W / 2;
    } else {

      targetCamX = p.x + p.w/2 - W / 2;
    }

    if (targetCamX < arenaLeftCam - 30) targetCamX = arenaLeftCam - 30;
    if (targetCamX + W > arenaRightCam + 30) targetCamX = arenaRightCam + 30 - W;
  }

  const camSpeed = inArenaState ? 0.15 : 0.1;

  if (!isEndlessMode) {

  if (mpSpectating && mpSpectateTarget && roomPlayers[mpSpectateTarget]) {
    const sp = roomPlayers[mpSpectateTarget];

    if (!sp.alive || sp.hp <= 0) {

      const alive = getAlivePlayerList();
      if (alive.length > 0) {
        mpSpectateIndex = mpSpectateIndex % alive.length;
        mpSpectateTarget = alive[mpSpectateIndex].uid;
      } else {

        mpSpectating = false;
        state = 'dead';
      }
    }
    if (mpSpectating && roomPlayers[mpSpectateTarget]) {
      const sp2 = roomPlayers[mpSpectateTarget];
      targetCamX = sp2.x + 26 - W / 2;

      if (inArenaState && bigWall) {
        const bArenaW2 = 2400;
        const arenaLeftSpec = bigWall.x + bigWall.w/2 - bArenaW2/2;
        const arenaRightSpec = arenaLeftSpec + bArenaW2;
        if (targetCamX < arenaLeftSpec - 30) targetCamX = arenaLeftSpec - 30;
        if (targetCamX + W > arenaRightSpec + 30) targetCamX = arenaRightSpec + 30 - W;
        const targetCamY2 = sp2.y - H * 0.5 + 40;
        cameraY += (targetCamY2 - cameraY) * 0.12;
      } else {

        if (sp2.climbingBigWall || sp2.y < GROUND_Y - 130) {
          const comfortY = GROUND_Y - H * 0.6;
          const targetCamY2 = Math.min(0, sp2.y - comfortY);
          cameraY += (targetCamY2 - cameraY) * 0.1;
        } else {
          cameraY += (0 - cameraY) * 0.08;
        }
      }
    }
  }

  cameraX += (targetCamX - cameraX) * camSpeed;
  if (cameraX < 0) cameraX = 0;
  if (cameraX > levelWidth - W) cameraX = levelWidth - W;

  if (mpSpectating) {

  } else if (inArenaState) {

    const arenaCenter = bigWall ? bigWall.y + 40 + 400 : GROUND_Y;
    const targetCamY = p.y - H * 0.5 + p.h/2;
    cameraY += (targetCamY - cameraY) * 0.12;
  } else if (p.climbingBigWall || p.y < GROUND_Y - p.h - 50) {

    const comfortY = GROUND_Y - H * 0.6;
    const targetCamY = Math.min(0, p.y - comfortY);
    cameraY += (targetCamY - cameraY) * 0.1;
  } else {

    cameraY += (0 - cameraY) * 0.08;
  }

  if (!inArenaState && cameraY > 0) cameraY = 0;
  }

  if (screenFlash > 0) screenFlash--;
  if (bossIntroTimer > 0) {
    bossIntroTimer--;

    if (bossIntroTimer === 0 && state === 'splitfight' && miniBosses.length > 0) {
      const bArenaW = 2400;
      const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
      const arenaFloor = bigWall.y + 40 + 800;

      player.x = arenaLeft + bArenaW * 0.15;
      player.y = arenaFloor - player.h - 10;
      player.vy = 0;

      const spawnPositions = [
        { x: arenaLeft + bArenaW * 0.55, y: arenaFloor - 110 },
        { x: arenaLeft + bArenaW * 0.65, y: arenaFloor - 110 },
        { x: arenaLeft + bArenaW * 0.75, y: arenaFloor - 110 },
        { x: arenaLeft + bArenaW * 0.85, y: arenaFloor - 110 },
        { x: arenaLeft + bArenaW * 0.70, y: arenaFloor - 280 },
      ];
      for (let i = 0; i < miniBosses.length; i++) {
        const mb = miniBosses[i];
        if (mb.dead) continue;
        const sp = spawnPositions[i] || spawnPositions[0];
        mb.x = sp.x - mb.w/2;
        mb.y = sp.y;
        mb.vy = 0;
        mb.vx = 0;
        mb.dir = -1;
        mb.shootCooldown = 60 + i * 15;
        mb.attackTimer = 0;
        mb.specialTimer = 0;
      }

      screenFlash = 30;
      screenFlashColor = '#ffffff';
      shakeTimer = 20;
      bossVfx.push({ type: 'text', x: player.x + player.w/2 + 400, y: player.y - 60, text: '⚔ FIGHT! ⚔', life: 120, maxLife: 120, color: '#ffdd44', size: 48, vy: -0.3 });
    }
  }

  if (bossDeathTimer > 0 && boss && boss.dead && !epstein) {
    bossDeathTimer--;

    if (bossDeathTimer % 12 === 0 && bossDeathTimer > 30) {
      const ox = (Math.random()-0.5) * 200;
      const oy = (Math.random()-0.5) * 200;
      spawnParticles(boss.x + boss.w/2 + ox, boss.y + boss.h/2 + oy, '#ff' + ['4444','8800','cc00','dd44','ffff'][Math.floor(Math.random()*5)], 15);
      shakeTimer = Math.max(shakeTimer, 8);
      if (bossDeathTimer % 36 === 0) {
        bossVfx.push({ type: 'ring', x: boss.x+boss.w/2+ox, y: boss.y+boss.h/2+oy, radius: 5, maxRadius: 200, life: 25, maxLife: 25, color: '#ff8800' });
      }
    }

    if (bossDeathTimer === 30) {
      screenFlash = 30;
      screenFlashColor = '#ffffff';
      shakeTimer = 20;
      bossVfx.push({ type: 'text', x: boss.x+boss.w/2, y: boss.y - 20, text: 'Wait... one call...', life: 150, maxLife: 150, color: '#ff8844' });

      phonecallTimer = 300;
      state = 'phonecall';
      bossDialogue = { active: true, texts: epsteinDialogues, index: 0, timer: 0 };
    }
  }

  if (epstein && !epstein.dead && state === 'epsteinfight') {
   if (_mpHost) {
    const bArenaW3 = 2400;
    const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW3/2;
    const arenaRight = arenaLeft + bArenaW3;
    const arenaTop = bigWall.y + 40;
    const arenaFloor = arenaTop + 800;

    const eHpPct = epstein.hp / epstein.maxHp;
    if (eHpPct <= 0.4 && !epstein.phaseTriggered2) {
      epstein.phaseTriggered2 = true;
      epstein.phase = 2;
      epstein.speed = 3.5;
      bossDialogue = { active: true, texts: epsteinPhaseDialogues[2], index: 0, timer: 0 };
      state = 'bossdialogue';
      shakeTimer = 25;
      screenFlash = 20;
      screenFlashColor = '#8844ff';
      bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 400, life: 40, maxLife: 40, color: '#8844ff' });
    }

    epstein.frameTimer++;
    if (epstein.frameTimer > 7) { epstein.frameTimer = 0; epstein.frame = (epstein.frame + 1) % 4; }
    epstein.attackTimer++;

    epstein.vy += GRAVITY * 0.8;
    epstein.y += epstein.vy;
    for (const plat of arenaPlats) {
      if (rectsOverlap(epstein, plat) && epstein.vy >= 0) {
        const oTop = (epstein.y + epstein.h) - plat.y;
        if (oTop > 0 && oTop < 40) {
          epstein.y = plat.y - epstein.h;
          epstein.vy = 0;
        }
      }
    }

    const epTarget = mpEnabled ? getNearestPlayerTarget(epstein.x + epstein.w/2, epstein.y + epstein.h/2) : p;
    if (epTarget.x < epstein.x) epstein.dir = -1; else epstein.dir = 1;
    if (!epstein.charging) {
      epstein.x += epstein.dir * epstein.speed;
      if (epstein.x < arenaLeft + 30) epstein.x = arenaLeft + 30;
      if (epstein.x + epstein.w > arenaRight - 30) epstein.x = arenaRight - epstein.w - 30;
    }

    epstein.shootCooldown--;
    if (epstein.shootCooldown <= 0) {
      epstein.shootCooldown = epstein.phase === 2 ? 25 + Math.floor(Math.random()*20) : 45 + Math.floor(Math.random()*25);
      const dx = epTarget.x + (epTarget.w||52)/2 - (epstein.x + epstein.w/2);
      const dy = epTarget.y + (epTarget.h||80)/2 - (epstein.y + epstein.h/2);
      const dist = Math.sqrt(dx*dx + dy*dy) || 1;
      epsteinProjectiles.push({
        x: epstein.x + epstein.w/2, y: epstein.y + epstein.h/3,
        vx: (dx/dist) * 5, vy: (dy/dist) * 5,
        life: 180, rotation: 0, size: 50 + Math.random()*20,
        imgIdx: Math.floor(Math.random() * 5),
      });
      spawnParticles(epstein.x + epstein.w/2, epstein.y + epstein.h/3, '#8844ff', 5);

      if (epstein.phase === 2 && Math.random() < 0.3) {
        for (let a = -0.3; a <= 0.3; a += 0.3) {
          epsteinProjectiles.push({
            x: epstein.x + epstein.w/2, y: epstein.y + epstein.h/3,
            vx: epstein.dir * 5 * Math.cos(a), vy: 5 * Math.sin(a),
            life: 150, rotation: Math.random()*Math.PI*2, size: 45 + Math.random()*15,
            imgIdx: Math.floor(Math.random() * 5),
          });
        }
      }
    }

    if (!epstein.summonCooldown) epstein.summonCooldown = 400;
    epstein.summonCooldown--;
    if (epstein.summonCooldown <= 0) {
      epstein.summonCooldown = epstein.phase === 2 ? 300 : 500;

      const mCount = epstein.phase === 2 ? 2 : 1;

      const aliveMinions = bossMinions.filter(m => !m.dead).length;
      if (aliveMinions < 3) {
        for (let mi = 0; mi < mCount && (aliveMinions + mi) < 3; mi++) {
          const spawnX = epstein.x + (mi === 0 ? -80 : 80 + epstein.w);
          const spawnY = epstein.y + epstein.h - 60;
          bossMinions.push({
            x: Math.max(arenaLeft + 30, Math.min(arenaRight - 60, spawnX)),
            y: spawnY,
            w: 40, h: 60,
            hp: 2, maxHp: 2,
            dir: Math.random() > 0.5 ? 1 : -1,
            speed: 2 + Math.random(),
            frame: 0, frameTimer: 0,
            dead: false, vy: -4,
            isEpstein: true,
          });
          spawnParticles(spawnX, spawnY, '#8844ff', 10);
          bossVfx.push({ type: 'ring', x: spawnX, y: spawnY, radius: 5, maxRadius: 60, life: 15, maxLife: 15, color: '#ff44ff' });
        }

        bossVfx.push({ type: 'text', x: epstein.x+epstein.w/2, y: epstein.y - 50, text: 'COME, MY MINIONS!', life: 60, maxLife: 60, color: '#ff44ff' });
      }
    }

    if (epstein.phase === 2) {
      epstein.teleportCooldown--;
      if (epstein.teleportCooldown <= 0) {
        epstein.teleportCooldown = 150 + Math.floor(Math.random()*100);

        spawnParticles(epstein.x + epstein.w/2, epstein.y + epstein.h/2, '#8844ff', 20);
        bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 5, maxRadius: 100, life: 15, maxLife: 15, color: '#8844ff' });
        epstein.x = epTarget.x + (Math.random() > 0.5 ? 150 : -150);
        epstein.x = Math.max(arenaLeft + 40, Math.min(arenaRight - epstein.w - 40, epstein.x));
        spawnParticles(epstein.x + epstein.w/2, epstein.y + epstein.h/2, '#ff44ff', 20);
        bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 5, maxRadius: 120, life: 15, maxLife: 15, color: '#ff44ff' });
        screenFlash = 5;
        screenFlashColor = '#8844ff44';
      }
    }

   }

    if (p.alive && !p.won && p.iFrames <= 0 && rectsOverlap(p, epstein)) {
      p.hp -= 1;
      p.iFrames = 45;
      p.vx = (p.x < epstein.x ? -1 : 1) * 6;
      p.vy = -7;
      shakeTimer = 8;
      spawnParticles(p.x + p.w/2, p.y + p.h/2, '#8844ff', 10);
    }

    if (p.hp <= 0) {
      handlePlayerDeath();
    }
  }

  for (let i = epsteinProjectiles.length - 1; i >= 0; i--) {
    const ep = epsteinProjectiles[i];
    ep.x += ep.vx;
    ep.y += ep.vy;
    ep.rotation += 0.1;
    ep.life--;

    if (p.iFrames <= 0 && !p.won && p.alive && rectsOverlap({ x: ep.x - ep.size/2, y: ep.y - ep.size/2, w: ep.size, h: ep.size }, p)) {
      p.hp--;
      p.iFrames = 40;
      shakeTimer = 8;
      spawnParticles(p.x + p.w/2, p.y + p.h/2, '#8844ff', 8);
      epsteinProjectiles.splice(i, 1);
      if (p.hp <= 0) {
        handlePlayerDeath();
      }
      continue;
    }
    if (ep.life <= 0) epsteinProjectiles.splice(i, 1);
  }

  if (bossDeathTimer > 0 && epstein && epstein.dead && !fusionBoss) {
    bossDeathTimer--;
    if (bossDeathTimer % 10 === 0 && bossDeathTimer > 40) {
      const ox = (Math.random()-0.5) * 250;
      const oy = (Math.random()-0.5) * 250;
      spawnParticles(epstein.x + epstein.w/2 + ox, epstein.y + epstein.h/2 + oy, ['#8844ff','#ff44ff','#ffdd44','#ffffff'][Math.floor(Math.random()*4)], 18);
      shakeTimer = Math.max(shakeTimer, 10);
    }
    if (bossDeathTimer === 40) {
      screenFlash = 50;
      screenFlashColor = '#ffffff';
      shakeTimer = 40;

      fusionCutsceneTimer = 360;
      state = 'fusioncutscene';
      bossVfx.push({ type: 'text', x: epstein.x+epstein.w/2, y: epstein.y - 30, text: 'WAIT... WHAT?!', life: 150, maxLife: 150, color: '#ff4444' });
    }
  }

  if (fusionBoss && !fusionBoss.dead && state === 'fusionfight') {
   if (_mpHost) {
    const bArenaW = 2400;
    const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
    const arenaRight = arenaLeft + bArenaW;
    const arenaTop = bigWall.y + 40;
    const arenaFloor = arenaTop + 800;
    const fb = fusionBoss;

    const fHpPct = fb.hp / fb.maxHp;
    if (fHpPct <= 0.4 && !fb.phaseTriggered2) {
      fb.phaseTriggered2 = true;
      fb.phase = 2;
      fb.speed = 4;
      shakeTimer = 30;
      screenFlash = 25;
      screenFlashColor = '#ff440088';
      bossVfx.push({ type: 'ring', x: fb.x+fb.w/2, y: fb.y+fb.h/2, radius: 10, maxRadius: 500, life: 40, maxLife: 40, color: '#ff4400' });
      bossVfx.push({ type: 'text', x: fb.x+fb.w/2, y: fb.y - 30, text: 'FULL POWER!', life: 120, maxLife: 120, color: '#ff2222' });
      bossDialogue = { active: true, texts: ['You think you\'ve won?!', 'WE ARE ONE NOW!', 'This isn\'t even our final form... wait, yes it is.', 'PREPARE TO BE DEPORTED TO THE SHADOW REALM!'], index: 0, timer: 0 };
      state = 'bossdialogue';
    }

    fb.frameTimer++;
    if (fb.frameTimer > 6) { fb.frameTimer = 0; fb.frame = (fb.frame + 1) % 4; }
    fb.attackTimer++;

    if (fb.mergeGlow > 0) fb.mergeGlow -= 0.005;

    fb.vy += GRAVITY * 0.7;
    fb.y += fb.vy;
    for (const plat of arenaPlats) {
      if (rectsOverlap(fb, plat) && fb.vy >= 0) {
        const oTop = (fb.y + fb.h) - plat.y;
        if (oTop > 0 && oTop < 40) {
          fb.y = plat.y - fb.h;
          fb.vy = 0;
        }
      }
    }

    if (fb.y < arenaTop) { fb.y = arenaTop; fb.vy = 0; }
    if (fb.y + fb.h > arenaFloor) { fb.y = arenaFloor - fb.h; fb.vy = 0; }

    const fbTarget = mpEnabled ? getNearestPlayerTarget(fb.x + fb.w/2, fb.y + fb.h/2) : p;
    if (fbTarget.x < fb.x) fb.dir = -1; else fb.dir = 1;
    if (!fb.charging) {
      fb.x += fb.dir * fb.speed;
      if (fb.x < arenaLeft + 30) fb.x = arenaLeft + 30;
      if (fb.x + fb.w > arenaRight - 30) fb.x = arenaRight - fb.w - 30;
    }

    fb.shootCooldown--;
    if (fb.shootCooldown <= 0) {
      fb.shootCooldown = fb.phase === 2 ? 18 + Math.floor(Math.random()*15) : 30 + Math.floor(Math.random()*20);
      const dx = fbTarget.x + (fbTarget.w||52)/2 - (fb.x + fb.w/2);
      const dy = fbTarget.y + (fbTarget.h||80)/2 - (fb.y + fb.h/2);
      const dist = Math.sqrt(dx*dx + dy*dy) || 1;

      epsteinProjectiles.push({
        x: fb.x + fb.w/2, y: fb.y + fb.h/3,
        vx: (dx/dist) * 6, vy: (dy/dist) * 6,
        life: 180, rotation: 0, size: 30 + Math.random()*15,
        imgIdx: Math.floor(Math.random() * 5),
      });

      if (Math.random() < 0.4) {
        bullets.push({
          x: fb.x + fb.w/2, y: fb.y + fb.h * 0.4,
          vx: fb.dir * 5.5, vy: (Math.random()-0.5) * 2,
          life: 200,
        });
      }
      spawnParticles(fb.x + fb.w/2, fb.y + fb.h/3, '#ff8844', 5);

      if (fb.phase === 2 && Math.random() < 0.35) {
        for (let a = -0.4; a <= 0.4; a += 0.2) {
          epsteinProjectiles.push({
            x: fb.x + fb.w/2, y: fb.y + fb.h/3,
            vx: fb.dir * 6 * Math.cos(a), vy: 6 * Math.sin(a),
            life: 150, rotation: Math.random()*Math.PI*2, size: 25 + Math.random()*10,
            imgIdx: Math.floor(Math.random() * 5),
          });
        }
      }
    }

    fb.slamCooldown--;
    if (fb.slamCooldown <= 0 && fb.vy === 0) {
      fb.slamCooldown = fb.phase === 2 ? 120 + Math.floor(Math.random()*60) : 180 + Math.floor(Math.random()*80);
      fb.vy = -18;
      shakeTimer = 15;
      fb._slamDelay = 36;
    }

    if (fb._slamDelay !== undefined && fb._slamDelay > 0) {
      fb._slamDelay--;
      if (fb._slamDelay <= 0 && !fusionBoss.dead) {
        shakeTimer = 20;
        screenFlash = 8;
        screenFlashColor = '#ff440044';
        bossVfx.push({ type: 'ring', x: fb.x+fb.w/2, y: fb.y+fb.h, radius: 10, maxRadius: 400, life: 25, maxLife: 25, color: '#ff4400' });
        fusionBoss._slamShock = 25;
      }
    }

    if (fb.phase === 2) {
      fb.dashCooldown--;
      if (fb.dashCooldown <= 0 && !fb.charging) {
        fb.dashCooldown = 100 + Math.floor(Math.random()*80);
        fb.charging = true;
        fb.chargeVx = fb.dir * 12;
        fb._chargeDelay = 48;
        bossVfx.push({ type: 'text', x: fb.x+fb.w/2, y: fb.y - 20, text: 'CHARGE!', life: 40, maxLife: 40, color: '#ff4400' });
      }

      if (fb._chargeDelay !== undefined && fb._chargeDelay > 0) {
        fb._chargeDelay--;
        if (fb._chargeDelay <= 0 && fusionBoss) fusionBoss.charging = false;
      }
      if (fb.charging) {
        fb.x += fb.chargeVx;
        if (fb.x < arenaLeft + 20) { fb.x = arenaLeft + 20; fb.charging = false; }
        if (fb.x + fb.w > arenaRight - 20) { fb.x = arenaRight - fb.w - 20; fb.charging = false; }
        spawnParticles(fb.x + (fb.chargeVx > 0 ? 0 : fb.w), fb.y + fb.h/2, '#ff4400', 3);
      }
    }

   }

    if (p.alive && !p.won && p.iFrames <= 0 && rectsOverlap(p, fusionBoss)) {
      p.hp -= 2;
      p.iFrames = 50;
      p.vx = (p.x < fusionBoss.x ? -1 : 1) * 8;
      p.vy = -8;
      shakeTimer = 12;
      spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4400', 12);
    }

    if (fusionBoss._slamShock > 0) {
      fusionBoss._slamShock--;
      if (fusionBoss._slamShock > 20) {
        shakeTimer = Math.max(shakeTimer, fusionBoss._slamShock);
        if (p.alive && p.onGround && Math.abs(p.x - fusionBoss.x) < 300 && p.iFrames <= 0) {
          p.hp--;
          p.iFrames = 45;
          p.vy = -10;
          spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4400', 10);
        }
      }
    }

    if (p.hp <= 0) {
      handlePlayerDeath();
    }
  }

  if (bossDeathTimer > 0 && fusionBoss && fusionBoss.dead && miniBosses.length === 0) {
    bossDeathTimer--;
    if (bossDeathTimer % 8 === 0 && bossDeathTimer > 40) {
      const ox = (Math.random()-0.5) * 300;
      const oy = (Math.random()-0.5) * 300;
      spawnParticles(fusionBoss.x + fusionBoss.w/2 + ox, fusionBoss.y + fusionBoss.h/2 + oy, ['#ff4400','#8844ff','#ffdd44','#ffffff','#ff44ff'][Math.floor(Math.random()*5)], 20);
      shakeTimer = Math.max(shakeTimer, 12);
    }
    if (bossDeathTimer === 50) {
      screenFlash = 60;
      screenFlashColor = '#ffffff';
      shakeTimer = 50;
      bossVfx.push({ type: 'ring', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y+fusionBoss.h/2, radius: 10, maxRadius: 900, life: 60, maxLife: 60, color: '#ffffff' });
      bossVfx.push({ type: 'text', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y - 40, text: 'THEY\'RE SPLITTING!', life: 180, maxLife: 180, color: '#ff4444' });

      const bArenaW = 2400;
      const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
      const arenaFloor = bigWall.y + 40 + 800;
      const cx = fusionBoss.x + fusionBoss.w/2;
      const cy = fusionBoss.y + fusionBoss.h/2;
      const dm3 = getDiffMult();
      const miniDefs = [
          { name: 'TRUMP', img: 'boss', color: '#ff4400', hp: Math.ceil(18 * dm3.enemyHp), speed: 2.8 * dm3.enemySpeed },
          { name: 'EPSTEIN', img: 'epstein', color: '#8844ff', hp: Math.ceil(15 * dm3.enemyHp), speed: 3.2 * dm3.enemySpeed },
          { name: 'MUSK', img: 'musk', color: '#4488ff', hp: Math.ceil(15 * dm3.enemyHp), speed: 3.8 * dm3.enemySpeed },
          { name: 'CLINTON', img: 'clinton', color: '#cc2222', hp: Math.ceil(12 * dm3.enemyHp), speed: 2.5 * dm3.enemySpeed },
          { name: 'HAWKING', img: 'hawking', color: '#44ff88', hp: Math.ceil(35 * dm3.enemyHp), speed: 1.0 * dm3.enemySpeed },
        ];
      for (let i = 0; i < miniDefs.length; i++) {
        const angle = (i / miniDefs.length) * Math.PI * 2 - Math.PI/2;
        const spawnDist = 120;
        const md = miniDefs[i];
        miniBosses.push({
          x: cx + Math.cos(angle) * spawnDist - 40,
          y: cy + Math.sin(angle) * spawnDist - 50,
          w: 80, h: 100,
          hp: md.hp, maxHp: md.hp,
          name: md.name, imgKey: md.img, color: md.color,
          dir: Math.random() > 0.5 ? 1 : -1,
          speed: md.speed,
          frame: 0, frameTimer: 0,
          dead: false,
          vy: -5 - Math.random() * 5,
          vx: Math.cos(angle) * 6,
          shootCooldown: 30 + Math.floor(Math.random() * 40),
          attackTimer: 0,
        });

        spawnParticles(cx + Math.cos(angle) * spawnDist, cy + Math.sin(angle) * spawnDist, md.color, 15);
        bossVfx.push({ type: 'ring', x: cx + Math.cos(angle)*spawnDist, y: cy + Math.sin(angle)*spawnDist, radius: 5, maxRadius: 150, life: 20, maxLife: 20, color: md.color });
      }

      state = 'splitfight';
      bossIntroTimer = 1800;

      bossMinions = [];
      bullets = [];
      epsteinProjectiles = [];

      player.maxHp = 50;
      player.hp = player.maxHp;

      screenFlash = 80;
      screenFlashColor = '#ffffff';
      shakeTimer = 60;

      const splitColors = ['#ff4400','#8844ff','#4488ff','#cc2222', hawkingPhase2 ? '#ffd700' : '#44ff88'];
      for (let sc = 0; sc < splitColors.length; sc++) {
        bossVfx.push({ type: 'ring', x: cx, y: cy, radius: 5 + sc*20, maxRadius: 400 + sc*150, life: 70 + sc*10, maxLife: 70 + sc*10, color: splitColors[sc] });
      }

      for (let lb = 0; lb < 12; lb++) {
        const lx = arenaLeft + Math.random() * bArenaW;
        const ly = bigWall.y + 40 + Math.random() * 400;
        spawnParticles(lx, ly, splitColors[lb % 5], 15);
        bossVfx.push({ type: 'ring', x: lx, y: ly, radius: 3, maxRadius: 80, life: 20, maxLife: 20, color: splitColors[lb % 5] });
      }
      bossVfx.push({ type: 'text', x: cx, y: cy - 80, text: '⚡ THE CABAL UNLEASHED ⚡', life: 240, maxLife: 240, color: '#ffdd44', size: 42, vy: -0.2 });
      bossVfx.push({ type: 'text', x: cx, y: cy - 40, text: 'FIVE AGAINST ONE', life: 200, maxLife: 200, color: '#ff4444', size: 28, vy: -0.15 });
    }
  }

  if (state === 'splitfight' && miniBosses.length > 0) {
    const bArenaW = 2400;
    const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
    const arenaRight = arenaLeft + bArenaW;
    const arenaTop = bigWall.y + 40;
    const arenaFloor = arenaTop + 800;
    const othersAlive = miniBosses.filter(m => !m.dead && m.name !== 'HAWKING').length;
    const hawkingAlone = othersAlive === 0;

    for (const mb of miniBosses) {
      if (mb.dead) continue;

      mb.frameTimer++;
      if (mb.frameTimer > 8) { mb.frameTimer = 0; mb.frame = (mb.frame + 1) % 4; }
      mb.attackTimer++;
      if (!mb.specialTimer) mb.specialTimer = 0;
      mb.specialTimer++;

      if (_mpHost) {

      mb.vy += GRAVITY * 0.8;
      mb.y += mb.vy;
      if (mb.vx) { mb.x += mb.vx; mb.vx *= 0.95; if (Math.abs(mb.vx) < 0.3) mb.vx = 0; }
      for (const plat of arenaPlats) {
        if (rectsOverlap(mb, plat) && mb.vy >= 0) {
          const oTop = (mb.y + mb.h) - plat.y;
          if (oTop > 0 && oTop < 40) {
            mb.y = plat.y - mb.h;
            mb.vy = 0;
          }
        }
      }

      const mbTarget = mpEnabled ? getNearestPlayerTarget(mb.x + mb.w/2, mb.y + mb.h/2) : p;
      if (mbTarget.x < mb.x) mb.dir = -1; else mb.dir = 1;
      const chaseSpeed = mb.name === 'HAWKING' && hawkingAlone ? mb.speed * 2.5 : mb.speed;
      mb.x += mb.dir * chaseSpeed;
      if (mb.x < arenaLeft + 20) mb.x = arenaLeft + 20;
      if (mb.x + mb.w > arenaRight - 20) mb.x = arenaRight - mb.w - 20;

      mb.shootCooldown--;
      const dx = mbTarget.x + (mbTarget.w||52)/2 - (mb.x + mb.w/2);
      const dy = mbTarget.y + (mbTarget.h||80)/2 - (mb.y + mb.h/2);
      const dist = Math.sqrt(dx*dx + dy*dy) || 1;
      const dm = getDiffMult();

      if (mb.name === 'TRUMP') {

        if (mb.shootCooldown <= 0) {
          mb.shootCooldown = 50 + Math.floor(Math.random() * 20);

          for (let s = -2; s <= 2; s++) {
            const angle = Math.atan2(dy, dx) + s * 0.2;
            epsteinProjectiles.push({
              x: mb.x + mb.w/2, y: mb.y + mb.h/3,
              vx: Math.cos(angle) * 5.5 * dm.projSpeed, vy: Math.sin(angle) * 5.5 * dm.projSpeed,
              life: 120, rotation: Math.random()*Math.PI*2, size: 20, imgIdx: 0,
            });
          }
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, '#ff4400', 10);
        }

        if (mb.specialTimer % 140 === 0 && mb.vy === 0) {
          mb.vy = -14;
          mb._slamDelay = 21;
        }

        if (mb._slamDelay !== undefined && mb._slamDelay > 0) {
          mb._slamDelay--;
          if (mb._slamDelay <= 0 && !mb.dead) {
            shakeTimer = 15;
            spawnParticles(mb.x + mb.w/2, mb.y + mb.h, '#ff4400', 20);

            for (let fw = -1; fw <= 1; fw += 2) {
              for (let fi = 1; fi <= 3; fi++) {
                epsteinProjectiles.push({
                  x: mb.x + mb.w/2 + fw * fi * 40, y: mb.y + mb.h - 20,
                  vx: fw * fi * 2.5, vy: -1,
                  life: 80, rotation: 0, size: 22, imgIdx: 0, isFireWave: true,
                });
              }
            }

            mb._slamShock = 25;
          }
        }

        if (mb.specialTimer % 400 === 0) {
          bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 30, text: 'MAGA RAGE!', life: 60, maxLife: 60, color: '#ff4400' });
          bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 200, life: 25, maxLife: 25, color: '#ff4400' });
          mb.shootCooldown = 0;
          shakeTimer = 8;
        }
      }
      else if (mb.name === 'EPSTEIN') {

        if (mb.shootCooldown <= 0) {
          mb.shootCooldown = 50 + Math.floor(Math.random() * 20);

          for (let h = 0; h < 2; h++) {
            const spreadAngle = Math.atan2(dy, dx) + (h === 0 ? -0.3 : 0.3);
            epsteinProjectiles.push({
              x: mb.x + mb.w/2, y: mb.y + mb.h/3,
              vx: Math.cos(spreadAngle) * 3.5 * dm.projSpeed, vy: Math.sin(spreadAngle) * 3.5 * dm.projSpeed,
              life: 220, rotation: Math.random()*Math.PI*2, size: 25,
              imgIdx: 4, homing: true,
            });
          }
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, '#8844ff', 6);
        }

        if (mb.specialTimer % 200 === 0) {
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#8844ff', 18);

          for (let pc = 0; pc < 4; pc++) {
            epsteinProjectiles.push({
              x: mb.x + mb.w/2 + (Math.random()-0.5)*60, y: mb.y + mb.h/2 + (Math.random()-0.5)*60,
              vx: (Math.random()-0.5)*1.5, vy: (Math.random()-0.5)*1.5,
              life: 150, rotation: Math.random()*Math.PI*2, size: 30, imgIdx: 4,
            });
          }

          const teleX = mbTarget.x + (Math.random() > 0.5 ? 1 : -1) * (120 + Math.random() * 200);
          mb.x = Math.max(arenaLeft + 30, Math.min(arenaRight - mb.w - 30, teleX));
          mb.y = Math.max(arenaTop + 50, mb.y - 100 - Math.random() * 100);
          mb.vy = 0;
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#8844ff', 18);
          bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 20, text: 'FROM THE SHADOWS', life: 50, maxLife: 50, color: '#8844ff' });
          shakeTimer = 6;
        }

        if (mb.specialTimer % 350 === 0) {
          for (let w = 0; w < 6; w++) {
            const angle = (Math.PI * 2 / 6) * w;
            epsteinProjectiles.push({
              x: mb.x + mb.w/2, y: mb.y + mb.h/2,
              vx: Math.cos(angle) * 2.5, vy: Math.sin(angle) * 2.5,
              life: 180, rotation: angle, size: 22, imgIdx: 4,
            });
          }
          bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 180, life: 20, maxLife: 20, color: '#8844ff' });
        }
      }
      else if (mb.name === 'MUSK') {

        if (mb.shootCooldown <= 0) {
          mb.shootCooldown = 35 + Math.floor(Math.random() * 15);

          for (let b = 0; b < 3; b++) {
            const spread = (b - 1) * 0.15;
            const angle = Math.atan2(dy, dx) + spread;
            epsteinProjectiles.push({
              x: mb.x + mb.w/2, y: mb.y + mb.h/3,
              vx: Math.cos(angle) * 7 * dm.projSpeed, vy: Math.sin(angle) * 7 * dm.projSpeed,
              life: 90, rotation: Math.random()*Math.PI*2, size: 16, imgIdx: 0,
            });
          }
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, '#4488ff', 6);
        }

        if (mb.specialTimer % 100 === 0) {
          const oldX = mb.x;
          mb.vx = mb.dir * 22;
          mb.vy = -5;

          for (let et = 0; et < 5; et++) {
            epsteinProjectiles.push({
              x: oldX + mb.w/2 + et * mb.dir * 20, y: mb.y + mb.h/2,
              vx: 0, vy: -0.5,
              life: 60, rotation: Math.random()*Math.PI*2, size: 18, imgIdx: 0,
            });
          }
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#4488ff', 15);
          bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 120, life: 15, maxLife: 15, color: '#4488ff' });
        }

        if (mb.specialTimer % 250 === 0) {
          bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 30, text: 'DRONE STRIKE!', life: 60, maxLife: 60, color: '#4488ff' });
          for (let ds = 0; ds < 6; ds++) {
            const dropX = mbTarget.x - 150 + ds * 60 + (Math.random()-0.5)*30;
            epsteinProjectiles.push({
              x: dropX, y: arenaTop + 20,
              vx: (Math.random()-0.5)*1.5, vy: 5 + Math.random()*2,
              life: 120, rotation: Math.random()*Math.PI*2, size: 20, imgIdx: 0,
            });
          }
          shakeTimer = 8;
        }
      }
      else if (mb.name === 'CLINTON') {

        if (mb.shootCooldown <= 0) {
          mb.shootCooldown = 60 + Math.floor(Math.random() * 30);

          epsteinProjectiles.push({
            x: mb.x + mb.w/2, y: mb.y + mb.h/3,
            vx: (dx/dist) * 4.5 * dm.projSpeed, vy: (dy/dist) * 4.5 * dm.projSpeed,
            life: 160, rotation: Math.random()*Math.PI*2, size: 24, imgIdx: 4,
          });

          epsteinProjectiles.push({
            x: mb.x + mb.w/2, y: mb.y + mb.h/3,
            vx: (dx/dist) * 3, vy: -6,
            life: 140, rotation: Math.random()*Math.PI*2, size: 22, imgIdx: 4,
          });
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, '#cc2222', 6);
        }

        if (mb.specialTimer % 160 === 0) {
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#cc2222', 18);
          const behindX = mbTarget.x + ((mbTarget.facing||1) > 0 ? -90 : (mbTarget.w||52) + 50);
          mb.x = Math.max(arenaLeft + 20, Math.min(arenaRight - mb.w - 20, behindX));
          mb.y = mbTarget.y - 15;
          mb.vy = 0;
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#cc2222', 18);
          bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 20, text: 'NOTHING HAPPENED', life: 50, maxLife: 50, color: '#cc2222' });
          shakeTimer = 8;

          epsteinProjectiles.push({
            x: mb.x + mb.w/2, y: mb.y + mb.h/3,
            vx: (mbTarget.x < mb.x ? -1 : 1) * 6, vy: 0,
            life: 60, rotation: 0, size: 28, imgIdx: 4,
          });
        }

        if (mb.specialTimer % 300 === 0) {
          for (let d = 0; d < 8; d++) {
            const angle = (Math.PI * 2 / 8) * d;
            epsteinProjectiles.push({
              x: mb.x + mb.w/2, y: mb.y + mb.h/2,
              vx: Math.cos(angle) * 2, vy: Math.sin(angle) * 2,
              life: 200, rotation: angle, size: 20, imgIdx: 4,
            });
          }
          bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 160, life: 20, maxLife: 20, color: '#cc2222' });
        }
      }
      else if (mb.name === 'HAWKING') {
        const isPhase2 = hawkingPhase2;

        if (mb.shootCooldown <= 0) {
          mb.shootCooldown = isPhase2 ? 20 : (hawkingAlone ? 30 : 55);

          const numProj = isPhase2 ? 12 : (hawkingAlone ? 8 : 5);
          for (let o = 0; o < numProj; o++) {
            const angle = (Math.PI * 2 / numProj) * o + mb.specialTimer * 0.05;
            epsteinProjectiles.push({
              x: mb.x + mb.w/2, y: mb.y + mb.h/3,
              vx: Math.cos(angle) * (isPhase2 ? 5 : 4), vy: Math.sin(angle) * (isPhase2 ? 5 : 4),
              life: 140, rotation: angle, size: isPhase2 ? 24 : 20, imgIdx: 0,
            });
          }
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, hawkingPhase2 ? '#ffd700' : '#44ff88', 10);

          epsteinProjectiles.push({
            x: mb.x + mb.w/2, y: mb.y + mb.h/3,
            vx: (dx/dist) * 6, vy: (dy/dist) * 6,
            life: 200, rotation: Math.random()*Math.PI*2, size: isPhase2 ? 32 : 28,
            imgIdx: 4, homing: true,
          });
        }

        const gravInterval = isPhase2 ? 150 : (hawkingAlone ? 250 : 400);
        if (mb.specialTimer % gravInterval === 0) {
          bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 300, maxRadius: 10, life: 40, maxLife: 40, color: hawkingPhase2 ? '#ffd700' : '#44ff88' });
          bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 30, text: isPhase2 ? 'BLACK HOLE' : 'SINGULARITY', life: 60, maxLife: 60, color: hawkingPhase2 ? '#ffd700' : '#44ff88' });
          mb._gravPull = { active: 40, str: isPhase2 ? 6 : 4, range: isPhase2 ? 700 : 500 };
          shakeTimer = isPhase2 ? 15 : 10;
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, hawkingPhase2 ? '#ffd700' : '#44ff88', 25);
        }

        if (isPhase2 && mb.specialTimer % 80 === 0) {
          for (let hr = 0; hr < 4; hr++) {
            const rx = mb.x + mb.w/2 + (Math.random()-0.5)*400;
            epsteinProjectiles.push({
              x: rx, y: arenaTop + 10,
              vx: (Math.random()-0.5)*2, vy: 4 + Math.random()*3,
              life: 120, rotation: Math.random()*Math.PI*2, size: 22, imgIdx: 0,
            });
          }
        }

        if (isPhase2 && mb.specialTimer % 200 === 0) {
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffd700', 20);
          bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 200, life: 20, maxLife: 20, color: '#ffd700' });
          const _warpTarget = mpEnabled ? getNearestPlayerTarget(mb.x + mb.w/2, mb.y + mb.h/2) : p;
          mb.x = _warpTarget.x + (Math.random() > 0.5 ? 200 : -200 - mb.w);
          mb.x = Math.max(arenaLeft + 20, Math.min(arenaRight - mb.w - 20, mb.x));
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffd700', 20);
          bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y-30, text: 'WORMHOLE', life: 40, maxLife: 40, color: '#ffd700' });
        }
      }

      }

      const contactDmg = (mb.name === 'HAWKING' && hawkingAlone) ? (hawkingPhase2 ? 3 : 2) : 1;
      if (p.alive && !p.won && p.iFrames <= 0 && rectsOverlap(p, mb)) {
        p.hp -= contactDmg;
        p.iFrames = 40;
        p.vx = (p.x < mb.x ? -1 : 1) * 5;
        p.vy = -6;
        shakeTimer = 8;
        spawnParticles(p.x + p.w/2, p.y + p.h/2, mb.color, 8);
      }

      if (mb.name === 'HAWKING' && mb._gravPull && mb._gravPull.active > 0) {
        mb._gravPull.active--;
        if (!p.alive) continue;
        const gpDx = (mb.x + mb.w/2) - (p.x + p.w/2);
        const gpDy = (mb.y + mb.h/2) - (p.y + p.h/2);
        const gpDist = Math.sqrt(gpDx*gpDx + gpDy*gpDy) || 1;
        if (gpDist < mb._gravPull.range) {
          p.vx += (gpDx / gpDist) * mb._gravPull.str * 0.15;
          p.vy += (gpDy / gpDist) * (mb._gravPull.str - 1) * 0.15;
        }
      }

      if (mb._slamShock > 0) {
        mb._slamShock--;
        if (mb._slamShock > 20) {
          shakeTimer = Math.max(shakeTimer, mb._slamShock);
          const shockDist = Math.abs(p.x - mb.x);
          if (p.alive && shockDist < 250 && p.iFrames <= 0 && Math.abs(p.y + p.h - (mb.y + mb.h)) < 60) {
            p.hp -= 3;
            p.iFrames = 45;
            p.vy = -10;
            spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4400', 12);
          }
        }
      }
    }

    for (const proj of epsteinProjectiles) {
      if (proj.homing && proj.life > 30) {
        const _homingTarget = mpEnabled ? getNearestPlayerTarget(proj.x, proj.y) : p;
        const hdx = _homingTarget.x + (_homingTarget.w||52)/2 - proj.x;
        const hdy = _homingTarget.y + (_homingTarget.h||80)/2 - proj.y;
        const hdist = Math.sqrt(hdx*hdx + hdy*hdy) || 1;
        proj.vx += (hdx / hdist) * 0.15;
        proj.vy += (hdy / hdist) * 0.15;

        const spd = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy);
        if (spd > 5) { proj.vx = (proj.vx/spd)*5; proj.vy = (proj.vy/spd)*5; }
      }
    }

    if (p.hp <= 0) {
      handlePlayerDeath();
    }

    const allDead = miniBosses.length > 0 && miniBosses.every(mb => mb.dead);
    if (allDead && state === 'splitfight') {
      bossDeathTimer = 0;
      screenFlash = 60;
      screenFlashColor = '#ffffff';
      shakeTimer = 50;
      for (let i = 0; i < 150; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 14;
        particles.push({ x: p.x + p.w/2, y: p.y + p.h/2, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed-3, life: 80+Math.random()*60, color: ['#ff4400','#8844ff','#ffdd44','#ffffff','#44ff88','#4488ff','#ff44ff'][Math.floor(Math.random()*7)], size: 3+Math.random()*8 });
      }
      bossVfx.push({ type: 'ring', x: p.x+p.w/2, y: p.y+p.h/2, radius: 10, maxRadius: 900, life: 70, maxLife: 70, color: '#ffdd44' });
      bossVfx.push({ type: 'text', x: p.x+p.w/2, y: p.y - 50, text: '★ FREEDOM! ★', life: 200, maxLife: 200, color: '#ffdd44' });

      player.x = bigWall.x + bigWall.w + 30;
      player.y = bigWall.y - player.h;
      player.vy = 0; player.vx = 0;
      arenaPlats = [];
      guards = [];
      bullets = [];
      projectiles = [];
      epsteinProjectiles = [];
      bossMinions = [];
      state = 'winCutscene';
      winCutsceneTimer = 0;
      player.won = true;
      player.alive = true;
      player.hp = player.maxHp;
      player.iFrames = 99999;
      mpSpectating = false;
      spawnParticles(player.x, player.y, '#ffdd44', 50);
      spawnParticles(player.x, player.y, '#ff6644', 40);
      restartCooldown = 60;
    }
  }

  if (state === 'hawkingRefusal') {
    hawkingRefusalTimer++;
    const t = hawkingRefusalTimer;

    if (t === 1) hawkingRefusalPhase = 0;
    if (t === 60) hawkingRefusalPhase = 1;
    if (t === 120) hawkingRefusalPhase = 2;
    if (t === 180) hawkingRefusalPhase = 3;
    if (t === 220) hawkingRefusalPhase = 4;
    if (t === 280) hawkingRefusalPhase = 5;
    if (t === 340) hawkingRefusalPhase = 6;
    if (t === 400) hawkingRefusalPhase = 7;
    if (t === 460) hawkingRefusalPhase = 8;
    if (t === 520) hawkingRefusalPhase = 9;
    if (t === 620) hawkingRefusalPhase = 10;
    if (t === 780) hawkingRefusalPhase = 11;
    if (t === 920) hawkingRefusalPhase = 12;
    if (t === 1120) hawkingRefusalPhase = 13;

    if (t === 1130) {
      hawkingPhase2 = true;
      state = 'splitfight';
      const hawk = miniBosses.find(m => m.name === 'HAWKING');
      if (hawk) {

        const dm = getDiffMult();
        hawk.w = 160;
        hawk.h = 200;
        hawk.hp = Math.ceil(50 * dm.enemyHp);
        hawk.maxHp = hawk.hp;
        hawk.speed = 1.2 * dm.enemySpeed;
        hawk.dead = false;
        hawk.shootCooldown = 30;
        hawk.specialTimer = 0;
        hawk.color = '#ffd700';

        const bArenaW = 2400;
        const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
        const arenaFloor = bigWall.y + 40 + 800;
        hawk.x = arenaLeft + bArenaW/2 - hawk.w/2;
        hawk.y = arenaFloor - hawk.h - 50;
        hawk.vy = -15;
        bossVfx.push({ type: 'text', x: hawk.x + hawk.w/2, y: hawk.y - 60, text: 'HAWKING TRANSCENDED', life: 180, maxLife: 180, color: '#ffd700' });
        bossVfx.push({ type: 'ring', x: hawk.x + hawk.w/2, y: hawk.y + hawk.h/2, radius: 10, maxRadius: 800, life: 50, maxLife: 50, color: '#ffd700' });
      }

      player.hp = Math.min(player.maxHp, player.hp + 15);
      screenFlash = 80;
      screenFlashColor = '#ffd700';
      shakeTimer = 60;
    }
  }

  if (state === 'hawkingDeath') {
    hawkingDeathTimer++;
    const dt = hawkingDeathTimer;
    const hawk = miniBosses.find(m => m.name === 'HAWKING');
    const hx = hawk ? hawk._deathX || (hawk.x + hawk.w/2) : W/2;
    const hy = hawk ? hawk._deathY || (hawk.y + hawk.h/2) : H/2;

    if (dt < 80) {

      if (dt % 4 === 0) {
        spawnParticles(hx + (Math.random()-0.5)*80, hy + (Math.random()-0.5)*80, '#ffd700', 3);
      }

      if (dt > 30) shakeTimer = Math.max(shakeTimer, 3 + Math.floor((dt-30)/10));
    }

    if (dt >= 80 && dt < 200) {
      const riseProg = (dt - 80) / 120;
      if (hawk) {
        hawk.y -= 1.5 * (1 - riseProg);
      }

      if (dt % 2 === 0) {
        for (let i = 0; i < 5; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 2 + Math.random() * 6;
          particles.push({
            x: hx, y: hy - (dt-80)*1.2,
            vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
            life: 40 + Math.random() * 40,
            color: ['#ffd700','#ffcc00','#ffaa00','#ffffff','#ffe066'][Math.floor(Math.random()*5)],
            size: 2 + Math.random() * 5,
          });
        }
      }

      if (dt % 20 === 0) {
        bossVfx.push({ type: 'ring', x: hx, y: hy - (dt-80)*1.2, radius: 5, maxRadius: 300 + riseProg * 200, life: 35, maxLife: 35, color: '#ffd700' });
      }
      shakeTimer = Math.max(shakeTimer, 5 + Math.floor(riseProg * 15));

      if (dt % 30 === 0) { screenFlash = 8; screenFlashColor = '#ffd700'; }
    }

    if (dt >= 200 && dt < 400) {
      const crackProg = (dt - 200) / 200;

      if (dt % 3 === 0) {
        for (let i = 0; i < 4; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 3 + Math.random() * 8;
          particles.push({
            x: hx, y: hy - 150,
            vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 2,
            life: 50 + Math.random() * 60,
            color: ['#ffd700','#ffffff','#ffdd44','#4488ff','#ff44ff'][Math.floor(Math.random()*5)],
            size: 3 + Math.random() * 6,
          });
        }
      }

      if (dt % 25 === 0) {
        bossVfx.push({ type: 'ring', x: hx, y: hy - 150, radius: 10, maxRadius: 500, life: 40, maxLife: 40, color: '#ffffff' });
      }
      shakeTimer = Math.max(shakeTimer, 10 + Math.floor(crackProg * 25));

      if (dt % 15 === 0 && crackProg > 0.5) { screenFlash = 10; screenFlashColor = '#ffffff'; }
    }

    if (dt >= 400 && dt < 550) {
      const disProg = (dt - 400) / 150;

      if (dt % 2 === 0) {
        for (let i = 0; i < 8; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 1 + Math.random() * 10 * disProg;
          particles.push({
            x: hx + (Math.random()-0.5) * 60 * disProg, y: hy - 150 + (Math.random()-0.5) * 60 * disProg,
            vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 1,
            life: 80 + Math.random() * 80,
            color: ['#ffd700','#ffcc00','#ffffff','#ffdd44','#ffe066','#ffaa00'][Math.floor(Math.random()*6)],
            size: 1 + Math.random() * 4,
          });
        }
      }
      if (dt >= 400 && dt <= 401) { screenFlash = 40; screenFlashColor = '#ffd700'; shakeTimer = 40; }
      if (dt >= 450 && dt <= 451) { screenFlash = 30; screenFlashColor = '#ffffff'; }

    }

    if (dt >= 550 && dt < 750) {

      if (dt % 6 === 0) {
        particles.push({
          x: Math.random() * W, y: Math.random() * H,
          vx: (Math.random()-0.5) * 0.5, vy: -Math.random() * 0.5 - 0.2,
          life: 60 + Math.random() * 40,
          color: ['#ffd70044','#ffffff44','#ffdd4444'][Math.floor(Math.random()*3)],
          size: 1 + Math.random() * 2,
        });
      }
    }

    if (dt >= 750 && dt <= 751) {
      screenFlash = 80;
      screenFlashColor = '#ffffff';
      shakeTimer = 30;

      for (let i = 0; i < 200; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 15;
        particles.push({
          x: hx, y: hy - 150,
          vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 3,
          life: 80 + Math.random() * 80,
          color: ['#ffd700','#ffffff','#ffdd44','#ffe066','#ffcc00'][Math.floor(Math.random()*5)],
          size: 2 + Math.random() * 8,
        });
      }
    }

    if (dt === 900) {

      if (hawk) { hawk.hp = 0; hawk.dead = true; }

      for (const mb of miniBosses) mb.dead = true;

      bossDeathTimer = 0;
      screenFlash = 60;
      screenFlashColor = '#ffffff';
      shakeTimer = 50;
      for (let i = 0; i < 150; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 14;
        particles.push({ x: player.x + player.w/2, y: player.y + player.h/2, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed-3, life: 80+Math.random()*60, color: ['#ff4400','#8844ff','#ffdd44','#ffffff','#44ff88','#4488ff','#ff44ff'][Math.floor(Math.random()*7)], size: 3+Math.random()*8 });
      }
      bossVfx.push({ type: 'ring', x: player.x+player.w/2, y: player.y+player.h/2, radius: 10, maxRadius: 900, life: 70, maxLife: 70, color: '#ffdd44' });
      bossVfx.push({ type: 'text', x: player.x+player.w/2, y: player.y - 50, text: '★ FREEDOM! ★', life: 200, maxLife: 200, color: '#ffdd44' });
      if (bigWall) {
        player.x = bigWall.x + bigWall.w + 30;
        player.y = bigWall.y - player.h;
      }
      player.vy = 0; player.vx = 0;
      arenaPlats = [];
      guards = [];
      bullets = [];
      projectiles = [];
      epsteinProjectiles = [];
      bossMinions = [];
      state = 'winCutscene';
      winCutsceneTimer = 0;
      player.won = true;
      player.alive = true;
      player.hp = player.maxHp;
      player.iFrames = 99999;
      mpSpectating = false;
      spawnParticles(player.x, player.y, '#ffdd44', 50);
      spawnParticles(player.x, player.y, '#ff6644', 40);
      restartCooldown = 60;
    }

    if (hawkingDeathTimer > 910) hawkingDeathTimer = 910;
  }

  if (state === 'winCutscene') {
    winCutsceneTimer++;
    const wt = winCutsceneTimer;

    if (wt === 1) {
      winCutsceneOfficeX = player.x + 750;
    }

    if (wt < 300) {
      player.x += 2.5;
      player.runFrame = (player.runFrame || 0) + 0.3;
      player.facing = 1;
    }

    if (wt === 300) {
      player.runFrame = 0;
    }

    cameraX = player.x - W * 0.3;
    if (cameraX < 0) cameraX = 0;

    if (wt >= 700) {
      state = 'won';
      restartCooldown = 0;
    }
  }

  for (let i = bossVfx.length - 1; i >= 0; i--) {
    const vfx = bossVfx[i];
    vfx.life--;
    if (vfx.vy) vfx.y += vfx.vy;
    if (vfx.type === 'ring') {
      const prog = 1 - vfx.life / vfx.maxLife;
      vfx.radius = vfx.maxRadius * prog;
    }
    if (vfx.life <= 0) bossVfx.splice(i, 1);
  }

  if ((state === 'bossfight' || state === 'bossdialogue') && boss && !boss.dead) {

    if (Math.random() < 0.3 * boss.phase) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 40 + Math.random() * 60;
      const colors = { 1: '#ff660044', 2: '#ff880066', 3: '#ff220088' };
      particles.push({
        x: boss.x + boss.w/2 + Math.cos(angle) * dist,
        y: boss.y + boss.h/2 + Math.sin(angle) * dist,
        vx: Math.cos(angle + Math.PI/2) * 1.5,
        vy: Math.sin(angle + Math.PI/2) * 1.5 - 1,
        life: 20 + Math.random() * 20,
        color: colors[boss.phase],
        size: 2 + Math.random() * 3,
      });
    }

    if (boss.phase === 3 && Math.random() < 0.4) {
      particles.push({
        x: boss.x + Math.random() * boss.w,
        y: boss.y + boss.h,
        vx: (Math.random()-0.5) * 2,
        vy: -Math.random() * 4 - 1,
        life: 15 + Math.random() * 15,
        color: ['#ff2200','#ff6600','#ffaa00','#ffcc00'][Math.floor(Math.random()*4)],
        size: 2 + Math.random() * 4,
      });
    }
  }

  if (state === 'epsteinfight' && epstein && !epstein.dead) {
    if (Math.random() < 0.25 * epstein.phase) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 40 + Math.random() * 60;
      particles.push({
        x: epstein.x + epstein.w/2 + Math.cos(angle) * dist,
        y: epstein.y + epstein.h/2 + Math.sin(angle) * dist,
        vx: Math.cos(angle + Math.PI/2) * 1.2,
        vy: Math.sin(angle + Math.PI/2) * 1.2 - 1,
        life: 18 + Math.random() * 18,
        color: epstein.phase === 2 ? '#ff44ff66' : '#8844ff44',
        size: 2 + Math.random() * 3,
      });
    }

    if (Math.random() < 0.3) {
      particles.push({
        x: epstein.x + Math.random() * epstein.w,
        y: epstein.y + epstein.h,
        vx: (Math.random()-0.5) * 2,
        vy: -Math.random() * 2 - 0.5,
        life: 15 + Math.random() * 15,
        color: ['#8844ff','#aa66ff','#6622cc','#ff44ff'][Math.floor(Math.random()*4)],
        size: 2 + Math.random() * 3,
      });
    }
  }

  if (state === 'fusionfight' && fusionBoss && !fusionBoss.dead) {
    if (Math.random() < 0.4) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 50 + Math.random() * 80;
      particles.push({
        x: fusionBoss.x + fusionBoss.w/2 + Math.cos(angle) * dist,
        y: fusionBoss.y + fusionBoss.h/2 + Math.sin(angle) * dist,
        vx: Math.cos(angle + Math.PI/2) * 1.5,
        vy: Math.sin(angle + Math.PI/2) * 1.5 - 1,
        life: 20 + Math.random() * 20,
        color: ['#ff440066','#8844ff66','#ff880044','#ffdd4444'][Math.floor(Math.random()*4)],
        size: 2 + Math.random() * 4,
      });
    }

    if (Math.random() < 0.4) {
      particles.push({
        x: fusionBoss.x + Math.random() * fusionBoss.w,
        y: fusionBoss.y + fusionBoss.h,
        vx: (Math.random()-0.5) * 3,
        vy: -Math.random() * 4 - 1,
        life: 15 + Math.random() * 15,
        color: ['#ff4400','#8844ff','#ff8800','#ffcc00'][Math.floor(Math.random()*4)],
        size: 2 + Math.random() * 4,
      });
    }
  }

  if (state === 'splitfight') {
    for (const mb of miniBosses) {
      if (mb.dead) continue;
      if (Math.random() < 0.15) {
        particles.push({
          x: mb.x + Math.random() * mb.w,
          y: mb.y + mb.h,
          vx: (Math.random()-0.5) * 2,
          vy: -Math.random() * 2 - 0.5,
          life: 12 + Math.random() * 10,
          color: mb.color,
          size: 2 + Math.random() * 2,
        });
      }
    }
  }

  if (state === 'endless' || state === 'endlessShop') {
    endless.roundTimer++;

    const zoomTarget = Math.min(W / (endless.arenaW + 80), H / (endless.arenaH + 80));
    endless.endlessZoom += (zoomTarget - endless.endlessZoom) * 0.05;
    const ez = endless.endlessZoom;

    const camTargetX = endless.arenaX + endless.arenaW / 2 - (W / ez) / 2;
    const camTargetY = endless.arenaY + endless.arenaH / 2 - (H / ez) / 2;
    cameraX += (camTargetX - cameraX) * 0.08;
    cameraY += (camTargetY - cameraY) * 0.08;

    if (state === 'endless' && player.alive) {
      const topZone = endless.arenaY + endless.arenaH * 0.2;
      if (player.y < topZone) {
        endless.roofTimer++;
      } else {
        endless.roofTimer = Math.max(0, endless.roofTimer - 3);
      }

      if (endless.roofTimer > 240) {
        const roofSpeed = Math.min(3, (endless.roofTimer - 240) * 0.008);
        endless.roofY = Math.min(endless.arenaH * 0.6, endless.roofY + roofSpeed);

        if (player.y < endless.arenaY + endless.roofY) {
          player.y = endless.arenaY + endless.roofY;
          player.vy = Math.max(player.vy, 2);
          if (Math.random() < 0.3) spawnParticles(player.x + player.w/2, player.y, '#ff4444', 3);
        }
      } else {

        endless.roofY = Math.max(0, endless.roofY - 1.5);
      }
    }

    if (state === 'endless' && endless.powerups.regenBoost > 0 && player.alive) {
      const regenRate = [480, 300, 180][endless.powerups.regenBoost - 1];
      if (endless.roundTimer % regenRate === 0 && player.hp < player.maxHp) {
        player.hp++;
      }
    }

    if (endless.dashCooldown > 0) endless.dashCooldown--;

    if (state === 'endless' && endless.powerups.freezeAura > 0 && player.alive) {
      const freezeRadius = 120 + endless.powerups.freezeAura * 60;
      const slowFactor = 0.6 - endless.powerups.freezeAura * 0.1;
      for (const e of endless.enemies) {
        if (e.dead) continue;

        if (e._origSpeed === undefined) e._origSpeed = e.speed;
        const dx = (e.x + e.w/2) - (player.x + player.w/2);
        const dy = (e.y + e.h/2) - (player.y + player.h/2);
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < freezeRadius) {
          e.speed = e._origSpeed * slowFactor;
          e._frozen = true;

          if (Math.random() < 0.03) spawnParticles(e.x + e.w/2, e.y + e.h/3, '#88ccff', 2);
        } else if (e._frozen) {

          e.speed = e._origSpeed;
          e._frozen = false;
        }
      }
    } else if (state === 'endless') {

      for (const e of endless.enemies) {
        if (e._frozen && e._origSpeed !== undefined) { e.speed = e._origSpeed; e._frozen = false; }
      }
    }

    if (state === 'endless' && endless.spawnsLeft > 0 && (!mpEnabled || isHost)) {
      endless.spawnTimer--;
      if (endless.spawnTimer <= 0) {
        endlessSpawnEnemy();
        endless.spawnsLeft--;

        endless.spawnTimer = Math.max(25, 70 - endless.round * 2);
      }
    }

    const aX = endless.arenaX, aW = endless.arenaW, aH = endless.arenaH;
    const floorY = endless.arenaY + aH;
    if (!mpEnabled || isHost) {
    const _pendingSummons = [];
    for (const e of endless.enemies) {
      if (e.dead) continue;
      if (e.iFrames > 0) e.iFrames--;

      const px = player.x + player.w / 2;
      const py = player.y + player.h / 2;
      const ex = e.x + e.w / 2;
      const ey = e.y + e.h / 2;
      const dx = px - ex;
      const dy = py - ey;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;

      if (e.isBoss) {
        e.attackTimer--;

        if (e.attackTimer <= 0 && !e.charging && !e.slamming) {
          const atk = e.attacks[Math.floor(Math.random() * e.attacks.length)];
          e.currentAttack = atk;
          if (atk === 'charge') {
            e.charging = true;
            e.chargeVx = (dx > 0 ? 1 : -1) * (e.speed * 4);
            e.attackTimer = 80;
            shakeTimer = 10;
          } else if (atk === 'slam') {
            e.vy = -16;
            e.slamming = true;
            e.attackTimer = 60;
          } else if (atk === 'summon' && e.summonCooldown <= 0) {

            const minionCount = 2 + Math.floor(Math.random() * 2);
            for (let mi = 0; mi < minionCount; mi++) {
              const template = ENDLESS_ENEMY_TIERS[Math.min(Math.floor(endless.round / 5), ENDLESS_ENEMY_TIERS.length - 1)];
              const side = Math.random() > 0.5 ? 1 : -1;
              const mhp = Math.ceil(template.baseHp * (1 + endless.round * 0.1));
              _pendingSummons.push({
                x: side > 0 ? aX + aW - template.w - 10 : aX + 10,
                y: floorY - template.h - 2,
                w: template.w, h: template.h,
                hp: mhp, maxHp: mhp,
                speed: template.baseSpeed * 1.2,
                dir: -side, type: template.type,
                imgKey: template.imgKey, color: template.color,
                frame: 0, frameTimer: 0, vy: 0, dead: false,
                shootCooldown: template.shootCd, attackTimer: 0,
                dmg: template.dmg, iFrames: 0,
              });
            }
            e.summonCooldown = 400;
            e.attackTimer = 100;
            screenFlash = 15;
            screenFlashColor = e.color + '44';
          } else if (atk === 'barrage' && (!e.barrageCooldown || e.barrageCooldown <= 0)) {

            const bCount = 8 + Math.floor(endless.round / 10) * 2;
            for (let bi = 0; bi < bCount; bi++) {
              const angle = (bi / bCount) * Math.PI * 2;
              const bspd = 3 + endless.round * 0.05;
              bullets.push({
                x: ex, y: ey,
                vx: Math.cos(angle) * bspd,
                vy: Math.sin(angle) * bspd,
                w: 8, h: 8, dmg: e.dmg, life: 200,
              });
            }
            e.barrageCooldown = 250;
            e.attackTimer = 80;
            shakeTimer = 15;
          } else if (atk === 'laser') {

            for (let li = 0; li < 5; li++) {
              const spread = (Math.random() - 0.5) * 0.3;
              const bspd = 5 + endless.round * 0.05;
              bullets.push({
                x: ex, y: ey,
                vx: (dx / dist + spread) * bspd,
                vy: (dy / dist + spread) * bspd,
                w: 6, h: 6, dmg: e.dmg, life: 150,
              });
            }
            e.attackTimer = 50;
          } else {
            e.attackTimer = 60;
          }
        }

        if (e.charging) {
          e.x += e.chargeVx;
          e.chargeVx *= 0.97;
          if (Math.abs(e.chargeVx) < 0.5) e.charging = false;

          if (player.alive && player.iFrames <= 0 && rectsOverlap(player, e)) {
            if (endless.shieldCharges > 0) {
              endless.shieldCharges--;
              player.iFrames = 50;
              spawnParticles(player.x + player.w / 2, player.y + player.h / 2, '#44ddff', 15);
            } else {
            player.hp -= e.dmg + 1;
            player.iFrames = 50;
            player.vx = e.chargeVx * 0.5;
            player.vy = -8;
            shakeTimer = 20;
            spawnParticles(player.x + player.w / 2, player.y + player.h / 2, '#ff4444', 15);
            if (player.hp <= 0) {
              handlePlayerDeath();
              if (endless.round > endless.highScore) { endless.highScore = endless.round; localStorage.setItem('endlessHighScore', String(endless.highScore)); }
            }
            }
          }
        }

        if (e.slamming && e.vy >= 0 && e.y + e.h >= floorY - 5) {
          e.slamming = false;
          shakeTimer = 25;
          screenFlash = 10;
          screenFlashColor = e.color + '66';

          const shockDist = 200;
          if (player.alive && player.iFrames <= 0 && Math.abs(player.x - e.x) < shockDist) {
            if (endless.shieldCharges > 0) {
              endless.shieldCharges--;
              player.iFrames = 40;
              spawnParticles(player.x + player.w / 2, player.y + player.h / 2, '#44ddff', 12);
            } else {
            player.hp -= e.dmg;
            player.iFrames = 40;
            player.vy = -10;
            spawnParticles(player.x + player.w / 2, player.y + player.h / 2, '#ff4444', 12);
            if (player.hp <= 0) {
              handlePlayerDeath();
              if (endless.round > endless.highScore) { endless.highScore = endless.round; localStorage.setItem('endlessHighScore', String(endless.highScore)); }
            }
            }
          }

          for (let si = 0; si < 20; si++) {
            spawnParticles(e.x + Math.random() * e.w, floorY, e.color, 2);
          }
        }

        if (e.summonCooldown > 0) e.summonCooldown--;
        if (e.barrageCooldown > 0) e.barrageCooldown--;

        if (!e.charging) {
          if (e._stunTimer > 0) {
            e._stunTimer--;
          } else if (Math.abs(dx) > 60) {
            e.dir = dx > 0 ? 1 : -1;
            e.x += e.dir * e.speed * 0.7;
          }
        }
      } else {

        const moveSpd = e.speed * (1 + endless.round * 0.01);

        if (e._stunTimer > 0) {
          e._stunTimer--;
        } else if (Math.abs(dx) > 30) {
          e.dir = dx > 0 ? 1 : -1;
          e.x += e.dir * moveSpd;
        }
      }

      const grav = (endless.modifier && endless.modifier.name === 'GRAVITY') ? 0.25 : 0.5;
      e.vy += grav;
      e.y += e.vy;

      if (endless.modifier && endless.modifier.name === 'REGEN' && e.hp < e.maxHp) {
        if (endless.roundTimer % 90 === 0) e.hp = Math.min(e.hp + 1, e.maxHp);
      }

      if (e.y + e.h >= floorY) {
        e.y = floorY - e.h;
        e.vy = 0;
      }

      for (const plat of endless.platforms) {
        if (plat.isFloor || plat.isSideWall) continue;
        if (e.x + e.w > plat.x && e.x < plat.x + plat.w &&
            e.y + e.h > plat.y && e.y + e.h < plat.y + 20 && e.vy >= 0) {
          e.y = plat.y - e.h;
          e.vy = 0;
        }
      }

      if (e.x < aX + 5) { e.x = aX + 5; e.dir = 1; if (e.charging) { e.charging = false; e.chargeVx = 0; } }
      if (e.x + e.w > aX + aW - 5) { e.x = aX + aW - e.w - 5; e.dir = -1; if (e.charging) { e.charging = false; e.chargeVx = 0; } }

      if (dy < -80 && e.vy === 0 && Math.abs(dx) < 200 && Math.random() < 0.02) {
        e.vy = -10 - Math.random() * 3;
      }

      e.frameTimer++;
      if (e.frameTimer > 8) { e.frameTimer = 0; e.frame = (e.frame + 1) % 4; }

      if (!e.isBoss) {
        e.shootCooldown--;
        if (e.shootCooldown <= 0 && dist < 500) {
          e.shootCooldown = ENDLESS_ENEMY_TIERS.find(t => t.type === e.type)?.shootCd || 80;
          e.shootCooldown += Math.floor(Math.random() * 20);

          const bspd = 3 + endless.round * 0.1;
          bullets.push({
            x: ex, y: ey,
            vx: (dx / dist) * bspd,
            vy: (dy / dist) * bspd,
            w: 8, h: 8,
            dmg: e.dmg,
            life: 200,
          });
        }
      }

      if (player.alive && player.iFrames <= 0 && rectsOverlap(player, e)) {

        if (endless.shieldCharges > 0) {
          endless.shieldCharges--;
          player.iFrames = 30;
          shakeTimer = 6;
          spawnParticles(player.x + player.w / 2, player.y + player.h / 2, '#44ddff', 15);
          screenFlash = 5;
          screenFlashColor = '#44ddff44';
        } else {
          player.hp -= e.dmg;
          player.iFrames = 40;
          shakeTimer = 10;
          spawnParticles(player.x + player.w / 2, player.y + player.h / 2, '#ff4444', 10);

          if (endless.powerups.thorns > 0 && !e.dead) {
            const thornsDmg = endless.powerups.thorns;
            e.hp -= thornsDmg;
            e.iFrames = 5;
            spawnParticles(e.x + e.w/2, e.y + e.h/3, '#ff8844', 8);
            if (e.hp <= 0) {
              e.dead = true;
              endless.totalKills++;
              spawnParticles(e.x + e.w/2, e.y + e.h/2, e.color, 15);

              if (endless.powerups.vampirism > 0 && player.alive) {
                player.hp = Math.min(player.hp + endless.powerups.vampirism, player.maxHp);
              }

              const _magnetBonus2 = endless.powerups.magnetism || 0;
              if (endless.powerups.luckyDrop > 0 && Math.random() < endless.powerups.luckyDrop * 0.12 + _magnetBonus2 * 0.05) {
                spawnParticles(e.x + e.w/2, e.y + e.h/2, '#44ff44', 5);
                if (player.alive) player.hp = Math.min(player.hp + 2 + _magnetBonus2, player.maxHp);
              }
            }
          }
          if (player.hp <= 0) {
            handlePlayerDeath();

            if (endless.round > endless.highScore) {
              endless.highScore = endless.round;
              localStorage.setItem('endlessHighScore', String(endless.highScore));
            }
          }
        }
      }
    }

    if (_pendingSummons.length > 0) endless.enemies.push(..._pendingSummons);

    }

    if (!mpEnabled || isHost) {
      for (let i = endless.enemies.length - 1; i >= 0; i--) {
        if (endless.enemies[i].dead) endless.enemies.splice(i, 1);
      }
    }

    if (state === 'endless') {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx;
        b.y += b.vy;
        if (b.life !== undefined) { b.life--; if (b.life <= 0) { bullets.splice(i, 1); continue; } }

        if (player.alive && player.iFrames <= 0 && rectsOverlap(player, b)) {

          if (endless.shieldCharges > 0) {
            endless.shieldCharges--;
            player.iFrames = 20;
            spawnParticles(player.x + player.w / 2, player.y + player.h / 2, '#44ddff', 10);
            bullets.splice(i, 1);
            continue;
          }
          const dmg = b.dmg || 1;
          player.hp -= dmg;
          player.iFrames = 30;
          shakeTimer = 8;
          spawnParticles(player.x + player.w / 2, player.y + player.h / 2, '#ff4444', 8);
          bullets.splice(i, 1);
          if (player.hp <= 0) {
            handlePlayerDeath();
            if (endless.round > endless.highScore) {
              endless.highScore = endless.round;
              localStorage.setItem('endlessHighScore', String(endless.highScore));
            }
          }
          continue;
        }

        if (b.x < endless.arenaX - 50 || b.x > endless.arenaX + endless.arenaW + 50 ||
            b.y < endless.arenaY - 50 || b.y > endless.arenaY + endless.arenaH + 50) {
          bullets.splice(i, 1);
        }
      }
    }

    const _anyAlive = !mpEnabled || player.alive || getAlivePlayerList().length > 0;
    if (state === 'endless' && endless.spawnsLeft <= 0 && endless.enemies.length === 0 && _anyAlive && (!mpEnabled || isHost)) {

      state = 'endlessShop';
      endless.intermission = true;
      endless.intermissionTimer = 0;
      endless.bossActive = false;
      endless.modifier = null;
      endless.shopPicked = false;
      endlessGenerateShop();

      if (mpEnabled && isHost) {
        db.ref('rooms/' + currentRoom + '/shopPicks').remove();
      }

      player.hp = Math.min(player.hp + Math.ceil(player.maxHp * 0.2), player.maxHp);
      player.iFrames = 60;
      bullets = [];

      screenFlash = 20;
      screenFlashColor = endlessIsBossRound(endless.round) ? '#ffd700' : '#44ff44';
    }

    if (state === 'endlessShop') {
      endless.intermissionTimer++;
    }
  }

  if (state === 'endless') {
    for (let i = projectiles.length - 1; i >= 0; i--) {
      const proj = projectiles[i];
      if (!proj) continue;
      let hit = false;
      for (let ei = endless.enemies.length - 1; ei >= 0; ei--) {
        const e = endless.enemies[ei];
        if (e.dead) continue;
        if (rectsOverlap(proj, e)) {
          const dmg = Math.ceil((proj.dmgMult || 1) * (cheats.oneHitKill ? 999 : 1));
          e.hp -= dmg;
          e.iFrames = 5;

          if (proj.stunning && proj.stunDuration > 0) {
            e._stunTimer = (e._stunTimer || 0) + proj.stunDuration;
          }

          if (proj.crit) {
            bossVfx.push({ type: 'text', x: e.x + e.w/2, y: e.y - 10, text: 'CRIT!', color: '#ff2222', size: 22, life: 40, maxLife: 40, vy: -1.5 });
          }
          spawnParticles(e.x + e.w / 2, e.y + e.h / 3, e.color, 8);
          shakeTimer = 4;

          if (proj.explosive && proj.explosionRadius > 0) {
            const exR = proj.explosionRadius;
            const exCx = e.x + e.w/2, exCy = e.y + e.h/2;
            spawnParticles(exCx, exCy, '#ff6622', 25);
            spawnParticles(exCx, exCy, '#ffaa44', 15);
            screenFlash = 5;
            screenFlashColor = '#ff662244';
            shakeTimer = 8;
            for (let aei = endless.enemies.length - 1; aei >= 0; aei--) {
              if (aei === ei) continue;
              const ae = endless.enemies[aei];
              if (ae.dead) continue;
              const adx = (ae.x + ae.w/2) - exCx;
              const ady = (ae.y + ae.h/2) - exCy;
              if (Math.sqrt(adx*adx + ady*ady) < exR) {
                const aoeDmg = Math.ceil(dmg * 0.5);
                ae.hp -= aoeDmg;
                ae.iFrames = 5;
                spawnParticles(ae.x + ae.w/2, ae.y + ae.h/3, ae.color, 6);
                if (ae.hp <= 0) {
                  ae.dead = true;
                  endless.totalKills++;
                  spawnParticles(ae.x + ae.w/2, ae.y + ae.h/2, ae.color, 15);
                  if (endless.powerups.vampirism > 0 && player.alive) {
                    player.hp = Math.min(player.hp + endless.powerups.vampirism, player.maxHp);
                  }

                  const _mb3 = endless.powerups.magnetism || 0;
                  if (endless.powerups.luckyDrop > 0 && Math.random() < endless.powerups.luckyDrop * 0.12 + _mb3 * 0.05) {
                    spawnParticles(ae.x + ae.w/2, ae.y + ae.h/2, '#44ff44', 5);
                    if (player.alive) player.hp = Math.min(player.hp + 2 + _mb3, player.maxHp);
                  }
                }
              }
            }
          }
          if (e.hp <= 0) {
            e.dead = true;
            endless.totalKills++;
            spawnParticles(e.x + e.w / 2, e.y + e.h / 2, e.color, 20);
            spawnParticles(e.x + e.w / 2, e.y + e.h / 2, '#ffdd44', 10);
            shakeTimer = 8;

            if (endless.powerups.vampirism > 0 && player.alive) {
              player.hp = Math.min(player.hp + endless.powerups.vampirism, player.maxHp);
            }

            const magnetBonus = endless.powerups.magnetism || 0;
            if (endless.powerups.luckyDrop > 0 && Math.random() < endless.powerups.luckyDrop * 0.12 + magnetBonus * 0.05) {
              const healAmt = 2 + magnetBonus;
              spawnParticles(e.x + e.w/2, e.y + e.h/2, '#44ff44', 5);
              if (player.alive) player.hp = Math.min(player.hp + healAmt, player.maxHp);
            }
          }
          hit = true;
          break;
        }
      }
      if (hit) { projectiles.splice(i, 1); }
    }
  }

  particles = particles.filter(pt => {
    pt.x += pt.vx;
    pt.y += pt.vy;
    pt.vy += 0.15;
    pt.life--;
    pt.size *= 0.97;
    return pt.life > 0;
  });

  if (particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);

  for (const k in keysJustPressed) delete keysJustPressed[k];
}

function draw() {
  const shake = shakeTimer > 0 ? (Math.random() - 0.5) * (shakeTimer > 20 ? 7 : 4) : 0;
  ctx.save();
  ctx.translate(shake, shake * 0.6);

  const inBossFight = state === 'bossfight' || state === 'bossdialogue' || state === 'epsteinfight' || state === 'phonecall' || state === 'fusioncutscene' || state === 'fusionfight' || state === 'splitfight' || state === 'hawkingRefusal' || state === 'hawkingDeath';
  const bossPhase = boss ? boss.phase : 1;

  if (state !== 'menu') {

  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  if (inBossFight || bossDeathTimer > 0) {

    const p3 = bossPhase === 3 ? 1 : bossPhase === 2 ? 0.6 : 0.3;
    skyGrad.addColorStop(0, '#080808');
    skyGrad.addColorStop(0.3, `rgba(15,20,12,${0.9+p3*0.1})`);
    skyGrad.addColorStop(0.5, '#0d1210');
    skyGrad.addColorStop(0.7, '#0a0f0c');
    skyGrad.addColorStop(1, '#050805');
  } else {
    skyGrad.addColorStop(0, '#1a0a2e');
    skyGrad.addColorStop(0.25, '#4a1942');
    skyGrad.addColorStop(0.45, '#c0392b');
    skyGrad.addColorStop(0.65, '#e67e22');
    skyGrad.addColorStop(0.85, '#f4d03f');
    skyGrad.addColorStop(1, '#d4a043');
  }
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  if (inBossFight && Math.random() < 0.005 * bossPhase) {

    ctx.fillStyle = `rgba(180,${bossPhase===3?50:120},0,${0.04 + Math.random()*0.06})`;
    ctx.fillRect(0, 0, W, H);
  }

  if (!inBossFight) {
    const _starTime = Date.now() / 1000;
    for (let i = 0; i < 50; i++) {
      const sx = ((i * 137 + 50) % W + (cameraX * 0.05) % W) % W;
      const sy = (i * 97 + 20) % (H * 0.3);
      const twinkle = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(_starTime * (1.2 + i * 0.3) + i * 2.7));
      const starSize = 1 + (i % 3) * 0.5;
      ctx.globalAlpha = twinkle * 0.5;
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(sx, sy, starSize, 0, Math.PI * 2); ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  const sunX = W * 0.7 + cameraX * 0.01;
  const sunY = GROUND_Y - 40;
  ctx.fillStyle = '#fff4cc66';
  ctx.beginPath();
  ctx.arc(sunX, sunY, 60, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#ffdd6688';
  ctx.beginPath();
  ctx.arc(sunX, sunY, 45, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#ffcc44aa';
  ctx.beginPath();
  ctx.arc(sunX, sunY, 30, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#5a3520';
  for (let i = 0; i < 12; i++) {
    const mx = i * 300 - (cameraX * 0.15) % 300;
    const mh = 80 + (i * 67) % 100;
    const mw = 180 + (i * 31) % 120;
    ctx.beginPath();
    ctx.moveTo(mx, GROUND_Y);
    ctx.lineTo(mx + mw / 2, GROUND_Y - mh);
    ctx.lineTo(mx + mw, GROUND_Y);
    ctx.fill();
  }

  ctx.fillStyle = '#7a4a3088';
  for (let i = 0; i < 8; i++) {
    const mx = i * 400 - (cameraX * 0.08) % 400 + 100;
    const mh = 50 + (i * 43) % 60;
    const mw = 250 + (i * 29) % 150;
    ctx.beginPath();
    ctx.moveTo(mx, GROUND_Y);
    ctx.lineTo(mx + mw / 2, GROUND_Y - mh);
    ctx.lineTo(mx + mw, GROUND_Y);
    ctx.fill();
  }

  ctx.save();

  const isEndlessState = (state === 'endless' || state === 'endlessShop');
  if (isEndlessState && endless.endlessZoom < 0.99) {
    const ez = endless.endlessZoom;
    ctx.scale(ez, ez);
    ctx.translate(-cameraX, -cameraY);
  } else {
    ctx.translate(-cameraX, -cameraY);
  }

  const groundGrad = ctx.createLinearGradient(0, GROUND_Y, 0, H);
  groundGrad.addColorStop(0, '#c9a96e');
  groundGrad.addColorStop(0.3, '#b8944d');
  groundGrad.addColorStop(1, '#8b6914');
  ctx.fillStyle = groundGrad;
  const groundRight = state === 'winCutscene' ? levelWidth + 2000 : levelWidth;
  ctx.fillRect(0, GROUND_Y, groundRight, H - GROUND_Y);

  ctx.fillStyle = '#d4b87a';
  ctx.fillRect(0, GROUND_Y, groundRight, 3);

  ctx.strokeStyle = '#a0854088';
  ctx.lineWidth = 1;
  for (let i = 0; i < levelWidth; i += 60) {
    ctx.beginPath();
    ctx.moveTo(i, GROUND_Y + 12);
    ctx.lineTo(i + 15, GROUND_Y + 18);
    ctx.lineTo(i + 8, GROUND_Y + 25);
    ctx.stroke();
  }

  for (const d of decorations) {
    if (d.type === 'cactus') {

      ctx.fillStyle = '#2d6b30';
      const ch = d.size * 2;

      ctx.fillRect(d.x, d.y - ch, 8, ch);

      ctx.fillRect(d.x - 10, d.y - ch * 0.7, 10, 6);
      ctx.fillRect(d.x - 10, d.y - ch * 0.7 - 14, 6, 14);

      ctx.fillRect(d.x + 8, d.y - ch * 0.5, 12, 6);
      ctx.fillRect(d.x + 14, d.y - ch * 0.5 - 18, 6, 18);

      ctx.fillStyle = '#3a8a3d';
      ctx.fillRect(d.x + 2, d.y - ch, 3, ch);
    } else if (d.type === 'tumbleweed') {
      ctx.fillStyle = '#8b7355';
      ctx.beginPath();
      ctx.arc(d.x, d.y - d.size / 2, d.size / 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#6b5335';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(d.x, d.y - d.size / 2, d.size / 3, 0, Math.PI * 2);
      ctx.stroke();
    } else if (d.type === 'rock') {
      ctx.fillStyle = '#9a8060';
      ctx.beginPath();
      ctx.moveTo(d.x, d.y);
      ctx.lineTo(d.x - d.size / 2, d.y);
      ctx.lineTo(d.x - d.size / 3, d.y - d.size / 2);
      ctx.lineTo(d.x + d.size / 3, d.y - d.size / 1.5);
      ctx.lineTo(d.x + d.size / 2, d.y);
      ctx.fill();
      ctx.fillStyle = '#b09a70';
      ctx.fillRect(d.x - 2, d.y - d.size / 2, 4, 3);
    } else {

      ctx.fillStyle = '#6b7a40';
      ctx.beginPath();
      ctx.arc(d.x, d.y - 4, d.size / 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#5a6930';
      ctx.beginPath();
      ctx.arc(d.x + 4, d.y - 6, d.size / 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  for (const wall of walls) {

    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(wall.x + 3, wall.y + 3, wall.w, wall.h);
    if (wall.isPlatform) {
      const platGrad = ctx.createLinearGradient(wall.x, wall.y, wall.x, wall.y + wall.h);
      platGrad.addColorStop(0, '#c0a060');
      platGrad.addColorStop(0.3, '#a08050');
      platGrad.addColorStop(1, '#806030');
      ctx.fillStyle = platGrad;
      ctx.fillRect(wall.x, wall.y, wall.w, wall.h);

      ctx.fillStyle = '#d4b87088';
      ctx.fillRect(wall.x, wall.y, wall.w, 2);

      ctx.fillStyle = '#60401044';
      ctx.fillRect(wall.x, wall.y + wall.h - 1, wall.w, 1);
    } else {

      const wallGrad = ctx.createLinearGradient(wall.x, wall.y, wall.x + wall.w, wall.y + wall.h);
      wallGrad.addColorStop(0, '#c09050');
      wallGrad.addColorStop(0.5, '#b08040');
      wallGrad.addColorStop(1, '#906830');
      ctx.fillStyle = wallGrad;
      ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
      ctx.strokeStyle = '#90603022';
      ctx.lineWidth = 1;
      for (let by = wall.y; by < wall.y + wall.h; by += 10) {
        ctx.beginPath();
        ctx.moveTo(wall.x, by);
        ctx.lineTo(wall.x + wall.w, by);
        ctx.stroke();
      }

      ctx.fillStyle = '#d4b87066';
      ctx.fillRect(wall.x, wall.y, wall.w, 3);
    }
  }

  if (bigWall) {
    const bw = bigWall;

    ctx.fillStyle = '#888';
    ctx.fillRect(bw.x, bw.y, bw.w, bw.h);

    ctx.fillStyle = '#999';
    for (let sx = bw.x; sx < bw.x + bw.w; sx += 6) {
      ctx.fillRect(sx, bw.y, 4, bw.h);
    }

    ctx.fillStyle = '#55555566';
    for (let sx = bw.x + 4; sx < bw.x + bw.w; sx += 6) {
      ctx.fillRect(sx, bw.y, 2, bw.h);
    }

    ctx.fillStyle = '#777';
    ctx.fillRect(bw.x - 3, bw.y + 20, bw.w + 6, 6);
    ctx.fillRect(bw.x - 3, bw.y + bw.h / 2, bw.w + 6, 6);
    ctx.fillRect(bw.x - 3, bw.y + bw.h - 30, bw.w + 6, 6);

    ctx.fillStyle = '#aaa';
    ctx.fillRect(bw.x - 8, bw.y - 10, bw.w + 16, 14);
    ctx.fillStyle = '#bbb';
    ctx.fillRect(bw.x - 8, bw.y - 10, bw.w + 16, 3);

    ctx.strokeStyle = '#888';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let bx = bw.x - 10; bx < bw.x + bw.w + 10; bx += 8) {
      ctx.moveTo(bx, bw.y - 16);
      ctx.lineTo(bx + 4, bw.y - 22);
      ctx.lineTo(bx + 8, bw.y - 16);
    }
    ctx.stroke();

    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    for (let bx = bw.x - 6; bx < bw.x + bw.w + 10; bx += 8) {
      ctx.beginPath();
      ctx.moveTo(bx, bw.y - 19);
      ctx.lineTo(bx - 3, bw.y - 25);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(bx, bw.y - 19);
      ctx.lineTo(bx + 3, bw.y - 25);
      ctx.stroke();
    }

    ctx.fillStyle = '#ffcc44';
    ctx.font = 'bold 11px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('▲ CLIMB ▲', bw.x + bw.w / 2, bw.y + bw.h / 2);

    ctx.fillStyle = '#ffcc4466';
    for (let ay = bw.y + 40; ay < bw.y + bw.h - 40; ay += 30) {
      ctx.beginPath();
      ctx.moveTo(bw.x + bw.w / 2, ay - 8);
      ctx.lineTo(bw.x + bw.w / 2 - 6, ay);
      ctx.lineTo(bw.x + bw.w / 2 + 6, ay);
      ctx.fill();
    }

    ctx.fillStyle = '#006847aa';
    ctx.font = 'bold 16px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('🇲🇽 MÉXICO', bw.x - 60, bw.y + 30);

    ctx.fillStyle = '#3c3b6eaa';
    ctx.font = 'bold 16px monospace';
    ctx.fillText('🇺🇸 USA', bw.x + bw.w + 60, bw.y + 30);

    ctx.fillStyle = '#44ff4488';
    ctx.font = 'bold 14px monospace';
    ctx.fillText('★ EL OTRO LADO ★', bw.x + bw.w + 60, bw.y + bw.h - 20);
  }

  const drawArena = (state === 'bossfight' || state === 'bossdialogue' || state === 'cutscene' || state === 'epsteinfight' || state === 'phonecall' || state === 'fusioncutscene' || state === 'fusionfight' || state === 'splitfight' || state === 'hawkingRefusal' || state === 'hawkingDeath' || bossDeathTimer > 0) && arenaPlats.length > 0;
  if (drawArena) {
    const sewFloor = arenaPlats.find(a => a.isFloor);
    const sewCeil = arenaPlats.find(a => a.isCeiling);
    const sewLeft = arenaPlats.find(a => a.isSideWall && a.x < (sewFloor ? sewFloor.x : 0));
    const sewRight = arenaPlats.find(a => a.isSideWall && a.x > (sewFloor ? sewFloor.x : 0));
    if (sewFloor && sewCeil) {
      const sx = sewCeil.x, sy = sewCeil.y, sw = sewCeil.w, sh = sewFloor.y - sewCeil.y;

      const bgGrad = ctx.createLinearGradient(sx, sy, sx, sy + sh);
      bgGrad.addColorStop(0, '#1a1e1a');
      bgGrad.addColorStop(0.3, '#141814');
      bgGrad.addColorStop(0.7, '#101410');
      bgGrad.addColorStop(1, '#0c100c');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(sx, sy, sw, sh);

      ctx.strokeStyle = '#1e241e';
      ctx.lineWidth = 1;
      const brickH = 28, brickW = 55;
      for (let row = 0; row < sh / brickH; row++) {
        const by = sy + row * brickH;
        const offset = (row % 2) * brickW / 2;
        for (let col = -1; col < sw / brickW + 1; col++) {
          const bx = sx + col * brickW + offset;
          ctx.strokeRect(bx, by, brickW, brickH);
        }
      }

      for (let i = 0; i < 12; i++) {
        const mx2 = sx + ((i*317+50) % sw);
        const my2 = sy + ((i*211+30) % sh);
        ctx.fillStyle = `rgba(40,${60+i*5},30,${0.15 + (i%3)*0.05})`;
        ctx.beginPath();
        ctx.ellipse(mx2, my2, 20+i*3, 12+i*2, 0, 0, Math.PI*2);
        ctx.fill();
      }

      for (let px = sx + 60; px < sx + sw - 60; px += 280) {

        ctx.fillStyle = '#3a4038';
        ctx.fillRect(px, sy + 25, 180, 14);
        ctx.fillStyle = '#4a5248';
        ctx.fillRect(px, sy + 25, 180, 4);

        ctx.fillStyle = '#555d52';
        ctx.fillRect(px - 3, sy + 22, 20, 20);
        ctx.fillRect(px + 163, sy + 22, 20, 20);

        if (px % 560 < 280) {
          ctx.fillStyle = '#3a4038';
          ctx.fillRect(px + 90, sy + 39, 10, 50);
        }
      }

      for (let cx = sx + 150; cx < sx + sw; cx += 400) {
        ctx.strokeStyle = '#44484488';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(cx, sy + 20);
        for (let cy = 0; cy < 80; cy += 12) {
          ctx.lineTo(cx + Math.sin(cy*0.3)*5, sy + 20 + cy);
        }
        ctx.stroke();
      }

      const waterY = sy + sh - 15;
      const waterGrad = ctx.createLinearGradient(sx, waterY, sx, sy + sh);
      waterGrad.addColorStop(0, 'rgba(20,60,30,0.4)');
      waterGrad.addColorStop(1, 'rgba(15,40,20,0.6)');
      ctx.fillStyle = waterGrad;
      ctx.fillRect(sx, waterY, sw, 15);

      const t = Date.now() / 1000;
      for (let wx = sx; wx < sx + sw; wx += 30) {
        const wy = waterY + Math.sin(wx*0.02 + t*2) * 2;
        ctx.fillStyle = `rgba(80,180,80,${0.08 + Math.sin(wx*0.05+t)*0.04})`;
        ctx.fillRect(wx, wy, 25, 3);
      }

      for (let d = 0; d < 5; d++) {
        const dx = sx + ((d*433+100) % sw);
        const dripY = sy + 40 + ((Date.now()/30 + d*97) % (sh - 60));
        ctx.fillStyle = 'rgba(100,200,120,0.5)';
        ctx.fillRect(dx, dripY, 2, 6);
      }

      for (let lx = sx + 100; lx < sx + sw; lx += 350) {
        const flicker = Math.sin(Date.now()/300 + lx) * 0.3 + 0.5;

        ctx.fillStyle = '#333';
        ctx.fillRect(lx - 8, sy + 50, 16, 10);

        ctx.fillStyle = `rgba(200,160,50,${flicker * 0.08})`;
        ctx.beginPath();
        ctx.moveTo(lx - 5, sy + 60);
        ctx.lineTo(lx - 80, sy + sh * 0.6);
        ctx.lineTo(lx + 80, sy + sh * 0.6);
        ctx.lineTo(lx + 5, sy + 60);
        ctx.fill();

        ctx.fillStyle = `rgba(255,200,80,${flicker * 0.5})`;
        ctx.beginPath();
        ctx.arc(lx, sy + 58, 4, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.fillStyle = '#ffcc0033';
      ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('⚠ RESTRICTED AREA ⚠', sx + sw/2, sy + sh/2 - 50);
      ctx.fillStyle = '#ff333322';
      ctx.font = 'bold 10px monospace';
      ctx.fillText('AUTHORIZED PERSONNEL ONLY', sx + sw/2, sy + sh/2 - 35);

      ctx.strokeStyle = '#2a302a';
      ctx.lineWidth = 2;
      for (let gx = sx + 200; gx < sx + sw - 200; gx += 400) {
        for (let gy2 = 0; gy2 < 30; gy2 += 6) {
          ctx.beginPath();
          ctx.moveTo(gx, sy + sh - 30 + gy2);
          ctx.lineTo(gx + 80, sy + sh - 30 + gy2);
          ctx.stroke();
        }
      }
    }
  }

  if (drawArena) for (const ap of arenaPlats) {
    if (ap.isPlatform) {

      const platGrad = ctx.createLinearGradient(ap.x, ap.y, ap.x, ap.y + ap.h);
      platGrad.addColorStop(0, '#5a6355');
      platGrad.addColorStop(1, '#3d4539');
      ctx.fillStyle = platGrad;
      ctx.fillRect(ap.x, ap.y, ap.w, ap.h);

      ctx.strokeStyle = '#4a5246';
      ctx.lineWidth = 1;
      for (let gx = ap.x; gx < ap.x + ap.w; gx += 8) {
        ctx.beginPath(); ctx.moveTo(gx, ap.y); ctx.lineTo(gx, ap.y + ap.h); ctx.stroke();
      }

      ctx.fillStyle = '#6a5540';
      ctx.fillRect(ap.x, ap.y, ap.w, 3);

      ctx.fillStyle = '#3a3a38';
      ctx.fillRect(ap.x + 8, ap.y + ap.h, 6, 35);
      ctx.fillRect(ap.x + ap.w - 14, ap.y + ap.h, 6, 35);
    } else if (ap.isSideWall) {

      const wallGrad = ctx.createLinearGradient(ap.x, ap.y, ap.x + ap.w, ap.y);
      wallGrad.addColorStop(0, '#2a2e28');
      wallGrad.addColorStop(0.5, '#353935');
      wallGrad.addColorStop(1, '#2a2e28');
      ctx.fillStyle = wallGrad;
      ctx.fillRect(ap.x, ap.y, ap.w, ap.h);

      ctx.strokeStyle = '#3a3e38';
      ctx.lineWidth = 1;
      for (let sy = ap.y; sy < ap.y + ap.h; sy += 35) {
        ctx.beginPath(); ctx.moveTo(ap.x, sy); ctx.lineTo(ap.x + ap.w, sy); ctx.stroke();
      }

      ctx.fillStyle = 'rgba(80,60,40,0.15)';
      for (let st = 0; st < 3; st++) {
        ctx.fillRect(ap.x + 5, ap.y + st*120 + 50, ap.w - 10, 40);
      }

      ctx.fillStyle = '#ffcc0022';
      ctx.fillRect(ap.x, ap.y, ap.w, 15);
      ctx.fillStyle = '#33333344';
      for (let s = ap.x; s < ap.x + ap.w; s += 12) {
        ctx.fillRect(s, ap.y, 6, 15);
      }
    } else if (ap.isCeiling) {

      ctx.fillStyle = '#252a25';
      ctx.fillRect(ap.x, ap.y, ap.w, ap.h);
      ctx.fillStyle = '#1e231e';
      ctx.fillRect(ap.x, ap.y + ap.h - 3, ap.w, 3);

      ctx.strokeStyle = '#1a1e1a';
      ctx.lineWidth = 1;
      for (let c = 0; c < 6; c++) {
        const cx = ap.x + (c * 313 + 100) % ap.w;
        ctx.beginPath();
        ctx.moveTo(cx, ap.y + ap.h);
        ctx.lineTo(cx + (c%2?20:-20), ap.y);
        ctx.stroke();
      }
    } else if (ap.isFloor) {

      const floorGrad = ctx.createLinearGradient(ap.x, ap.y, ap.x, ap.y + ap.h);
      floorGrad.addColorStop(0, '#3a3e38');
      floorGrad.addColorStop(1, '#2a2e28');
      ctx.fillStyle = floorGrad;
      ctx.fillRect(ap.x, ap.y, ap.w, ap.h);

      if (state === 'bossfight' || state === 'bossdialogue') {
        const edgePulse = Math.sin(Date.now() / 500) * 0.3 + 0.7;
        const edgeColor = boss && boss.phase === 3 ? `rgba(255,50,0,${edgePulse * 0.4})` : boss && boss.phase === 2 ? `rgba(200,120,0,${edgePulse * 0.25})` : `rgba(100,140,80,${edgePulse * 0.2})`;
        ctx.fillStyle = edgeColor;
        ctx.fillRect(ap.x, ap.y, ap.w, 2);
      } else {
        ctx.fillStyle = '#4a5048';
        ctx.fillRect(ap.x, ap.y, ap.w, 2);
      }

      ctx.strokeStyle = '#32363044';
      ctx.lineWidth = 1;
      for (let gx = ap.x; gx < ap.x + ap.w; gx += 50) {
        ctx.beginPath(); ctx.moveTo(gx, ap.y); ctx.lineTo(gx, ap.y + ap.h); ctx.stroke();
      }
    }
  }

  for (const m of bossMinions) {
    if (m.dead) continue;
    const mx = m.x, my = m.y;
    const bounce = Math.sin(m.frame * Math.PI / 2) * 2;
    ctx.save();
    const minionImg = m.isEpstein ? epsteinImg : guardImg;
    if (m.dir < 0) {
      ctx.translate(mx + m.w, my - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(minionImg, 0, 0, m.w, m.h);
    } else {
      ctx.drawImage(minionImg, mx, my - bounce, m.w, m.h);
    }
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.shadowColor = m.isEpstein ? '#8844ff' : '#ff5000';
    ctx.shadowBlur = 20;
    if (m.dir < 0) {
      ctx.translate(mx + m.w, my - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(minionImg, 0, 0, m.w, m.h);
    } else {
      ctx.drawImage(minionImg, mx, my - bounce, m.w, m.h);
    }
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.restore();

    const mHpPct = m.hp / m.maxHp;
    ctx.fillStyle = '#000000aa';
    ctx.fillRect(mx, my - 14, m.w, 5);
    ctx.fillStyle = mHpPct > 0.5 ? '#44cc44' : '#cc2222';
    ctx.fillRect(mx, my - 14, m.w * mHpPct, 5);

    ctx.fillStyle = m.isEpstein ? '#8844ff88' : '#ff444488';
    ctx.font = 'bold 9px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(m.isEpstein ? 'EPSTEIN' : 'MAGA', mx + m.w/2, my - 18);
  }

  for (const g of guards) {
    if (g.dead) continue;
    const gx = g.x;
    const gy = g.y;
    const bounce = Math.sin(g.frame * Math.PI / 2) * 2;

    if (!g.climbing) {
      ctx.fillStyle = '#00000055';
      ctx.beginPath();
      ctx.ellipse(gx + g.w / 2, GROUND_Y, g.w * 0.7, 5, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.save();
    if (g.dir < 0) {
      ctx.translate(gx + g.w, gy - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(guardImg, 0, 0, g.w, g.h);
    } else {
      ctx.drawImage(guardImg, gx, gy - bounce, g.w, g.h);
    }
    ctx.restore();

    if (g.alert) {
      ctx.save();
      ctx.globalAlpha = 0.2;
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 25;
      if (g.dir < 0) {
        ctx.translate(gx + g.w, gy - bounce);
        ctx.scale(-1, 1);
        ctx.drawImage(guardImg, 0, 0, g.w, g.h);
      } else {
        ctx.drawImage(guardImg, gx, gy - bounce, g.w, g.h);
      }
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    const hpBarW = g.w;
    const hpPct = g.hp / g.maxHp;
    ctx.fillStyle = '#000000aa';
    ctx.fillRect(gx, gy - 22 - bounce, hpBarW, 6);
    ctx.fillStyle = hpPct > 0.5 ? '#44cc44' : hpPct > 0.25 ? '#ccaa22' : '#cc2222';
    ctx.fillRect(gx, gy - 22 - bounce, hpBarW * hpPct, 6);

    if (g.alert) {
      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 18px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('!', gx + g.w / 2, gy - 28);
    }

    if (g.alert && !g.climbing) {
      ctx.fillStyle = '#ffff0011';
      ctx.beginPath();
      ctx.moveTo(gx + g.w / 2, gy + 10);
      if (g.dir > 0) {
        ctx.lineTo(gx + g.w + 80, gy - 20);
        ctx.lineTo(gx + g.w + 80, gy + 50);
      } else {
        ctx.lineTo(gx - 80, gy - 20);
        ctx.lineTo(gx - 80, gy + 50);
      }
      ctx.fill();
    }
  }

  if (state === 'endless' || state === 'endlessShop') {
    const eaX = endless.arenaX, eaW = endless.arenaW, eaH = endless.arenaH;
    const eaY = endless.arenaY;
    const eFloorY = eaY + eaH;

    const bgGrad2 = ctx.createLinearGradient(eaX, eaY, eaX, eFloorY);
    bgGrad2.addColorStop(0, '#1a1a2e');
    bgGrad2.addColorStop(0.5, '#16213e');
    bgGrad2.addColorStop(1, '#0f3460');
    ctx.fillStyle = bgGrad2;
    ctx.fillRect(eaX, eaY, eaW, eaH);

    ctx.strokeStyle = '#ffffff08';
    ctx.lineWidth = 1;
    for (let gx = eaX; gx < eaX + eaW; gx += 60) {
      ctx.beginPath(); ctx.moveTo(gx, eaY); ctx.lineTo(gx, eFloorY); ctx.stroke();
    }
    for (let gy = eaY; gy < eFloorY; gy += 60) {
      ctx.beginPath(); ctx.moveTo(eaX, gy); ctx.lineTo(eaX + eaW, gy); ctx.stroke();
    }

    ctx.fillStyle = '#ffffff06';
    ctx.font = `bold ${Math.min(300, eaW * 0.25)}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(String(endless.round), eaX + eaW / 2, eaY + eaH * 0.65);

    const floorGrad = ctx.createLinearGradient(eaX, eFloorY, eaX, eFloorY + 30);
    floorGrad.addColorStop(0, '#2a2a4a');
    floorGrad.addColorStop(1, '#1a1a2e');
    ctx.fillStyle = floorGrad;
    ctx.fillRect(eaX, eFloorY, eaW, 30);

    ctx.fillStyle = '#ffffff22';
    ctx.fillRect(eaX, eFloorY, eaW, 2);

    ctx.fillStyle = '#1a1a3a';
    ctx.fillRect(eaX - 30, eaY, 30, eaH + 30);
    ctx.fillRect(eaX + eaW, eaY, 30, eaH + 30);

    ctx.fillStyle = '#ffffff11';
    ctx.fillRect(eaX - 2, eaY, 2, eaH);
    ctx.fillRect(eaX + eaW, eaY, 2, eaH);

    for (const plat of endless.platforms) {
      if (plat.isFloor || plat.isSideWall) continue;
      const pGrad = ctx.createLinearGradient(plat.x, plat.y, plat.x, plat.y + plat.h);
      pGrad.addColorStop(0, '#3a3a6a');
      pGrad.addColorStop(1, '#2a2a4a');
      ctx.fillStyle = pGrad;
      ctx.fillRect(plat.x, plat.y, plat.w, plat.h);

      ctx.fillStyle = '#88aaff33';
      ctx.fillRect(plat.x, plat.y, plat.w, 2);
    }

    if (endless.roofY > 2) {
      const roofBottom = eaY + endless.roofY;
      const roofGrad = ctx.createLinearGradient(eaX, eaY, eaX, roofBottom);
      roofGrad.addColorStop(0, '#ff220088');
      roofGrad.addColorStop(0.6, '#ff440044');
      roofGrad.addColorStop(1, '#ff000000');
      ctx.fillStyle = roofGrad;
      ctx.fillRect(eaX, eaY, eaW, endless.roofY);

      ctx.fillStyle = '#ff2200aa';
      for (let sx = eaX; sx < eaX + eaW; sx += 30) {
        ctx.beginPath();
        ctx.moveTo(sx, roofBottom);
        ctx.lineTo(sx + 15, roofBottom + 12 + Math.sin(sx * 0.1 + Date.now() * 0.003) * 5);
        ctx.lineTo(sx + 30, roofBottom);
        ctx.fill();
      }

      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('⚠ STOP CAMPING! ⚠', eaX + eaW / 2, roofBottom + 40);
      ctx.textAlign = 'left';
    }

    for (const e of endless.enemies) {
      if (e.dead) continue;
      const ex = e.x, ey = e.y;
      const bounce = Math.sin(e.frame * Math.PI / 2) * 2;

      ctx.fillStyle = '#00000044';
      ctx.beginPath();
      ctx.ellipse(ex + e.w / 2, eFloorY, e.w * 0.6, 4, 0, 0, Math.PI * 2);
      ctx.fill();

      const eImg = images[e.imgKey];
      if (eImg) {
        ctx.save();

        if (e.iFrames > 0) {
          ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 30) * 0.3;
        }
        if (e.dir < 0) {
          ctx.translate(ex + e.w, ey - bounce);
          ctx.scale(-1, 1);
          ctx.drawImage(eImg, 0, 0, e.w, e.h);
        } else {
          ctx.drawImage(eImg, ex, ey - bounce, e.w, e.h);
        }
        ctx.globalAlpha = 1;
        ctx.restore();

        ctx.save();
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = e.color;
        ctx.fillRect(ex, ey - bounce, e.w, e.h);
        ctx.globalAlpha = 1;
        ctx.restore();
      } else {

        ctx.fillStyle = e.color;
        ctx.fillRect(ex, ey - bounce, e.w, e.h);
      }

      if (!e.isBoss) {
        const hpPct = e.hp / e.maxHp;
        ctx.fillStyle = '#000000aa';
        ctx.fillRect(ex, ey - 14 - bounce, e.w, 5);
        ctx.fillStyle = hpPct > 0.5 ? '#44cc44' : hpPct > 0.25 ? '#ccaa22' : '#cc2222';
        ctx.fillRect(ex, ey - 14 - bounce, e.w * hpPct, 5);
      }

      ctx.fillStyle = e.color + '88';
      ctx.font = e.isBoss ? 'bold 14px monospace' : 'bold 9px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(e.isBoss ? e.bossName : e.type.toUpperCase(), ex + e.w / 2, ey - 18 - bounce);

      if (e.isBoss) {
        ctx.save();
        ctx.globalAlpha = 0.12 + Math.sin(Date.now() / 300) * 0.06;
        ctx.shadowColor = e.color;
        ctx.shadowBlur = 30;
        ctx.fillStyle = e.color;
        ctx.fillRect(ex - 5, ey - 5, e.w + 10, e.h + 10);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
        ctx.restore();
      }
    }

    for (const b of bullets) {
      ctx.fillStyle = '#ff4444';
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 6;
      ctx.beginPath();
      ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    if (endless.modifier && endless.modifier.name === 'DARKNESS') {
      const pcx = player.x + player.w / 2;
      const pcy = player.y + player.h / 2;
      const grad = ctx.createRadialGradient(pcx, pcy, 120, pcx, pcy, 400);
      grad.addColorStop(0, 'rgba(0,0,0,0)');
      grad.addColorStop(0.5, 'rgba(0,0,0,0.5)');
      grad.addColorStop(1, 'rgba(0,0,0,0.92)');
      ctx.fillStyle = grad;
      ctx.fillRect(endless.arenaX - 30, endless.arenaY, endless.arenaW + 60, endless.arenaH + 30);
    }
  }

  if (boss && !boss.dead) {
    const bx = boss.x;
    const by = boss.y;
    const bounce = Math.sin(boss.frame * Math.PI / 2) * 3;
    const t = Date.now() / 1000;

    const auraRadius = boss.phase === 3 ? 220 : boss.phase === 2 ? 160 : 110;
    const auraIntensity = 0.05 + Math.sin(t * 3) * 0.03;
    const auraG = ctx.createRadialGradient(bx+boss.w/2, by+boss.h/2, 20, bx+boss.w/2, by+boss.h/2, auraRadius);
    if (boss.phase === 3) {
      auraG.addColorStop(0, `rgba(255,30,0,${auraIntensity * 3})`);
      auraG.addColorStop(0.5, `rgba(255,80,0,${auraIntensity * 2})`);
      auraG.addColorStop(1, 'rgba(255,0,0,0)');
    } else if (boss.phase === 2) {
      auraG.addColorStop(0, `rgba(255,140,0,${auraIntensity * 2.5})`);
      auraG.addColorStop(0.5, `rgba(255,100,0,${auraIntensity * 1.5})`);
      auraG.addColorStop(1, 'rgba(255,80,0,0)');
    } else {
      auraG.addColorStop(0, `rgba(255,100,0,${auraIntensity * 1.5})`);
      auraG.addColorStop(1, 'rgba(255,50,0,0)');
    }
    ctx.fillStyle = auraG;
    ctx.beginPath();
    ctx.arc(bx + boss.w/2, by + boss.h/2, auraRadius, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = boss.phase === 3 ? 'rgba(255,50,0,0.25)' : boss.phase === 2 ? 'rgba(255,140,0,0.2)' : 'rgba(255,200,0,0.12)';
    ctx.lineWidth = 2;
    const ringR = 80 + boss.phase * 15;
    ctx.beginPath();
    for (let a = 0; a < Math.PI * 2; a += 0.1) {
      const wobble = Math.sin(a * 3 + t * 4) * 8;
      const rx = bx + boss.w/2 + Math.cos(a + t * 2) * (ringR + wobble);
      const ry = by + boss.h/2 + Math.sin(a + t * 2) * (ringR * 0.4 + wobble * 0.3);
      if (a === 0) ctx.moveTo(rx, ry);
      else ctx.lineTo(rx, ry);
    }
    ctx.closePath();
    ctx.stroke();

    if (boss.charging) {
      const trailDir = boss.chargeVx > 0 ? -1 : 1;
      for (let i = 0; i < 5; i++) {
        const tx = bx + boss.w/2 + trailDir * (20 + i * 25);
        const ty = by + 10 + Math.random() * (boss.h - 20);
        ctx.fillStyle = `rgba(255, ${100 + i*30}, 0, ${0.5 - i*0.08})`;
        ctx.beginPath();
        ctx.arc(tx, ty, 6 + Math.random() * 8, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.strokeStyle = 'rgba(255,150,0,0.15)';
      ctx.lineWidth = 3;
      for (let sl = 0; sl < 12; sl++) {
        const sy = by - 100 + Math.random() * (boss.h + 200);
        const sx = bx + boss.w/2 + trailDir * (50 + Math.random() * 300);
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx + trailDir * (60 + Math.random() * 80), sy);
        ctx.stroke();
      }
    }

    if (boss.slamming && boss.vy < 0) {
      const warnX = bx + boss.w/2;
      const arenaFloorY = bigWall.y + 40 + 800;

      const warnPulse = Math.sin(t * 15) * 0.3 + 0.5;
      ctx.fillStyle = `rgba(255, 0, 0, ${warnPulse * 0.3})`;
      ctx.beginPath();
      ctx.ellipse(warnX, arenaFloorY, 250, 15, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = `rgba(255, 0, 0, ${warnPulse * 0.8})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(warnX, arenaFloorY, 200, 10, 0, 0, Math.PI * 2);
      ctx.stroke();

      ctx.fillStyle = `rgba(255, 0, 0, ${warnPulse})`;
      ctx.font = 'bold 24px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('⚠ INCOMING SLAM ⚠', warnX, arenaFloorY - 25);
    }

    if (boss.slamming && boss.vy > 2) {
      for (let ai = 1; ai <= 4; ai++) {
        ctx.globalAlpha = 0.15 / ai;
        ctx.drawImage(bossImg, bx, by - bounce - ai * 30, boss.w, boss.h);
      }
      ctx.globalAlpha = 1;
    }

    const airDist = boss.slamming ? Math.max(30, Math.abs(boss.vy) * 3) : 0;
    ctx.fillStyle = `rgba(0,0,0,${boss.slamming ? 0.2 : 0.4})`;
    ctx.beginPath();
    ctx.ellipse(bx + boss.w/2, by + boss.h + 5 + airDist, boss.w * 0.8 + airDist * 0.3, 8 + airDist * 0.1, 0, 0, Math.PI * 2);
    ctx.fill();

    const introScale = bossIntroTimer > 0 ? 1 + (bossIntroTimer / 120) * 0.5 : 1;
    const introAlpha = bossIntroTimer > 80 ? (120 - bossIntroTimer) / 40 : 1;

    ctx.save();
    ctx.globalAlpha = introAlpha;
    if (introScale !== 1) {
      ctx.translate(bx + boss.w/2, by + boss.h/2);
      ctx.scale(introScale, introScale);
      ctx.translate(-(bx + boss.w/2), -(by + boss.h/2));
    }
    if (boss.dir < 0) {
      ctx.translate(bx + boss.w, by - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(bossImg, 0, 0, boss.w, boss.h);
    } else {
      ctx.drawImage(bossImg, bx, by - bounce, boss.w, boss.h);
    }
    ctx.restore();

    const tintPulse = 0.15 + Math.sin(t * 4) * 0.1;
    ctx.save();
    ctx.globalAlpha = tintPulse;
    ctx.shadowColor = boss.phase === 3 ? '#ff0000' : '#ff8800';
    ctx.shadowBlur = 20 + boss.phase * 10;
    if (boss.dir < 0) {
      ctx.translate(bx + boss.w, by - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(bossImg, 0, 0, boss.w, boss.h);
    } else {
      ctx.drawImage(bossImg, bx, by - bounce, boss.w, boss.h);
    }
    ctx.shadowBlur = 0;
    ctx.restore();

    if (boss.phase >= 2) {
      const eyeY = by + boss.h * 0.2 - bounce;
      const eyeGlow = Math.sin(t * 6) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(255, ${boss.phase === 3 ? 0 : 100}, 0, ${eyeGlow})`;
      ctx.shadowColor = boss.phase === 3 ? '#ff0000' : '#ff8800';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(bx + boss.w * 0.35, eyeY, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(bx + boss.w * 0.65, eyeY, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    const phaseLabels = { 1: '★ TRUMP ★', 2: '★★ ENRAGED ★★', 3: '★★★ FINAL FORM ★★★' };
    ctx.shadowColor = boss.phase === 3 ? '#ff0000' : boss.phase === 2 ? '#ff6600' : '#ff4444';
    ctx.shadowBlur = boss.phase * 8;
    ctx.fillStyle = boss.phase === 3 ? '#ff0000' : boss.phase === 2 ? '#ff6600' : '#ff2222';
    ctx.font = `bold ${boss.phase === 3 ? 22 : boss.phase === 2 ? 20 : 18}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(phaseLabels[boss.phase], bx + boss.w / 2, by - 48);
    ctx.shadowBlur = 0;

    const bossHpW = 140;
    const bossHpPct = boss.hp / boss.maxHp;
    ctx.fillStyle = '#000000dd';
    ctx.fillRect(bx + boss.w / 2 - bossHpW / 2 - 1, by - 33, bossHpW + 2, 14);

    const hpGrad = ctx.createLinearGradient(bx + boss.w/2 - bossHpW/2, 0, bx + boss.w/2 + bossHpW/2, 0);
    if (bossHpPct > 0.6) { hpGrad.addColorStop(0, '#cc2222'); hpGrad.addColorStop(1, '#ff4444'); }
    else if (bossHpPct > 0.25) { hpGrad.addColorStop(0, '#cc4400'); hpGrad.addColorStop(1, '#ff8800'); }
    else { hpGrad.addColorStop(0, '#cc0000'); hpGrad.addColorStop(1, '#ff0000'); }
    ctx.fillStyle = hpGrad;
    ctx.fillRect(bx + boss.w/2 - bossHpW/2, by - 32, bossHpW * bossHpPct, 12);
    ctx.strokeStyle = '#ff666688';
    ctx.lineWidth = 1;
    ctx.strokeRect(bx + boss.w/2 - bossHpW/2, by - 33, bossHpW, 14);

    ctx.fillStyle = '#ffffff88';
    ctx.fillRect(bx + boss.w/2 - bossHpW/2 + bossHpW * 0.6, by - 33, 2, 14);
    ctx.fillRect(bx + boss.w/2 - bossHpW/2 + bossHpW * 0.25, by - 33, 2, 14);

    const shimmer = Math.sin(Date.now()/150) * 0.15 + 0.15;
    ctx.fillStyle = `rgba(255,255,255,${shimmer})`;
    ctx.fillRect(bx + boss.w/2 - bossHpW/2, by - 33, bossHpW * bossHpPct * 0.6, 4);
  }

  if (boss && boss.dead && bossDeathTimer > 0) {
    const deathAlpha = bossDeathTimer > 30 ? 0.5 : bossDeathTimer / 60;
    ctx.globalAlpha = deathAlpha;
    ctx.save();
    const scaleUp = 1 + (180 - bossDeathTimer) * 0.003;
    ctx.translate(boss.x + boss.w/2, boss.y + boss.h/2);
    ctx.scale(scaleUp, scaleUp);
    ctx.translate(-(boss.x + boss.w/2), -(boss.y + boss.h/2));
    ctx.drawImage(bossImg, boss.x, boss.y, boss.w, boss.h);
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  for (const t of player.trail) {
    const alpha = t.life / 10;
    ctx.fillStyle = `rgba(100, 200, 255, ${alpha * 0.3})`;
    ctx.fillRect(t.x - 3, t.y - 3, 6, 6);
  }

  if (player.alive) {
    const p = player;
    const px = p.x;
    const py = p.y;
    const runBounce = p.onGround ? Math.sin(p.runFrame * Math.PI / 2) * 2 : 0;

    ctx.fillStyle = '#00000055';
    ctx.beginPath();
    ctx.ellipse(px + p.w / 2, GROUND_Y, p.w * 0.7, 5, 0, 0, Math.PI * 2);
    ctx.fill();

    const pDrawW = p.w * PLAYER_IMG_SCALE;
    const pDrawH = p.h * PLAYER_IMG_SCALE;
    const pOffX = (p.w - pDrawW) / 2;
    const pOffY = p.h - pDrawH;
    ctx.save();
    if (p.facing < 0) {
      ctx.translate(px + p.w, py - runBounce);
      ctx.scale(-1, 1);
      ctx.drawImage(playerImg, -pOffX, pOffY, pDrawW, pDrawH);
    } else {
      ctx.drawImage(playerImg, px + pOffX, py + pOffY - runBounce, pDrawW, pDrawH);
    }
    ctx.restore();

    if (p.climbingBigWall) {
      ctx.fillStyle = '#ffcc44cc';
      ctx.font = 'bold 11px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('CLIMBING!', px + p.w / 2, py - 14);
    }

    if (p.onWall && !p.onGround && !p.climbingBigWall) {
      ctx.fillStyle = '#ccc';
      ctx.font = '9px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('wall slide', px + p.w / 2, py - 10);
    }

    if (p.iFrames > 0 && Math.floor(p.iFrames / 4) % 2 === 0) {
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 30;
      const drawW = p.w * PLAYER_IMG_SCALE;
      const drawH = p.h * PLAYER_IMG_SCALE;
      const pOffX = (p.w - drawW) / 2;
      const pOffY = p.h - drawH;
      ctx.drawImage(playerImg, px + pOffX, py - runBounce + pOffY, drawW, drawH);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    if ((state === 'endless') && endless.powerups.freezeAura > 0) {
      const freezeR = 120 + endless.powerups.freezeAura * 60;
      const fcx = px + p.w/2, fcy = py + p.h/2;
      ctx.save();
      const fGrad = ctx.createRadialGradient(fcx, fcy, freezeR * 0.1, fcx, fcy, freezeR);
      const fPulse = 0.12 + Math.sin(gameTimer * 0.05) * 0.05;
      fGrad.addColorStop(0, `rgba(136,204,255,${fPulse * 0.6})`);
      fGrad.addColorStop(0.5, `rgba(136,204,255,${fPulse * 0.3})`);
      fGrad.addColorStop(1, 'rgba(136,204,255,0)');
      ctx.fillStyle = fGrad;
      ctx.beginPath();
      ctx.arc(fcx, fcy, freezeR, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = `rgba(136,220,255,${fPulse * 0.5})`;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }

    if ((state === 'endless' || state === 'endlessShop') && endless.shieldCharges > 0) {
      const scx = px + p.w/2, scy = py + p.h/2;
      const sR = p.w * 0.8;
      const sPulse = 0.3 + Math.sin(gameTimer * 0.08) * 0.12;
      ctx.save();
      const sGrad = ctx.createRadialGradient(scx, scy, sR * 0.7, scx, scy, sR);
      sGrad.addColorStop(0, 'rgba(68,221,255,0)');
      sGrad.addColorStop(0.6, `rgba(68,221,255,${sPulse * 0.15})`);
      sGrad.addColorStop(1, `rgba(68,221,255,${sPulse * 0.4})`);
      ctx.fillStyle = sGrad;
      ctx.beginPath();
      ctx.arc(scx, scy, sR, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = `rgba(100,240,255,${sPulse * 0.6})`;
      ctx.lineWidth = 2;
      ctx.stroke();

      for (let ci = 0; ci < endless.shieldCharges; ci++) {
        const cAngle = (ci / endless.powerups.shield) * Math.PI * 2 - Math.PI / 2 + gameTimer * 0.02;
        ctx.fillStyle = `rgba(150,240,255,${sPulse})`;
        ctx.beginPath();
        ctx.arc(scx + Math.cos(cAngle) * sR, scy + Math.sin(cAngle) * sR, 4, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }
  }

  lerpRemotePlayers();
  drawOtherPlayers();

  for (const proj of projectiles) {
    ctx.save();
    ctx.translate(proj.x, proj.y);
    const angle = Math.atan2(proj.vy, proj.vx);
    ctx.rotate(angle);
    ctx.drawImage(projectileImg, -proj.w / 2, -proj.h / 2, proj.w, proj.h);
    ctx.restore();
  }

  for (const b of bullets) {

    const speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
    const nx = -b.vx/speed, ny = -b.vy/speed;
    for (let i = 1; i <= 4; i++) {
      ctx.fillStyle = `rgba(255, ${150 + i*25}, 0, ${0.3 - i*0.06})`;
      ctx.beginPath();
      ctx.arc(b.x + nx*i*6, b.y + ny*i*6, 4 - i*0.5, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.fillStyle = '#ff660033';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 12, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#ffaa0066';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 7, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#ffdd44';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
    ctx.fill();
  }

  if (epstein && !epstein.dead) {
    const ex = epstein.x, ey = epstein.y;
    const bounce = Math.sin(epstein.frame * Math.PI / 2) * 3;
    const t = Date.now() / 1000;

    const auraSize = 40 + Math.sin(t*3) * 10;
    const auraGrad = ctx.createRadialGradient(ex+epstein.w/2, ey+epstein.h/2, 10, ex+epstein.w/2, ey+epstein.h/2, epstein.w/2 + auraSize);
    auraGrad.addColorStop(0, 'rgba(136,68,255,0.3)');
    auraGrad.addColorStop(0.7, 'rgba(136,68,255,0.1)');
    auraGrad.addColorStop(1, 'rgba(136,68,255,0)');
    ctx.fillStyle = auraGrad;
    ctx.fillRect(ex - auraSize, ey - auraSize, epstein.w + auraSize*2, epstein.h + auraSize*2);

    for (let ai = 1; ai <= 3; ai++) {
      ctx.globalAlpha = 0.12 / ai;
      ctx.drawImage(epsteinImg, ex - epstein.dir * ai * 12, ey - bounce, epstein.w, epstein.h);
    }
    ctx.globalAlpha = 1;

    ctx.save();
    if (epstein.dir < 0) {
      ctx.translate(ex + epstein.w, ey - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(epsteinImg, 0, 0, epstein.w, epstein.h);
    } else {
      ctx.drawImage(epsteinImg, ex, ey - bounce, epstein.w, epstein.h);
    }
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = 0.2;
    ctx.shadowColor = '#8844ff';
    ctx.shadowBlur = 25;
    if (epstein.dir < 0) {
      ctx.translate(ex + epstein.w, ey - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(epsteinImg, 0, 0, epstein.w, epstein.h);
    } else {
      ctx.drawImage(epsteinImg, ex, ey - bounce, epstein.w, epstein.h);
    }
    ctx.shadowBlur = 0;
    ctx.restore();

    const epPhaseLabels = { 1: '★ EPSTEIN ★', 2: '★★ UNHINGED ★★' };
    ctx.fillStyle = '#ff44ff88';
    ctx.font = 'bold 11px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(epPhaseLabels[epstein.phase] || '', ex + epstein.w/2, ey - 45 - bounce);

    const eHpPct = epstein.hp / epstein.maxHp;
    ctx.fillStyle = '#000000bb';
    ctx.fillRect(ex - 10, ey - 35 - bounce, epstein.w + 20, 10);
    const eBarGrad = ctx.createLinearGradient(ex - 10, 0, ex + epstein.w + 10, 0);
    eBarGrad.addColorStop(0, '#8844ff');
    eBarGrad.addColorStop(1, '#ff44ff');
    ctx.fillStyle = eBarGrad;
    ctx.fillRect(ex - 10, ey - 35 - bounce, (epstein.w + 20) * eHpPct, 10);

    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.ellipse(ex + epstein.w/2, ey + epstein.h + 5, epstein.w/2, 8, 0, 0, Math.PI*2);
    ctx.fill();
  }

  for (const ep of epsteinProjectiles) {
    ctx.save();
    ctx.translate(ep.x, ep.y);
    ctx.rotate(ep.rotation);

    const projImg = epProjectileImgs[ep.imgIdx] || epsteinFilesImg;
    try {
      ctx.drawImage(projImg, -ep.size/2, -ep.size/2, ep.size, ep.size);
    } catch(e) {
      ctx.fillStyle = '#cc88ff';
      ctx.fillRect(-ep.size/2, -ep.size/2, ep.size, ep.size);
      ctx.fillStyle = '#fff';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('FILE', 0, 4);
    }

    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
    ctx.lineWidth = 2;
    ctx.strokeRect(-ep.size/2, -ep.size/2, ep.size, ep.size);
    ctx.restore();

    if (ep.life > 150) {
      const labels = ['CLASSIFIED', 'HAWKING??', 'SLICK WILLY', 'MUSK', '...'];
      ctx.fillStyle = `rgba(255,255,255,${(ep.life-150)/30})`;
      ctx.font = 'bold 10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(labels[ep.imgIdx] || '', ep.x, ep.y - ep.size/2 - 8);
    }
  }

  if (fusionBoss && !fusionBoss.dead) {
    const fx = fusionBoss.x, fy = fusionBoss.y;
    const fb = fusionBoss;
    const bounce = Math.sin(fb.frame * Math.PI / 2) * 4;
    const t = Date.now() / 1000;

    const auraSize = 60 + Math.sin(t*3) * 15;
    const auraGrad = ctx.createRadialGradient(fx+fb.w/2, fy+fb.h/2, 15, fx+fb.w/2, fy+fb.h/2, fb.w/2 + auraSize);
    auraGrad.addColorStop(0, `rgba(255,100,50,${0.25 + Math.sin(t*4)*0.1})`);
    auraGrad.addColorStop(0.5, `rgba(180,50,200,${0.15 + Math.sin(t*3)*0.05})`);
    auraGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = auraGrad;
    ctx.beginPath();
    ctx.arc(fx + fb.w/2, fy + fb.h/2, fb.w/2 + auraSize, 0, Math.PI * 2);
    ctx.fill();

    if (fb.mergeGlow > 0) {
      ctx.fillStyle = `rgba(255,255,200,${fb.mergeGlow * 0.3})`;
      ctx.beginPath();
      ctx.arc(fx + fb.w/2, fy + fb.h/2, fb.w + fb.mergeGlow * 100, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.save();
    ctx.translate(fx + fb.w/2, fy + fb.h/2);
    ctx.rotate(t * 1.5);
    ctx.strokeStyle = 'rgba(255,68,0,0.25)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.ellipse(0, 0, fb.w * 0.8, fb.h * 0.3, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.rotate(Math.PI / 2);
    ctx.strokeStyle = 'rgba(136,68,255,0.25)';
    ctx.beginPath();
    ctx.ellipse(0, 0, fb.w * 0.7, fb.h * 0.3, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

    ctx.save();

    ctx.save();
    ctx.beginPath();
    ctx.rect(fx, fy - bounce, fb.w/2, fb.h);
    ctx.clip();
    ctx.drawImage(bossImg, fx, fy - bounce, fb.w, fb.h);
    ctx.restore();

    ctx.save();
    ctx.beginPath();
    ctx.rect(fx + fb.w/2, fy - bounce, fb.w/2, fb.h);
    ctx.clip();
    ctx.drawImage(epsteinImg, fx, fy - bounce, fb.w, fb.h);
    ctx.restore();
    ctx.restore();

    ctx.strokeStyle = `rgba(255,255,200,${0.4 + Math.sin(t*8)*0.3})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    const cx = fx + fb.w/2;
    for (let ly = fy - bounce; ly < fy + fb.h - bounce; ly += 8) {
      ctx.lineTo(cx + (Math.random()-0.5) * 8, ly);
    }
    ctx.stroke();

    ctx.save();
    ctx.globalAlpha = 0.15;
    ctx.shadowColor = '#ff4400';
    ctx.shadowBlur = 25;

    ctx.save();
    ctx.beginPath();
    ctx.rect(fx, fy - bounce, fb.w/2, fb.h);
    ctx.clip();
    ctx.drawImage(bossImg, fx, fy - bounce, fb.w, fb.h);
    ctx.restore();

    ctx.shadowColor = '#8844ff';
    ctx.save();
    ctx.beginPath();
    ctx.rect(fx + fb.w/2, fy - bounce, fb.w/2, fb.h);
    ctx.clip();
    ctx.drawImage(epsteinImg, fx, fy - bounce, fb.w, fb.h);
    ctx.restore();
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.restore();

    ctx.fillStyle = '#ff884488';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#ff4400';
    ctx.shadowBlur = 10;
    ctx.fillText(fb.phase === 2 ? '★★ TRUMPSTEIN - UNLEASHED ★★' : '★ TRUMPSTEIN ★', fx + fb.w/2, fy - 50 - bounce);
    ctx.shadowBlur = 0;

    const fHpPct = fb.hp / fb.maxHp;
    ctx.fillStyle = '#000000bb';
    ctx.fillRect(fx - 15, fy - 40 - bounce, fb.w + 30, 12);
    const fBarGrad = ctx.createLinearGradient(fx - 15, 0, fx + fb.w + 15, 0);
    fBarGrad.addColorStop(0, '#ff4400');
    fBarGrad.addColorStop(0.5, '#ff8844');
    fBarGrad.addColorStop(1, '#8844ff');
    ctx.fillStyle = fBarGrad;
    ctx.fillRect(fx - 15, fy - 40 - bounce, (fb.w + 30) * fHpPct, 12);

    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(fx + fb.w/2, fy + fb.h + 5, fb.w/2 + 10, 10, 0, 0, Math.PI*2);
    ctx.fill();
  }

  for (const mb of miniBosses) {
    if (mb.dead) continue;
    const mx = mb.x, my = mb.y;
    const bounce = Math.sin(mb.frame * Math.PI / 2) * 2;
    const t = Date.now() / 1000;

    const auraRadius = (mb.name === 'HAWKING' && hawkingPhase2) ? mb.w/2 + 80 : mb.w/2 + 25;
    const mAuraGrad = ctx.createRadialGradient(mx+mb.w/2, my+mb.h/2, 5, mx+mb.w/2, my+mb.h/2, auraRadius);
    mAuraGrad.addColorStop(0, mb.color + ((mb.name === 'HAWKING' && hawkingPhase2) ? '88' : '44'));
    mAuraGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = mAuraGrad;
    ctx.beginPath();
    ctx.arc(mx + mb.w/2, my + mb.h/2, auraRadius, 0, Math.PI * 2);
    ctx.fill();

    if (mb.name === 'HAWKING' && hawkingPhase2) {

      for (let ring = 0; ring < 3; ring++) {
        ctx.save();
        ctx.translate(mx + mb.w/2, my + mb.h/2);
        ctx.rotate(t * (0.5 + ring * 0.3) + ring * Math.PI/3);
        ctx.strokeStyle = `rgba(255,215,0,${0.2 + Math.sin(t*2 + ring)*0.1})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, 0, mb.w/2 + 30 + ring*15, mb.h/4 + ring*8, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      for (let op = 0; op < 6; op++) {
        const orbitAngle = t * 2 + op * Math.PI / 3;
        const orbitR = mb.w/2 + 40;
        const opx = mx + mb.w/2 + Math.cos(orbitAngle) * orbitR;
        const opy = my + mb.h/2 + Math.sin(orbitAngle) * orbitR * 0.5;
        ctx.fillStyle = '#ffd700';
        ctx.globalAlpha = 0.5 + Math.sin(t*3 + op)*0.3;
        ctx.beginPath();
        ctx.arc(opx, opy, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      ctx.fillStyle = `rgba(255,215,0,${0.6 + Math.sin(t*3)*0.3})`;
      ctx.font = 'bold 11px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('TRANSCENDED', mx + mb.w/2, my - 35 - bounce);
    }

    if (mb.name === 'HAWKING') {
      const shieldOthers = miniBosses.filter(m => !m.dead && m.name !== 'HAWKING').length;
      if (shieldOthers > 0) {

        ctx.save();
        ctx.translate(mx + mb.w/2, my + mb.h/2);
        ctx.rotate(t * 0.8);
        ctx.strokeStyle = `rgba(255,215,0,${0.3 + Math.sin(t*3)*0.15})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let s = 0; s < 6; s++) {
          const angle = (Math.PI * 2 / 6) * s;
          const sr = mb.w/2 + 20 + Math.sin(t*2 + s)*5;
          const sx = Math.cos(angle) * sr;
          const sy = Math.sin(angle) * sr;
          if (s === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.restore();

        ctx.fillStyle = hawkingPhase2 ? `rgba(255,200,0,${0.4 + Math.sin(t*4)*0.2})` : `rgba(68,255,136,${0.4 + Math.sin(t*4)*0.2})`;
        ctx.font = 'bold 7px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('SHIELDED', mx + mb.w/2, my - 28 - bounce);
      }
    }

    const mbImgMap = { boss: bossImg, epstein: epsteinImg, musk: muskImg, clinton: clintonImg, hawking: (mb.name === 'HAWKING' && hawkingPhase2) ? hawkingGoldImg : hawkingImg };
    const mbImg = mbImgMap[mb.imgKey] || guardImg;
    ctx.save();
    if (mb.dir < 0) {
      ctx.translate(mx + mb.w, my - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(mbImg, 0, 0, mb.w, mb.h);
    } else {
      ctx.drawImage(mbImg, mx, my - bounce, mb.w, mb.h);
    }
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = 0.15 + Math.sin(t*4) * 0.05;
    ctx.shadowColor = mb.color;
    ctx.shadowBlur = 25;
    if (mb.dir < 0) {
      ctx.translate(mx + mb.w, my - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(mbImg, 0, 0, mb.w, mb.h);
    } else {
      ctx.drawImage(mbImg, mx, my - bounce, mb.w, mb.h);
    }
    ctx.restore();

    ctx.fillStyle = mb.color;
    ctx.font = 'bold 9px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(mb.name, mx + mb.w/2, my - 18 - bounce);

    const mbHpPct = mb.hp / mb.maxHp;
    ctx.fillStyle = '#00000088';
    ctx.fillRect(mx - 5, my - 12 - bounce, mb.w + 10, 7);
    ctx.fillStyle = mb.color;
    ctx.fillRect(mx - 5, my - 12 - bounce, (mb.w + 10) * mbHpPct, 7);
    ctx.strokeStyle = '#ffffff33';
    ctx.lineWidth = 1;
    ctx.strokeRect(mx - 5, my - 12 - bounce, mb.w + 10, 7);

    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath();
    ctx.ellipse(mx + mb.w/2, my + mb.h + 3, mb.w/3, 5, 0, 0, Math.PI*2);
    ctx.fill();
  }

  for (const vfx of bossVfx) {
    const alpha = vfx.life / vfx.maxLife;
    if (vfx.type === 'ring') {
      ctx.strokeStyle = vfx.color;
      ctx.globalAlpha = alpha;
      ctx.lineWidth = 3 + alpha * 4;
      ctx.beginPath();
      ctx.arc(vfx.x, vfx.y, vfx.radius, 0, Math.PI * 2);
      ctx.stroke();

      ctx.globalAlpha = alpha * 0.3;
      ctx.lineWidth = 10 + alpha * 8;
      ctx.beginPath();
      ctx.arc(vfx.x, vfx.y, vfx.radius * 0.95, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    } else if (vfx.type === 'crack') {
      ctx.strokeStyle = `rgba(100,50,0,${alpha})`;
      ctx.lineWidth = 2;
      const cx = vfx.x, cy = vfx.y;
      for (let c = 0; c < 8; c++) {
        const angle = c * Math.PI / 4 + 0.2;
        const len = 40 + c * 15;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        let px = cx, py = cy;
        for (let seg = 0; seg < 4; seg++) {
          px += Math.cos(angle + (Math.random()-0.5)*0.6) * len/4;
          py += Math.sin(angle + (Math.random()-0.5)*0.3) * len/8;
          ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
    } else if (vfx.type === 'text') {
      ctx.globalAlpha = alpha;
      ctx.fillStyle = vfx.color;
      ctx.shadowColor = vfx.color;
      ctx.shadowBlur = 20;
      const vfxSize = vfx.size || 32;
      ctx.font = `bold ${vfxSize + (1-alpha)*20}px monospace`;
      ctx.textAlign = 'center';
      ctx.fillText(vfx.text, vfx.x, vfx.y - (1-alpha)*60);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }
  }

  for (const pt of particles) {
    const pAlpha = pt.life / 40;
    ctx.globalAlpha = pAlpha;
    ctx.fillStyle = pt.color;
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, pt.size / 2, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  ctx.restore();

  const vg = ctx.createRadialGradient(W/2, H/2, H * 0.35, W/2, H/2, H * 0.95);
  vg.addColorStop(0, 'rgba(0,0,0,0)');
  vg.addColorStop(1, 'rgba(0,0,0,0.45)');
  ctx.fillStyle = vg;
  ctx.fillRect(0, 0, W, H);

  if (player && player.alive && player.hp / player.maxHp < 0.35) {
    const hpPulse = 0.12 + Math.sin(Date.now() / 300) * 0.06;
    const rvg = ctx.createRadialGradient(W/2, H/2, H * 0.25, W/2, H/2, H * 0.85);
    rvg.addColorStop(0, 'rgba(255,0,0,0)');
    rvg.addColorStop(1, `rgba(255,0,0,${hpPulse})`);
    ctx.fillStyle = rvg;
    ctx.fillRect(0, 0, W, H);
  }

  if (screenFlash > 0) {
    const flashAlpha = Math.min(0.8, screenFlash / 20);
    ctx.globalAlpha = flashAlpha;
    ctx.fillStyle = screenFlashColor;
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
  }

  if (state === 'hawkingRefusal') {
    const t = hawkingRefusalTimer;
    const cx = W / 2;
    const textY = H * 0.28;
    const heartY = H * 0.52;
    ctx.imageSmoothingEnabled = false;

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);

    function drawPixelHeart(hx, hy, scale, color, alpha) {
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      const px = [
        [0,1,1,0,0,1,1,0],
        [1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1],
        [0,1,1,1,1,1,1,0],
        [0,0,1,1,1,1,0,0],
        [0,0,0,1,1,0,0,0],
      ];
      const ox = hx - 4 * scale;
      const oy = hy - 3.5 * scale;
      for (let r = 0; r < px.length; r++)
        for (let c = 0; c < px[r].length; c++)
          if (px[r][c]) ctx.fillRect(Math.floor(ox + c * scale), Math.floor(oy + r * scale), scale, scale);
      ctx.globalAlpha = 1;
    }

    const hs = 5;

    function drawSplitHeart(sep, shakeX, shakeY) {
      const halfW = 4 * hs;
      const hTop = heartY - 4 * hs;
      const hBot = heartY + 4 * hs;

      const zigW = 3;
      const zigH = hs;

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(cx - sep - halfW - 10, hTop - 10);
      ctx.lineTo(cx - sep - halfW - 10, hBot + 10);

      let zy = hBot + 10;
      while (zy > hTop - 10) {
        ctx.lineTo(cx - sep + zigW, zy - zigH / 2);
        ctx.lineTo(cx - sep - zigW, zy - zigH);
        zy -= zigH;
      }
      ctx.closePath();
      ctx.clip();
      drawPixelHeart(cx - sep + shakeX, heartY + shakeY, hs, '#00ff00', 1);
      ctx.restore();

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(cx + sep + halfW + 10, hTop - 10);
      ctx.lineTo(cx + sep + halfW + 10, hBot + 10);

      zy = hBot + 10;
      while (zy > hTop - 10) {
        ctx.lineTo(cx + sep - zigW, zy - zigH / 2);
        ctx.lineTo(cx + sep + zigW, zy - zigH);
        zy -= zigH;
      }
      ctx.closePath();
      ctx.clip();
      drawPixelHeart(cx + sep + shakeX, heartY + shakeY, hs, '#00ff00', 1);
      ctx.restore();
    }

    if (t >= 60 && t < 240) {
      drawPixelHeart(cx, heartY, hs, '#00ff00', 1);
    }

    if (t >= 240 && t < 380) {
      const sep = 4;

      let shakeX = 0, shakeY = 0;
      if (t >= 340) {
        shakeX = Math.floor(Math.sin(t * 0.8) * 2);
        shakeY = Math.floor(Math.cos(t * 1.1) * 1);
      }

      drawSplitHeart(sep, shakeX, shakeY);

      if (t % 12 === 0 && t < 320) {
        particles.push({
          x: cx + (Math.random()-0.5)*8, y: heartY,
          vx: (Math.random()-0.5)*1.5, vy: Math.random()*1.5 + 0.5,
          life: 25, color: '#00ff00', size: 3,
        });
      }

      if (t === 240) shakeTimer = Math.max(shakeTimer, 4);
    }

    if (t >= 380 && t < 410) {
      drawPixelHeart(cx, heartY, hs, '#00ff00', 1);
      if (t === 380) shakeTimer = Math.max(shakeTimer, 4);
    }

    if (t >= 410 && t < 440) {
      drawPixelHeart(cx, heartY, hs, '#00ff00', 1);
    }

    if (t >= 440 && t < 530) {
      drawPixelHeart(cx, heartY, hs, '#00ff00', 1);

      const text = '* But it refused.';
      const letterDelay = 4;
      const lettersShown = Math.min(text.length, Math.floor((t - 440) / letterDelay));
      const displayText = text.substring(0, lettersShown);

      ctx.fillStyle = '#fff';
      ctx.font = 'bold 32px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(displayText, cx, textY);
    }

    if (t >= 530 && t < 620) {
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 32px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('* But it refused.', cx, textY);

      const goldProgress = Math.min(1, (t - 540) / 60);
      const heartColor = goldProgress < 0.5 ? ((t % 8 < 4) ? '#00ff00' : '#44ff88') : ((t % 6 < 3) ? '#ffd700' : '#ffcc00');
      const heartScale = hs + (goldProgress > 0.5 ? Math.sin(t * 0.15) * 1.5 : 0);
      drawPixelHeart(cx, heartY, heartScale, heartColor, 1);

      if (t > 560) shakeTimer = Math.max(shakeTimer, 2 + Math.floor(goldProgress * 3));

      if (goldProgress > 0.5) {
        for (let w = 0; w < 6; w++) {
          const wa = (Date.now()/1000 * 1.5 + w * Math.PI / 3) % (Math.PI * 2);
          const wd = 30 + Math.sin(Date.now()/1000 * 2 + w) * 15;
          ctx.fillStyle = `rgba(255, 215, 0, ${0.2 + Math.sin(Date.now()/1000 * 3 + w) * 0.15})`;
          ctx.beginPath();
          ctx.arc(cx + Math.cos(wa) * wd, heartY + Math.sin(wa) * wd, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      if (t >= 545) {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('The will of a genius cannot be extinguished.', cx, heartY + 50);
      }
    }

    if (t >= 620 && t < 780) {
      const phaseDur = 160;
      const fadeIn = Math.min(1, (t - 620) / 30);

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const zoomProg = (t - 620) / phaseDur;
      const hawkSize = Math.min(W * 0.45, 320) + zoomProg * 40;
      const hawkH_val = imgH(hawkingImg, hawkSize);
      ctx.globalAlpha = fadeIn;
      ctx.drawImage(hawkingImg, cx - hawkSize/2, H * 0.2 - zoomProg * 15, hawkSize, hawkH_val);
      ctx.globalAlpha = 1;

      if (t > 660) {
        const textAlpha = Math.min(1, (t - 660) / 25);
        ctx.globalAlpha = textAlpha;
        ctx.fillStyle = '#999';
        ctx.font = 'italic 18px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('Stephen Hawking', cx, H * 0.2 + hawkH_val + 20);
        ctx.globalAlpha = 1;
      }

      if (t > 700) {
        const hbPhase = ((t - 700) % 40) / 40;
        if (hbPhase < 0.15) {
          const pulseAlpha = Math.sin(hbPhase / 0.15 * Math.PI) * 0.08;
          ctx.fillStyle = `rgba(255, 215, 0, ${pulseAlpha})`;
          ctx.fillRect(0, 0, W, H);
        }
      }

      if (t > 740) {
        const shk = ((t - 740) / 40) * 4;
        shakeTimer = Math.max(shakeTimer, Math.ceil(shk));
      }

      if (t > 760) {
        const earlyProg = (t - 760) / 20;
        const crackN = Math.floor(earlyProg * 4);
        for (let c = 0; c < crackN; c++) {
          ctx.strokeStyle = `rgba(255, 215, 0, ${0.15 + Math.random() * 0.1})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          const sx = cx + (Math.sin(c * 5.3) * 0.3) * W;
          const sy = H * 0.35 + Math.cos(c * 3.7) * H * 0.2;
          ctx.moveTo(sx, sy);
          for (let s = 0; s < 3; s++) {
            ctx.lineTo(sx + (Math.random()-0.5) * 60, sy + (Math.random()-0.5) * 50);
          }
          ctx.stroke();
        }
      }
    }

    if (t >= 780 && t < 920) {
      const flashProg = (t - 780) / 140;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const hawkSize = Math.min(W * 0.45, 320);
      const hawkH_val = imgH(hawkingImg, hawkSize);
      if (flashProg < 0.4) {
        ctx.globalAlpha = 1 - flashProg * 2;
        ctx.drawImage(hawkingImg, cx - hawkSize/2, H * 0.2, hawkSize, hawkH_val);
        ctx.globalAlpha = 1;
      }

      const crackCount = Math.floor(flashProg * 20);
      for (let c = 0; c < crackCount; c++) {
        ctx.strokeStyle = `rgba(255, 215, 0, ${0.2 + Math.random() * 0.4})`;
        ctx.lineWidth = 1 + Math.random() * 3 + flashProg * 2;
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 15 + flashProg * 25;
        ctx.beginPath();
        const startX = cx + (Math.sin(c * 7.3 + flashProg * 2) * 0.5) * W;
        const startY = H * 0.4 + Math.cos(c * 4.1) * H * 0.3;
        ctx.moveTo(startX, startY);
        for (let s = 0; s < 6; s++) {
          ctx.lineTo(startX + (Math.random()-0.5) * 140 * (s+1)/3, startY + (Math.random()-0.5) * 110 * (s+1)/3);
        }
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      const flashGrad = ctx.createRadialGradient(cx, H * 0.4, 0, cx, H * 0.4, W * flashProg * 0.8);
      flashGrad.addColorStop(0, `rgba(255, 215, 0, ${flashProg * 0.7})`);
      flashGrad.addColorStop(0.5, `rgba(255, 200, 0, ${flashProg * 0.3})`);
      flashGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = flashGrad;
      ctx.fillRect(0, 0, W, H);

      shakeTimer = Math.max(shakeTimer, Math.ceil(5 + flashProg * 15));

      if (flashProg > 0.5 && Math.random() < flashProg * 0.3) {
        ctx.fillStyle = `rgba(255, 200, 0, ${Math.random() * 0.08})`;
        ctx.fillRect(0, 0, W, H);
      }

      if (flashProg > 0.85) {
        ctx.fillStyle = `rgba(255, 230, 100, ${(flashProg - 0.85) / 0.15})`;
        ctx.fillRect(0, 0, W, H);
      }
    }

    if (t >= 920 && t < 1120) {
      const revealProg = (t - 920) / 200;

      const bgFade = Math.min(1, revealProg * 2);
      if (revealProg < 0.2) {
        ctx.fillStyle = `rgba(255, 230, 100, ${1 - revealProg * 5})`;
        ctx.fillRect(0, 0, W, H);
      }
      ctx.fillStyle = `rgba(0, 0, 0, ${bgFade})`;
      ctx.fillRect(0, 0, W, H);

      const hawkSize = Math.min(W * 0.5, 350);
      const hawkH_val = imgH(hawkingGoldImg, hawkSize);
      const hawkAlpha = Math.min(1, revealProg * 3);

      for (let a = 0; a < 3; a++) {
        const aRad = hawkSize * (0.8 + a * 0.4) + Math.sin(Date.now()/1000 * 2 + a) * 10;
        const aGrad = ctx.createRadialGradient(cx, H * 0.35 + hawkH_val * 0.4, 10, cx, H * 0.35 + hawkH_val * 0.4, aRad);
        aGrad.addColorStop(0, `rgba(255, 215, 0, ${(0.2 - a * 0.05) * hawkAlpha})`);
        aGrad.addColorStop(0.6, `rgba(255, 180, 0, ${(0.08 - a * 0.02) * hawkAlpha})`);
        aGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = aGrad;
        ctx.beginPath();
        ctx.arc(cx, H * 0.35 + hawkH_val * 0.4, aRad, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.globalAlpha = hawkAlpha;
      ctx.shadowColor = '#ffd700';
      ctx.shadowBlur = 40 + revealProg * 40;
      ctx.drawImage(hawkingGoldImg, cx - hawkSize/2, H * 0.2, hawkSize, hawkH_val);
      ctx.drawImage(hawkingGoldImg, cx - hawkSize/2, H * 0.2, hawkSize, hawkH_val);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;

      if (revealProg > 0.2) {
        const tAlpha = Math.min(1, (revealProg - 0.2) / 0.2);
        ctx.globalAlpha = tAlpha;
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 30px monospace';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 25;
        ctx.fillText('T R A N S C E N D E D', cx, H * 0.1);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }

      if (revealProg > 0.4) {
        const dlgProg = (revealProg - 0.4) / 0.6;
        const quotes = [
          { at: 0.0, text: '"You thought you could kill me?"', y: 0.78 },
          { at: 0.35, text: '"I have conquered death itself."', y: 0.84 },
          { at: 0.7, text: '"Now... face a GOD."', y: 0.90, bold: true },
        ];
        for (const q of quotes) {
          if (dlgProg >= q.at) {
            const qProg = Math.min(1, (dlgProg - q.at) / 0.2);
            const showLen = Math.floor(q.text.length * Math.min(1, qProg * 3));
            ctx.globalAlpha = Math.min(1, qProg * 2);
            ctx.fillStyle = q.bold ? '#ffd700' : '#dddddd';
            ctx.font = q.bold ? 'bold 24px monospace' : '18px monospace';
            ctx.textAlign = 'center';
            if (q.bold) { ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 15; }
            ctx.fillText(q.text.substring(0, showLen), cx, H * q.y);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          }
        }
      }

      if (revealProg > 0.15) {
        const ringT = Date.now()/1000;
        for (let r = 0; r < 4; r++) {
          const rPhase = ((ringT * 0.6 + r * 0.25) % 1);
          const rRadius = 30 + rPhase * 300;
          ctx.strokeStyle = `rgba(255, 215, 0, ${(1 - rPhase) * 0.2})`;
          ctx.lineWidth = 2 * (1 - rPhase);
          ctx.beginPath();
          ctx.arc(cx, H * 0.35 + hawkH_val * 0.3, rRadius, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      if (revealProg > 0.1) {
        for (let gp = 0; gp < 20; gp++) {
          const gpT = Date.now()/1000;
          const gpx = cx + Math.sin(gpT * 1.2 + gp * 0.31) * hawkSize * 0.8;
          const gpy = H * 0.9 - ((gpT * 30 + gp * 25) % (H * 0.75));
          ctx.fillStyle = `rgba(255, 215, 0, ${0.2 + Math.sin(gpT * 3 + gp) * 0.15})`;
          ctx.beginPath();
          ctx.arc(gpx, gpy, 1.5 + Math.sin(gpT * 2 + gp) * 1, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    ctx.imageSmoothingEnabled = true;

    ctx.fillStyle = '#ffffff22';
    ctx.fillRect(W - 110, 8, 100, 28);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 110, 8, 100, 28);
    ctx.fillStyle = '#aaa';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SKIP \u25b6\u25b6', W - 60, 27);
  }

  if (state === 'hawkingDeath') {
    const dt = hawkingDeathTimer;
    const hawk = miniBosses.find(m => m.name === 'HAWKING');
    const hx = hawk ? hawk._deathX || W/2 : W/2;
    const hy = hawk ? hawk._deathY || H/2 : H/2;
    const t = Date.now() / 1000;

    if (dt < 80) {
      const freezeProg = dt / 80;

      ctx.fillStyle = `rgba(0,0,0,${freezeProg * 0.6})`;
      ctx.fillRect(0, 0, W, H);

      const distGrad = ctx.createRadialGradient(hx, hy, 10, hx, hy, 300 + freezeProg * 200);
      distGrad.addColorStop(0, `rgba(255,200,0,${0.15 * freezeProg})`);
      distGrad.addColorStop(0.4, `rgba(255,200,0,${0.05 * freezeProg})`);
      distGrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = distGrad;
      ctx.fillRect(0, 0, W, H);

      if (dt > 30) {
        const glitchN = Math.floor((dt - 30) / 5);
        for (let g = 0; g < glitchN; g++) {
          const gy = ((g * 97 + dt * 7) % H);
          const gw = 50 + Math.random() * 200;
          ctx.fillStyle = `rgba(255,200,0,${0.1 + Math.random() * 0.15})`;
          ctx.fillRect(Math.random() * W, gy, gw, 2);
        }
      }

      if (dt > 40) {
        ctx.globalAlpha = Math.sin((dt - 40) / 40 * Math.PI);
        ctx.fillStyle = '#ffd700';
        ctx.font = `bold ${14 + Math.sin(t * 10) * 2}px monospace`;
        ctx.textAlign = 'center';
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 20;
        ctx.fillText('CRITICAL MASS REACHED', W/2, H * 0.15);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }
    }

    if (dt >= 80 && dt < 200) {
      const riseProg = (dt - 80) / 120;

      ctx.fillStyle = `rgba(0,0,0,${0.7 + riseProg * 0.2})`;
      ctx.fillRect(0, 0, W, H);

      const colW = 60 + riseProg * 120;
      const colGrad = ctx.createLinearGradient(hx - colW/2, H, hx + colW/2, hy - 200);
      colGrad.addColorStop(0, 'rgba(255,200,0,0)');
      colGrad.addColorStop(0.3, `rgba(255,200,0,${0.2 + riseProg * 0.3})`);
      colGrad.addColorStop(0.6, `rgba(136,255,204,${0.15 + riseProg * 0.25})`);
      colGrad.addColorStop(1, `rgba(255,255,255,${riseProg * 0.3})`);
      ctx.fillStyle = colGrad;
      ctx.fillRect(hx - colW/2, hy - 200, colW, H - hy + 200);

      if (hawk) {
        const floatY = hy - 100 * riseProg;
        const hSize = 120 + riseProg * 40;
        const hH = imgH(hawkingImg, hSize);
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 30 + riseProg * 60;
        ctx.drawImage(hawkingGoldImg, hx - hSize/2, floatY - hH/2, hSize, hH);
        ctx.shadowBlur = 0;
        ctx.restore();
      }

      const ringCount = Math.floor(riseProg * 6);
      for (let r = 0; r < ringCount; r++) {
        const rProg = ((t * 0.8 + r * 0.3) % 1);
        const rRadius = 50 + rProg * 350;
        ctx.strokeStyle = `rgba(255,200,0,${(1-rProg) * 0.3})`;
        ctx.lineWidth = 3 * (1 - rProg);
        ctx.beginPath();
        ctx.arc(hx, hy - 100 * riseProg, rRadius, 0, Math.PI * 2);
        ctx.stroke();
      }

      for (let p = 0; p < 8; p++) {
        const pa = (t * 2 + p * 0.785) % (Math.PI * 2);
        const pd = 100 + Math.sin(t * 3 + p) * 40;
        const px = hx + Math.cos(pa) * pd;
        const py = (hy - 100 * riseProg) + Math.sin(pa) * pd * 0.6;
        ctx.fillStyle = `rgba(255,200,0,${0.4 + Math.sin(t*5+p)*0.2})`;
        ctx.beginPath();
        ctx.arc(px, py, 2 + Math.sin(t*4+p)*1, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    if (dt >= 200 && dt < 400) {
      const crackProg = (dt - 200) / 200;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const starCount = Math.floor(crackProg * 120);
      for (let s = 0; s < starCount; s++) {
        const sx = (s * 73.7 + s * s * 3.1) % W;
        const sy = (s * 47.3 + s * 11.7) % H;
        const twinkle = 0.2 + Math.sin(t * 3 + s * 2) * 0.15;
        ctx.fillStyle = `rgba(255,255,255,${twinkle * crackProg})`;
        const sSize = s % 11 === 0 ? 3 : (s % 5 === 0 ? 2 : 1);
        ctx.fillRect(sx, sy, sSize, sSize);
      }

      const crackCount = Math.floor(crackProg * 8);
      for (let c = 0; c < crackCount; c++) {
        const cStartX = (c * 157 + 100) % W;
        const cStartY = (c * 211 + 80) % H;
        ctx.strokeStyle = `rgba(255,200,0,${0.4 + Math.sin(t*4+c)*0.2})`;
        ctx.lineWidth = 2 + Math.sin(t * 6 + c) * 1;
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.moveTo(cStartX, cStartY);
        for (let seg = 0; seg < 6; seg++) {
          ctx.lineTo(
            cStartX + (Math.random()-0.5) * 150 * (seg+1)/3,
            cStartY + seg * 30 + (Math.random()-0.5) * 40
          );
        }
        ctx.stroke();
        ctx.shadowBlur = 0;

        const crGlow = ctx.createRadialGradient(cStartX, cStartY, 0, cStartX, cStartY, 30);
        crGlow.addColorStop(0, `rgba(255,200,0,${0.3 * (1 - crackProg * 0.5)})`);
        crGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = crGlow;
        ctx.fillRect(cStartX - 30, cStartY - 30, 60, 60);
      }

      if (hawk) {
        const dissolve = Math.min(1, crackProg * 1.5);
        const floatY = hy - 120 - Math.sin(t * 0.5) * 20;
        const hSize = 160 - crackProg * 40;
        const hH = imgH(hawkingGoldImg, hSize);
        ctx.save();
        ctx.globalAlpha = Math.max(0, 1 - dissolve);
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 40 + crackProg * 80;
        ctx.drawImage(hawkingGoldImg, hx - hSize/2, floatY - hH/2, hSize, hH);
        ctx.shadowBlur = 0;
        ctx.restore();

        const auraGrad = ctx.createRadialGradient(hx, floatY, 10, hx, floatY, 200);
        auraGrad.addColorStop(0, `rgba(255,200,0,${0.3 + dissolve * 0.3})`);
        auraGrad.addColorStop(0.4, `rgba(255,200,0,${0.1})`);
        auraGrad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = auraGrad;
        ctx.beginPath();
        ctx.arc(hx, floatY, 200, 0, Math.PI * 2);
        ctx.fill();
      }

      if (crackProg > 0.5 && Math.random() < crackProg * 0.3) {
        const barY = Math.random() * H;
        ctx.fillStyle = `rgba(255,200,0,${Math.random() * 0.1})`;
        ctx.fillRect(0, barY, W, 2 + Math.random() * 4);
      }
    }

    if (dt >= 400 && dt < 550) {
      const disProg = (dt - 400) / 150;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      for (let s = 0; s < 150; s++) {
        const sx = (s * 73.7 + s * s * 3.1) % W;
        const sy = (s * 47.3 + s * 11.7) % H;
        const twinkle = 0.15 + Math.sin(t * 2.5 + s * 1.5) * 0.12;
        ctx.fillStyle = `rgba(255,255,255,${twinkle})`;
        ctx.fillRect(sx, sy, s % 7 === 0 ? 2 : 1, s % 7 === 0 ? 2 : 1);
      }

      const novaCenter = { x: hx, y: hy - 120 };
      const novaR = disProg * 400;
      for (let nr = 0; nr < 4; nr++) {
        const nrR = novaR * (0.3 + nr * 0.2);
        const nrAlpha = Math.max(0, (1 - disProg) * 0.4 - nr * 0.08);
        ctx.strokeStyle = `rgba(255,200,0,${nrAlpha})`;
        ctx.lineWidth = 4 - nr;
        ctx.beginPath();
        ctx.arc(novaCenter.x, novaCenter.y, nrR, 0, Math.PI * 2);
        ctx.stroke();
      }

      const novaGlow = ctx.createRadialGradient(novaCenter.x, novaCenter.y, 0, novaCenter.x, novaCenter.y, 100 * (1 - disProg * 0.5));
      novaGlow.addColorStop(0, `rgba(255,255,255,${(1 - disProg) * 0.6})`);
      novaGlow.addColorStop(0.3, `rgba(255,200,0,${(1 - disProg) * 0.3})`);
      novaGlow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = novaGlow;
      ctx.beginPath();
      ctx.arc(novaCenter.x, novaCenter.y, 100, 0, Math.PI * 2);
      ctx.fill();

      const constellationPts = 30;
      for (let cp = 0; cp < constellationPts; cp++) {
        const cpAngle = (cp / constellationPts) * Math.PI * 2 + Math.sin(cp * 3) * 0.5;
        const cpDist = 30 + disProg * (80 + cp * 8);
        const cpx = novaCenter.x + Math.cos(cpAngle) * cpDist;
        const cpy = novaCenter.y + Math.sin(cpAngle) * cpDist * 0.7;
        if (cpx < 0 || cpx > W || cpy < 0 || cpy > H) continue;
        const cpAlpha = Math.min(1, disProg * 3) * (0.3 + Math.sin(t * 2 + cp) * 0.2);
        ctx.fillStyle = `rgba(255,200,0,${cpAlpha})`;
        const cpSize = cp % 4 === 0 ? 4 : 2;
        ctx.beginPath();
        ctx.arc(cpx, cpy, cpSize, 0, Math.PI * 2);
        ctx.fill();

        if (cp % 4 === 0) {
          ctx.fillStyle = `rgba(255,200,0,${cpAlpha * 0.3})`;
          ctx.beginPath();
          ctx.arc(cpx, cpy, 10, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      if (disProg > 0.4) {
        ctx.strokeStyle = `rgba(255,200,0,${(disProg - 0.4) * 0.15})`;
        ctx.lineWidth = 1;
        for (let lp = 0; lp < constellationPts - 1; lp += 3) {
          const a1 = (lp / constellationPts) * Math.PI * 2 + Math.sin(lp * 3) * 0.5;
          const d1 = 30 + disProg * (80 + lp * 8);
          const a2 = ((lp+3) / constellationPts) * Math.PI * 2 + Math.sin((lp+3) * 3) * 0.5;
          const d2 = 30 + disProg * (80 + (lp+3) * 8);
          ctx.beginPath();
          ctx.moveTo(novaCenter.x + Math.cos(a1)*d1, novaCenter.y + Math.sin(a1)*d1*0.7);
          ctx.lineTo(novaCenter.x + Math.cos(a2)*d2, novaCenter.y + Math.sin(a2)*d2*0.7);
          ctx.stroke();
        }
      }
    }

    if (dt >= 550 && dt < 750) {
      const cosmicProg = (dt - 550) / 200;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      for (let s = 0; s < 100; s++) {
        const sx = ((s * 73.7 + s * s * 3.1) + t * 5) % W;
        const sy = (s * 47.3 + s * 11.7) % H;
        ctx.fillStyle = `rgba(255,255,255,${0.15 + Math.sin(t + s) * 0.1})`;
        ctx.fillRect(sx, sy, 1, 1);
      }

      for (let cp = 0; cp < 20; cp++) {
        const cpAngle = (cp / 20) * Math.PI * 2;
        const cpDist = 200 + cosmicProg * 50 + Math.sin(t * 0.5 + cp) * 20;
        const cpx = hx + Math.cos(cpAngle) * cpDist;
        const cpy = (hy - 120) + Math.sin(cpAngle) * cpDist * 0.7;
        ctx.fillStyle = `rgba(255,200,0,${0.15 * (1 - cosmicProg * 0.5)})`;
        ctx.beginPath();
        ctx.arc(cpx, cpy, 2, 0, Math.PI * 2);
        ctx.fill();
      }

      if (cosmicProg < 0.4) {
        const eqText = 'E = mc\u00B2';
        const eqProg = cosmicProg / 0.4;
        const charCount = Math.floor(eqText.length * eqProg);
        ctx.fillStyle = `rgba(255,221,68,${eqProg})`;
        ctx.font = `bold ${40 + Math.sin(t * 2) * 3}px monospace`;
        ctx.textAlign = 'center';
        ctx.shadowColor = '#ffdd44';
        ctx.shadowBlur = 25;
        ctx.fillText(eqText.substring(0, charCount), W/2, H * 0.35);
        ctx.shadowBlur = 0;
      } else {

        const fadeProg = Math.min(1, (cosmicProg - 0.4) / 0.15);
        ctx.globalAlpha = 1 - fadeProg;
        ctx.fillStyle = '#ffdd44';
        ctx.font = `bold 40px monospace`;
        ctx.textAlign = 'center';
        ctx.shadowColor = '#ffdd44';
        ctx.shadowBlur = 20;
        ctx.fillText('E = mc\u00B2', W/2, H * 0.35);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }

      if (cosmicProg > 0.35) {
        const dlgProg = (cosmicProg - 0.35) / 0.65;
        const dialogues = [
          { at: 0.0, text: '"The universe...' },
          { at: 0.3, text: '...finally balanced."' },
          { at: 0.65, text: '- Stephen Hawking' },
        ];
        for (const dlg of dialogues) {
          if (dlgProg >= dlg.at) {
            const dProg = Math.min(1, (dlgProg - dlg.at) / 0.2);
            const isAttrib = dlg.text.startsWith('-');
            ctx.globalAlpha = Math.sin(Math.min(1, dProg) * Math.PI * 0.5);
            ctx.fillStyle = isAttrib ? '#ffd700' : '#ffffff';
            ctx.font = isAttrib ? 'italic 18px monospace' : `${22 + Math.sin(t)*1}px monospace`;
            ctx.textAlign = 'center';
            ctx.shadowColor = isAttrib ? '#ffd700' : '#ffffff';
            ctx.shadowBlur = 12;
            const yOff = isAttrib ? 0.62 : (dlg.at < 0.2 ? 0.48 : 0.55);

            const fullLen = dlg.text.length;
            const showLen = Math.floor(fullLen * Math.min(1, dProg * 3));
            ctx.fillText(dlg.text.substring(0, showLen), W/2, H * yOff);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          }
        }
      }

      const pulseR = 100 + Math.sin(t * 1.5) * 30;
      const pulseGrad = ctx.createRadialGradient(W/2, H * 0.45, 0, W/2, H * 0.45, pulseR);
      pulseGrad.addColorStop(0, `rgba(255,200,0,${0.05 + Math.sin(t*2)*0.02})`);
      pulseGrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = pulseGrad;
      ctx.beginPath();
      ctx.arc(W/2, H * 0.45, pulseR, 0, Math.PI * 2);
      ctx.fill();
    }

    if (dt >= 750 && dt < 850) {
      const whiteProg = (dt - 750) / 100;
      if (whiteProg < 0.3) {

        const flashP = whiteProg / 0.3;
        ctx.fillStyle = `rgba(255,255,255,${flashP})`;
        ctx.fillRect(0, 0, W, H);
      } else if (whiteProg < 0.7) {

        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, W, H);
        const textProg = (whiteProg - 0.3) / 0.4;
        ctx.fillStyle = `rgba(0,0,0,${Math.sin(textProg * Math.PI)})`;
        ctx.font = 'bold 48px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('HAWKING DEFEATED', W/2, H * 0.45);
        ctx.fillStyle = `rgba(180,140,40,${Math.sin(textProg * Math.PI) * 0.7})`;
        ctx.font = '18px monospace';
        ctx.fillText('The mind that defied death... rests at last.', W/2, H * 0.55);
      } else {

        const fadeP = (whiteProg - 0.7) / 0.3;
        const brightness = Math.floor(255 * (1 - fadeP));
        ctx.fillStyle = `rgb(${brightness},${brightness},${brightness})`;
        ctx.fillRect(0, 0, W, H);
      }
    }

    if (dt >= 850) {

      const victProg = (dt - 850) / 50;
      ctx.fillStyle = `rgba(0,0,0,${1 - victProg * 0.5})`;
      ctx.fillRect(0, 0, W, H);

      ctx.globalAlpha = Math.sin(victProg * Math.PI);
      ctx.fillStyle = '#ffdd44';
      ctx.font = 'bold 36px monospace';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#ffdd44';
      ctx.shadowBlur = 30;
      ctx.fillText('\u2605 FREEDOM \u2605', W/2, H * 0.45);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }

    const barH = 45;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, barH);
    ctx.fillRect(0, H - barH, W, barH);
    ctx.strokeStyle = '#ffd70044';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(0, barH); ctx.lineTo(W, barH); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, H - barH); ctx.lineTo(W, H - barH); ctx.stroke();

    const vigGrad = ctx.createRadialGradient(W/2, H/2, H*0.2, W/2, H/2, H*0.9);
    vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
    vigGrad.addColorStop(1, `rgba(0,0,0,${Math.min(0.5, dt / 200)})`);
    ctx.fillStyle = vigGrad;
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#ffffff22';
    ctx.fillRect(W - 110, 8, 100, 28);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 110, 8, 100, 28);
    ctx.fillStyle = '#aaa';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SKIP \u25b6\u25b6', W - 60, 27);
  }

  if (state === 'winCutscene') {
    const wt = winCutsceneTimer;

    const officeScreenX = winCutsceneOfficeX - cameraX;
    const officeY = GROUND_Y - 200;

    ctx.fillStyle = '#4a3c2e';
    ctx.fillRect(officeScreenX, officeY, 180, 200);

    ctx.fillStyle = '#2a1c0e';
    ctx.beginPath();
    ctx.moveTo(officeScreenX - 20, officeY);
    ctx.lineTo(officeScreenX + 90, officeY - 60);
    ctx.lineTo(officeScreenX + 200, officeY);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#1a140a';
    ctx.fillRect(officeScreenX + 65, officeY + 120, 50, 80);

    ctx.fillStyle = '#ffdd44';
    ctx.beginPath();
    ctx.arc(officeScreenX + 105, officeY + 160, 3, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#ffeeaa';
    ctx.fillRect(officeScreenX + 20, officeY + 40, 40, 50);
    ctx.fillRect(officeScreenX + 120, officeY + 40, 40, 50);

    ctx.strokeStyle = '#2a1c0e';
    ctx.lineWidth = 2;
    ctx.strokeRect(officeScreenX + 20, officeY + 40, 40, 50);
    ctx.strokeRect(officeScreenX + 120, officeY + 40, 40, 50);

    ctx.beginPath();
    ctx.moveTo(officeScreenX + 40, officeY + 40); ctx.lineTo(officeScreenX + 40, officeY + 90);
    ctx.moveTo(officeScreenX + 20, officeY + 65); ctx.lineTo(officeScreenX + 60, officeY + 65);
    ctx.moveTo(officeScreenX + 140, officeY + 40); ctx.lineTo(officeScreenX + 140, officeY + 90);
    ctx.moveTo(officeScreenX + 120, officeY + 65); ctx.lineTo(officeScreenX + 160, officeY + 65);
    ctx.stroke();

    ctx.fillStyle = '#1a4480';
    ctx.fillRect(officeScreenX + 25, officeY + 100, 130, 22);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('CITIZENSHIP OFFICE', officeScreenX + 90, officeY + 115);

    const flagX = officeScreenX + 170, flagY = officeY - 80;
    ctx.fillStyle = '#654321';
    ctx.fillRect(flagX, flagY, 3, 80);

    const fW = 32, fH = 20;

    for (let s = 0; s < 7; s++) {
      ctx.fillStyle = s % 2 === 0 ? '#cc0000' : '#ffffff';
      ctx.fillRect(flagX + 3, flagY + s * (fH / 7), fW, fH / 7);
    }

    ctx.fillStyle = '#0044aa';
    ctx.fillRect(flagX + 3, flagY, fW * 0.45, fH * 0.57);

    if (wt >= 300 && wt < 350) {

    }

    if (wt >= 350) {
      const fadeP = Math.min(1, (wt - 350) / 100);
      ctx.fillStyle = `rgba(0,0,0,${fadeP})`;
      ctx.fillRect(0, 0, W, H);
    }

    if (wt >= 480) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const textProg = Math.min(1, (wt - 480) / 60);
      ctx.globalAlpha = textProg;
      ctx.fillStyle = '#ffdd44';
      ctx.font = 'bold 56px monospace';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#ffdd44';
      ctx.shadowBlur = 20;
      ctx.fillText('THE END', W/2, H/2 - 20);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;

      if (wt >= 540) {
        const subProg = Math.min(1, (wt - 540) / 40);
        ctx.globalAlpha = subProg;
        ctx.fillStyle = '#88ccff';
        ctx.font = '18px monospace';
        ctx.fillText('Thank you for playing', W/2, H/2 + 30);
        ctx.globalAlpha = 1;
      }

      if (wt >= 580 && settings.showTimer) {
        const tProg = Math.min(1, (wt - 580) / 40);
        ctx.globalAlpha = tProg * 0.7;
        ctx.fillStyle = '#aaa';
        ctx.font = '14px monospace';
        const mins = Math.floor(gameTimer / 3600);
        const secs = Math.floor((gameTimer % 3600) / 60);
        ctx.fillText(`Time: ${mins}:${secs.toString().padStart(2, '0')}`, W / 2, H / 2 + 60);
        ctx.globalAlpha = 1;
      }

      if (wt >= 620) {
        const credProg = Math.min(1, (wt - 620) / 40);
        ctx.globalAlpha = credProg * 0.6;
        ctx.fillStyle = '#666';
        ctx.font = '12px monospace';
        ctx.fillText('A game about perseverance', W/2, H/2 + 90);
        ctx.globalAlpha = 1;
      }
    }

    const barH = 45;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, barH);
    ctx.fillRect(0, H - barH, W, barH);

    ctx.fillStyle = '#ffffff22';
    ctx.fillRect(W - 110, 8, 100, 28);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 110, 8, 100, 28);
    ctx.fillStyle = '#aaa';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SKIP \u25b6\u25b6', W - 60, 27);
  }

  if (bossIntroTimer > 60) {
    const introFade = (bossIntroTimer - 60) / 30;
    ctx.fillStyle = `rgba(255,255,255,${introFade})`;
    ctx.fillRect(0, 0, W, H);
  }

  if (inBossFight && bossIntroTimer > 0) {
    const barH = 50 * Math.min(1, bossIntroTimer / 30);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, barH);
    ctx.fillRect(0, H - barH, W, barH);
  }

  if (inBossFight) {
    const bPhase = boss ? boss.phase : 1;
    const isEpstein = state === 'epsteinfight' || state === 'phonecall';
    const isFusion = state === 'fusioncutscene' || state === 'fusionfight';
    const isSplit = state === 'splitfight';
    const vigGrad = ctx.createRadialGradient(W/2, H/2, H*0.3, W/2, H/2, H*0.8);
    vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
    if (isFusion) {
      vigGrad.addColorStop(0.7, 'rgba(30,10,0,0.35)');
      vigGrad.addColorStop(1, 'rgba(60,10,30,0.6)');
    } else if (isSplit) {
      vigGrad.addColorStop(0.7, 'rgba(10,10,30,0.3)');
      vigGrad.addColorStop(1, 'rgba(20,10,50,0.5)');
    } else if (isEpstein) {
      vigGrad.addColorStop(0.7, 'rgba(20,0,30,0.3)');
      vigGrad.addColorStop(1, 'rgba(40,0,60,0.55)');
    } else {
      vigGrad.addColorStop(0.7, bPhase === 3 ? 'rgba(30,5,0,0.3)' : 'rgba(0,10,5,0.25)');
      vigGrad.addColorStop(1, bPhase === 3 ? 'rgba(60,0,0,0.6)' : 'rgba(0,15,5,0.5)');
    }
    ctx.fillStyle = vigGrad;
    ctx.fillRect(0, 0, W, H);
  }

  if (state === 'phonecall') {

    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);

    const pulse = Math.sin(Date.now() / 200) * 0.5 + 0.5;
    const ringColor = `rgba(255,200,0,${pulse * 0.3})`;
    ctx.strokeStyle = ringColor;
    ctx.lineWidth = 3;
    for (let r = 0; r < 3; r++) {
      const ringR = 30 + r * 25 + pulse * 10;
      ctx.beginPath();
      ctx.arc(W/2, H/2 - 60, ringR, 0, Math.PI * 2);
      ctx.stroke();
    }

    const trumpX = W * 0.25 - 60;
    const trumpY = H * 0.3;
    ctx.save();
    ctx.shadowColor = '#ff8800';
    ctx.shadowBlur = 20;
    ctx.drawImage(bossIntroImg, trumpX, trumpY, 120, 160);
    ctx.shadowBlur = 0;
    ctx.restore();

    ctx.fillStyle = '#333';
    ctx.fillRect(trumpX + 105, trumpY + 30, 20, 35);
    ctx.fillStyle = '#4488ff';
    ctx.fillRect(trumpX + 107, trumpY + 33, 16, 29);
    ctx.strokeStyle = '#88ccff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(trumpX + 115, trumpY + 43, 4, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(trumpX + 108, trumpY + 52);
    ctx.lineTo(trumpX + 122, trumpY + 52);
    ctx.stroke();

    const epX = W * 0.75 - 50;
    const epY = H * 0.3;
    const epReveal = 1 - (phonecallTimer / 300);
    ctx.save();
    ctx.globalAlpha = 0.3 + epReveal * 0.7;
    ctx.shadowColor = '#8844ff';
    ctx.shadowBlur = 30 * epReveal;
    ctx.drawImage(epsteinImg, epX, epY, 100, 140);
    ctx.shadowBlur = 0;
    ctx.restore();

    if (epReveal < 0.6) {
      ctx.fillStyle = `rgba(0,0,0,${0.8 - epReveal})`;
      ctx.fillRect(epX, epY, 100, 140);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 24px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('?', epX + 50, epY + 80);
    }

    const dots = '.'.repeat(1 + Math.floor(Date.now() / 400) % 3);
    ctx.fillStyle = '#ffcc00';
    ctx.font = 'bold 28px monospace';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#ff880088';
    ctx.shadowBlur = 10;
    ctx.fillText(`CALLING${dots}`, W/2, H * 0.25);
    ctx.shadowBlur = 0;

    ctx.strokeStyle = `rgba(255,200,0,${0.3 + pulse * 0.3})`;
    ctx.lineWidth = 2;
    ctx.setLineDash([8, 8]);
    ctx.beginPath();
    ctx.moveTo(trumpX + 125, trumpY + 50);
    ctx.lineTo(epX, epY + 70);
    ctx.stroke();
    ctx.setLineDash([]);

    if (bossDialogue.active && bossDialogue.index < bossDialogue.texts.length) {
      const dText = bossDialogue.texts[bossDialogue.index];
      const boxY = H * 0.72;
      ctx.fillStyle = '#000000cc';
      ctx.fillRect(W * 0.1, boxY, W * 0.8, 80);
      ctx.strokeStyle = '#ffcc0066';
      ctx.lineWidth = 2;
      ctx.strokeRect(W * 0.1, boxY, W * 0.8, 80);
      ctx.fillStyle = '#ffcc00';
      ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'left';
      ctx.fillText('TRUMP:', W * 0.13, boxY + 25);
      ctx.fillStyle = '#fff';
      ctx.font = '16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(dText, W/2, boxY + 55);
    }

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, 40);
    ctx.fillRect(0, H - 40, W, 40);

    ctx.fillStyle = '#ffffff33';
    ctx.fillRect(W - 110, 8, 100, 28);
    ctx.strokeStyle = '#ffffff55';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 110, 8, 100, 28);
    ctx.fillStyle = '#ccc';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SKIP ▶▶', W - 60, 27);
  }

  if (state === 'endless' || state === 'endlessShop') {
    ctx.textAlign = 'left';

    const hpBarX = 12, hpBarY = 12, hpBarW = 160, hpBarH = 20;
    ctx.fillStyle = '#00000088';
    ctx.fillRect(hpBarX - 2, hpBarY - 2, hpBarW + 4, hpBarH + 4);
    ctx.fillStyle = '#333';
    ctx.fillRect(hpBarX, hpBarY, hpBarW, hpBarH);
    const pHpPct = player.hp / player.maxHp;
    const hpCol = pHpPct > 0.5 ? '#44ff44' : pHpPct > 0.25 ? '#ffcc22' : '#ff4444';
    ctx.fillStyle = hpCol;
    ctx.fillRect(hpBarX, hpBarY, hpBarW * pHpPct, hpBarH);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px monospace';
    ctx.fillText(`HP: ${player.hp}/${player.maxHp}`, hpBarX + 5, hpBarY + 15);

    if (endless.powerups.shield > 0) {
      const shieldY = hpBarY + hpBarH + 6;
      for (let si = 0; si < endless.powerups.shield; si++) {
        const sx = hpBarX + si * 20;
        ctx.fillStyle = si < endless.shieldCharges ? '#44ddff' : '#333344';
        ctx.beginPath();
        ctx.moveTo(sx + 8, shieldY);
        ctx.lineTo(sx + 15, shieldY + 4);
        ctx.lineTo(sx + 13, shieldY + 12);
        ctx.lineTo(sx + 8, shieldY + 16);
        ctx.lineTo(sx + 3, shieldY + 12);
        ctx.lineTo(sx + 1, shieldY + 4);
        ctx.closePath();
        ctx.fill();
      }
    }

    if (endless.powerups.dash > 0) {
      const dashReady = endless.dashCooldown <= 0;
      ctx.fillStyle = dashReady ? '#88ffcc' : '#555';
      ctx.font = '11px monospace';
      ctx.textAlign = 'left';
      ctx.fillText(dashReady ? 'DASH READY' : 'DASH...', hpBarX, hpBarY + (endless.powerups.shield > 0 ? 42 : 30));
    }

    ctx.textAlign = 'center';
    ctx.fillStyle = '#88ccff';
    ctx.font = 'bold 28px monospace';
    ctx.shadowColor = '#4488ff';
    ctx.shadowBlur = 10;
    ctx.fillText(`ROUND ${endless.round}`, W / 2, 32);
    ctx.shadowBlur = 0;

    if (endless.bossActive && endless.roundTimer < 180) {
      const annAlpha = endless.roundTimer < 30 ? endless.roundTimer / 30 : endless.roundTimer > 150 ? (180 - endless.roundTimer) / 30 : 1;
      ctx.globalAlpha = annAlpha;
      const bossEnemy = endless.enemies.find(e => e.isBoss && !e.dead);
      if (bossEnemy) {
        ctx.fillStyle = '#000000cc';
        ctx.fillRect(W / 2 - 250, H / 2 - 60, 500, 100);
        ctx.strokeStyle = bossEnemy.color;
        ctx.lineWidth = 3;
        ctx.strokeRect(W / 2 - 250, H / 2 - 60, 500, 100);
        ctx.fillStyle = '#ff4444';
        ctx.font = 'bold 16px monospace';
        ctx.fillText('WARNING — BOSS ROUND', W / 2, H / 2 - 30);
        ctx.fillStyle = bossEnemy.color;
        ctx.font = 'bold 28px monospace';
        ctx.shadowColor = bossEnemy.color;
        ctx.shadowBlur = 15;
        ctx.fillText(bossEnemy.bossName, W / 2, H / 2 + 10);
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#aaa';
        ctx.font = '12px monospace';
        ctx.fillText('Defeat the boss to advance!', W / 2, H / 2 + 30);
      }
      ctx.globalAlpha = 1;
    }

    const remainCount = endless.enemies.length + endless.spawnsLeft;
    ctx.fillStyle = remainCount > 0 ? '#ff8844' : '#44ff88';
    ctx.font = 'bold 14px monospace';
    if (endless.bossActive) {
      const bosses = endless.enemies.filter(e => e.isBoss && !e.dead);
      if (bosses.length > 0) {
        ctx.fillStyle = '#ff4444';
        ctx.fillText('BOSS FIGHT', W / 2, 52);
      } else {
        ctx.fillStyle = '#44ff88';
        ctx.fillText('BOSS DEFEATED!', W / 2, 52);
      }
    } else {
      ctx.fillText(`Enemies: ${remainCount}`, W / 2, 52);
    }

    if (endless.modifier && state === 'endless') {
      ctx.fillStyle = '#ffaa00';
      ctx.font = 'bold 12px monospace';
      ctx.fillText(endless.modifier.name + ' - ' + endless.modifier.desc, W / 2, 68);
    }

    if (endless.bossActive) {
      let bossBarIdx = 0;
      for (const e of endless.enemies) {
        if (!e.isBoss || e.dead) continue;
        const bbW = 400, bbH = 16;
        const bbX = W / 2 - bbW / 2;
        const bbY = 76 + bossBarIdx * 28;

        ctx.fillStyle = '#00000088';
        ctx.fillRect(bbX - 2, bbY - 2, bbW + 4, bbH + 4);
        ctx.fillStyle = '#222';
        ctx.fillRect(bbX, bbY, bbW, bbH);

        const bHpPct = e.hp / e.maxHp;
        const grad = ctx.createLinearGradient(bbX, 0, bbX + bbW, 0);
        grad.addColorStop(0, e.color);
        grad.addColorStop(1, '#ff2222');
        ctx.fillStyle = grad;
        ctx.fillRect(bbX, bbY, bbW * bHpPct, bbH);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 11px monospace';
        ctx.fillText(`${e.bossName}  ${e.hp}/${e.maxHp}`, W / 2, bbY + 13);
        bossBarIdx++;
      }
    }

    ctx.textAlign = 'right';
    ctx.fillStyle = '#ffcc44';
    ctx.font = 'bold 14px monospace';
    ctx.fillText(`Kills: ${endless.totalKills}`, W - 12, 24);
    ctx.fillStyle = '#888';
    ctx.font = '11px monospace';
    ctx.fillText(`Best: Round ${endless.highScore}`, W - 12, 40);

    ctx.textAlign = 'left';
    let puY = H - 18;
    const pu = endless.powerups;
    const puKeys = Object.keys(ENDLESS_POWERUP_DEFS);
    for (let pi = puKeys.length - 1; pi >= 0; pi--) {
      const k = puKeys[pi];
      if (pu[k] <= 0) continue;
      const def = ENDLESS_POWERUP_DEFS[k];

      drawEndlessIcon(ctx, def.icon, 22, puY - 5, 14, def.color);
      ctx.fillStyle = def.color;
      ctx.font = '12px monospace';
      ctx.textAlign = 'left';
      ctx.fillText(`${def.name} Lv.${pu[k]}`, 34, puY);
      puY -= 18;
    }
    ctx.textAlign = 'left';
    if (_isTouchDev) drawTouchButtons();
  }

  if (state === 'endlessShop' && endless.shopChoices.length > 0) {

    ctx.fillStyle = '#000000aa';
    ctx.fillRect(0, 0, W, H);

    ctx.textAlign = 'center';
    ctx.fillStyle = '#ffcc44';
    ctx.font = 'bold 32px monospace';
    ctx.shadowColor = '#ffaa0066';
    ctx.shadowBlur = 15;
    ctx.fillText('CHOOSE YOUR POWER-UP', W / 2, H * 0.18);
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#aaa';
    ctx.font = '14px monospace';
    ctx.fillText(`Round ${endless.round} cleared! Pick a power-up.`, W / 2, H * 0.24);

    const cardW = Math.min(220, (W - 60) / 3);
    const cardH = 240;
    const cardGap = 16;
    const totalW = cardW * endless.shopChoices.length + cardGap * (endless.shopChoices.length - 1);
    const startX = W / 2 - totalW / 2;
    const cardY = H * 0.3;

    for (let ci = 0; ci < endless.shopChoices.length; ci++) {
      const key = endless.shopChoices[ci];
      const def = ENDLESS_POWERUP_DEFS[key];
      const curLevel = endless.powerups[key];
      const selected = ci === endless.shopSelection;
      const cx = startX + ci * (cardW + cardGap);

      ctx.fillStyle = selected ? '#222244' : '#111122';
      ctx.fillRect(cx, cardY, cardW, cardH);

      ctx.strokeStyle = selected ? def.color : '#444466';
      ctx.lineWidth = selected ? 3 : 1;
      ctx.strokeRect(cx, cardY, cardW, cardH);

      if (selected) {
        ctx.shadowColor = def.color;
        ctx.shadowBlur = 20;
        ctx.strokeRect(cx, cardY, cardW, cardH);
        ctx.shadowBlur = 0;
      }

      drawEndlessIcon(ctx, def.icon, cx + cardW / 2, cardY + 42, 36, def.color);

      ctx.font = 'bold 14px monospace';
      ctx.fillStyle = '#fff';
      ctx.fillText(def.name, cx + cardW / 2, cardY + 85);

      ctx.font = '11px monospace';
      ctx.fillStyle = '#aaa';
      ctx.fillText(def.desc, cx + cardW / 2, cardY + 108);

      if (curLevel > 0) {
        ctx.fillStyle = '#88ff88';
        ctx.font = 'bold 12px monospace';
        ctx.fillText(`Lv.${curLevel} → Lv.${curLevel + 1}`, cx + cardW / 2, cardY + 135);
        ctx.fillStyle = '#ffcc44';
        ctx.font = '10px monospace';
        ctx.fillText('UPGRADE!', cx + cardW / 2, cardY + 152);
      } else {
        ctx.fillStyle = '#44aaff';
        ctx.font = 'bold 12px monospace';
        ctx.fillText('NEW!', cx + cardW / 2, cardY + 135);
      }

      ctx.fillStyle = '#666';
      ctx.font = '10px monospace';
      ctx.fillText(`Max: ${def.max}`, cx + cardW / 2, cardY + cardH - 15);

      if (selected) {
        ctx.fillStyle = def.color;
        ctx.font = 'bold 13px monospace';
        ctx.fillText('▶ ENTER / TAP ◀', cx + cardW / 2, cardY + cardH - 35);
      }
    }

    ctx.fillStyle = '#888';
    ctx.font = '12px monospace';
    ctx.textAlign = 'center';
    if (mpEnabled && endless.shopPicked) {

      ctx.fillStyle = '#00000088';
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = '#ffcc44';
      ctx.font = 'bold 24px monospace';
      ctx.textAlign = 'center';
      const dots = '.'.repeat(1 + Math.floor(Date.now() / 500) % 3);
      ctx.fillText('Waiting for other players' + dots, W / 2, H / 2);
      ctx.fillStyle = '#aaa';
      ctx.font = '14px monospace';
      ctx.fillText('You picked: ' + ENDLESS_POWERUP_DEFS[endless.shopChoices[endless.shopSelection]]?.name, W / 2, H / 2 + 35);
    } else {
      ctx.fillText('← → to select, ENTER to choose', W / 2, cardY + cardH + 30);
    }
    ctx.textAlign = 'left';
  }

  if (state === 'playing' && bigWall) {
    const dist = Math.max(0, bigWall.x - player.x);
    const pct = Math.min(1, 1 - dist / (levelWidth - 280));

    ctx.fillStyle = '#00000088';
    ctx.fillRect(W / 2 - 150, 12, 300, 20);
    ctx.fillStyle = '#333';
    ctx.fillRect(W / 2 - 148, 14, 296, 16);

    const barGrad = ctx.createLinearGradient(W / 2 - 148, 0, W / 2 + 148, 0);
    barGrad.addColorStop(0, '#44aaff');
    barGrad.addColorStop(1, hawkingPhase2 ? '#ffd700' : '#44ff88');
    ctx.fillStyle = barGrad;
    ctx.fillRect(W / 2 - 148, 14, 296 * pct, 16);

    ctx.shadowColor = '#000';
    ctx.shadowBlur = 3;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 11px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`LA FRONTERA: ${Math.floor(pct * 100)}%`, W / 2, 27);
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';

    const hpW = 200;
    ctx.fillStyle = '#00000088';
    ctx.fillRect(20, 12, hpW + 4, 22);
    ctx.fillStyle = '#222';
    ctx.fillRect(22, 14, hpW, 18);
    const phpPct = player.hp / player.maxHp;
    const phpCol = cbHP(phpPct);
    const hpGrad = ctx.createLinearGradient(22, 14, 22, 32);
    hpGrad.addColorStop(0, phpCol.b);
    hpGrad.addColorStop(0.5, phpCol.b);
    hpGrad.addColorStop(1, '#00000044');
    ctx.fillStyle = hpGrad;
    ctx.fillRect(22, 14, hpW * phpPct, 18);

    ctx.fillStyle = '#ffffff18';
    ctx.fillRect(22, 14, hpW * phpPct, 6);

    ctx.strokeStyle = '#ffffff33';
    ctx.lineWidth = 1;
    ctx.strokeRect(20, 12, hpW + 4, 22);

    ctx.shadowColor = '#000';
    ctx.shadowBlur = 3;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`HP: ${player.hp}/${player.maxHp}`, 28, 28);
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';

    ctx.fillStyle = '#ffffff55';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(_isTouchDev ? '¡Cuidado! Use on-screen controls' : '← → Move  |  ←/Space Jump  |  Hold ← Climb  |  Click/F Throw  |  ¡Cuidado!', W / 2, H - 10);

    if (boss && !boss.dead) {
      const bossHudW = 250;
      const bHpPct = boss.hp / boss.maxHp;
      ctx.fillStyle = '#00000099';
      ctx.fillRect(W - bossHudW - 30, 12, bossHudW + 10, 26);
      ctx.fillStyle = '#222';
      ctx.fillRect(W - bossHudW - 25, 14, bossHudW, 22);
      ctx.fillStyle = bHpPct > 0.5 ? '#cc2222' : bHpPct > 0.25 ? '#cc6622' : '#ff0000';
      ctx.fillRect(W - bossHudW - 25, 14, bossHudW * bHpPct, 22);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 12px monospace';
      ctx.textAlign = 'right';
      ctx.fillText(`★ TRUMP: ${boss.hp}/${boss.maxHp}`, W - 30, 30);
    }

    drawTouchButtons();
  }

  if (state === 'bossfight') {

    const hpW = 200;
    ctx.fillStyle = '#00000099';
    ctx.fillRect(15, 8, hpW + 14, 30);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(17, 10, hpW + 10, 26);
    const phpPct = player.hp / player.maxHp;
    const phpCols = cbHP(phpPct);
    const phpGrad = ctx.createLinearGradient(22, 0, 22 + hpW, 0);
    phpGrad.addColorStop(0, phpCols.a);
    phpGrad.addColorStop(1, phpCols.b);
    ctx.fillStyle = phpGrad;
    ctx.fillRect(22, 14, hpW * phpPct, 18);

    ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/200)*0.1+0.1})`;
    ctx.fillRect(22, 14, hpW * phpPct * 0.5, 6);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(22, 14, hpW, 18);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`❤ ${player.hp}/${player.maxHp}`, 28, 29);

    if (boss && !boss.dead) {
      const bossHudW = Math.min(500, W * 0.6, W - 260);
      const bHpPct = boss.hp / boss.maxHp;
      const barX = Math.max(240, W/2 - bossHudW/2);
      const bossHudY = 44;

      ctx.fillStyle = '#000000cc';
      ctx.fillRect(barX - 5, bossHudY, bossHudW + 10, 38);

      const phaseNames = { 1: 'TRUMP', 2: '★ TRUMP - ENRAGED ★', 3: '★★ TRUMP - FINAL FORM ★★' };
      ctx.fillStyle = boss.phase === 3 ? '#ff2222' : boss.phase === 2 ? '#ff8844' : '#ffcc44';
      ctx.font = `bold ${boss.phase === 3 ? 13 : 12}px monospace`;
      ctx.textAlign = 'center';
      ctx.shadowColor = boss.phase === 3 ? '#ff0000' : '#ff880088';
      ctx.shadowBlur = boss.phase * 4;
      ctx.fillText(phaseNames[boss.phase], W/2, bossHudY + 13);
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#1a0a0a';
      ctx.fillRect(barX, bossHudY + 17, bossHudW, 16);
      const bossGrad = ctx.createLinearGradient(barX, 0, barX + bossHudW, 0);
      if (bHpPct > 0.6) { bossGrad.addColorStop(0, '#881111'); bossGrad.addColorStop(1, '#cc3333'); }
      else if (bHpPct > 0.25) { bossGrad.addColorStop(0, '#883300'); bossGrad.addColorStop(1, '#ee6600'); }
      else { bossGrad.addColorStop(0, '#990000'); bossGrad.addColorStop(1, '#ff2200'); }
      ctx.fillStyle = bossGrad;
      ctx.fillRect(barX, bossHudY + 17, bossHudW * bHpPct, 16);

      ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/150)*0.12+0.08})`;
      ctx.fillRect(barX, bossHudY + 17, bossHudW * bHpPct * 0.4, 5);

      ctx.fillStyle = '#ffffff66';
      ctx.fillRect(barX + bossHudW * 0.6, bossHudY + 17, 2, 16);
      ctx.fillRect(barX + bossHudW * 0.25, bossHudY + 17, 2, 16);

      ctx.strokeStyle = boss.phase === 3 ? '#ff444488' : '#ff880044';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, bossHudY + 17, bossHudW, 16);

      ctx.fillStyle = '#ffffffcc';
      ctx.font = 'bold 10px monospace';
      ctx.fillText(`${boss.hp} / ${boss.maxHp}`, W/2, bossHudY + 29);
    }

    if (boss && !boss.dead && boss.phase > 1) {
      ctx.fillStyle = boss.phase === 3 ? '#ff000088' : '#ff660066';
      ctx.font = 'bold 16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`PHASE ${boss.phase}`, W/2, 95);
    }

    drawTouchButtons();

    ctx.fillStyle = '#ffffff55';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(_isTouchDev ? 'Defeat Trump to cross!' : 'Defeat Trump to cross!  |  Click/F Throw  |  \u2190 \u2192 Move  |  \u2191/Space Jump', W / 2, H - 10);
  }

  if (state === 'epsteinfight') {

    const hpW = 200;
    ctx.fillStyle = '#00000099';
    ctx.fillRect(15, 8, hpW + 14, 30);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(17, 10, hpW + 10, 26);
    const phpPct2 = player.hp / player.maxHp;
    const phpGrad2 = ctx.createLinearGradient(22, 0, 22 + hpW, 0);
    const phpCols2 = cbHP(phpPct2);
    phpGrad2.addColorStop(0, phpCols2.a);
    phpGrad2.addColorStop(1, phpCols2.b);
    ctx.fillStyle = phpGrad2;
    ctx.fillRect(22, 14, hpW * phpPct2, 18);
    ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/200)*0.1+0.1})`;
    ctx.fillRect(22, 14, hpW * phpPct2 * 0.5, 6);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(22, 14, hpW, 18);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`❤ ${player.hp}/${player.maxHp}`, 28, 29);

    if (epstein && !epstein.dead) {
      const eHudW = Math.min(500, W * 0.5, W - 260);
      const eHpPct = epstein.hp / epstein.maxHp;
      const barX = Math.max(240, W/2 - eHudW/2);

      ctx.fillStyle = '#000000cc';
      ctx.fillRect(barX - 5, 5, eHudW + 10, 38);

      const ePhaseNames = { 1: 'EPSTEIN', 2: '★ EPSTEIN - UNHINGED ★' };
      ctx.fillStyle = epstein.phase === 2 ? '#ff44ff' : '#aa88ff';
      ctx.font = `bold ${epstein.phase === 2 ? 13 : 12}px monospace`;
      ctx.textAlign = 'center';
      ctx.shadowColor = '#8844ff';
      ctx.shadowBlur = epstein.phase * 6;
      ctx.fillText(ePhaseNames[epstein.phase], W/2, 18);
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#0a0a1a';
      ctx.fillRect(barX, 22, eHudW, 16);
      const eGrad = ctx.createLinearGradient(barX, 0, barX + eHudW, 0);
      if (eHpPct > 0.5) { eGrad.addColorStop(0, '#442288'); eGrad.addColorStop(1, '#8844ff'); }
      else if (eHpPct > 0.25) { eGrad.addColorStop(0, '#662288'); eGrad.addColorStop(1, '#cc44ff'); }
      else { eGrad.addColorStop(0, '#880044'); eGrad.addColorStop(1, '#ff22ff'); }
      ctx.fillStyle = eGrad;
      ctx.fillRect(barX, 22, eHudW * eHpPct, 16);

      ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/150)*0.12+0.08})`;
      ctx.fillRect(barX, 22, eHudW * eHpPct * 0.4, 5);

      ctx.fillStyle = '#ffffff66';
      ctx.fillRect(barX + eHudW * 0.4, 22, 2, 16);

      ctx.strokeStyle = epstein.phase === 2 ? '#ff44ff88' : '#8844ff44';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, 22, eHudW, 16);

      ctx.fillStyle = '#ffffffcc';
      ctx.font = 'bold 10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`${epstein.hp} / ${epstein.maxHp}`, W/2, 34);
    }

    if (epstein && !epstein.dead && epstein.phase === 2) {
      ctx.fillStyle = '#ff44ff88';
      ctx.font = 'bold 16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('PHASE 2', W/2, 56);
    }

    drawTouchButtons();

    ctx.fillStyle = '#ffffff55';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(_isTouchDev ? 'Defeat Epstein!' : 'Defeat Epstein!  |  Click/F Throw  |  \u2190 \u2192 Move  |  \u2191/Space Jump', W / 2, H - 10);
  }

  if (state === 'fusioncutscene') {

    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0, 0, W, H);

    const prog = 1 - fusionCutsceneTimer / 360;

    const pulse = Math.sin(Date.now() / 150) * 0.5 + 0.5;
    ctx.strokeStyle = `rgba(255,100,0,${0.2 + pulse * 0.3})`;
    ctx.lineWidth = 2;
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2 + Date.now() / 800;
      const outerR = 300 - prog * 200;
      const innerR = 20 + prog * 30;
      ctx.beginPath();
      ctx.moveTo(W/2 + Math.cos(angle) * outerR, H/2 + Math.sin(angle) * outerR);
      ctx.lineTo(W/2 + Math.cos(angle) * innerR, H/2 + Math.sin(angle) * innerR);
      ctx.stroke();
    }

    ctx.strokeStyle = `rgba(136,68,255,${0.2 + pulse * 0.3})`;
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2 + Date.now() / 800 + Math.PI / 12;
      const outerR = 280 - prog * 180;
      const innerR = 25 + prog * 35;
      ctx.beginPath();
      ctx.moveTo(W/2 + Math.cos(angle) * outerR, H/2 + Math.sin(angle) * outerR);
      ctx.lineTo(W/2 + Math.cos(angle) * innerR, H/2 + Math.sin(angle) * innerR);
      ctx.stroke();
    }

    const portraitSize = Math.min(W * 0.18, 140);
    const separation = (1 - prog) * 180;
    const shakeX = prog > 0.7 ? (Math.random() - 0.5) * 8 : 0;
    const shakeY = prog > 0.7 ? (Math.random() - 0.5) * 8 : 0;

    const portraitH = portraitSize * 1.3;

    ctx.save();
    ctx.globalAlpha = 0.7 + prog * 0.3;
    ctx.shadowColor = '#ff4400';
    ctx.shadowBlur = 20 + prog * 30;
    ctx.drawImage(bossIntroImg, W/2 - portraitSize - separation + shakeX, H/2 - portraitH/2 + shakeY, portraitSize, portraitH);
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = 0.7 + prog * 0.3;
    ctx.shadowColor = '#8844ff';
    ctx.shadowBlur = 20 + prog * 30;
    ctx.drawImage(epsteinImg, W/2 + separation + shakeX, H/2 - portraitH/2 + shakeY, portraitSize, portraitH);
    ctx.restore();

    const glowR = 30 + prog * 120;
    const glowGrad = ctx.createRadialGradient(W/2, H/2, 5, W/2, H/2, glowR);
    glowGrad.addColorStop(0, `rgba(255,200,100,${prog * 0.7})`);
    glowGrad.addColorStop(0.4, `rgba(255,100,50,${prog * 0.5})`);
    glowGrad.addColorStop(0.7, `rgba(136,68,255,${prog * 0.3})`);
    glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.arc(W/2, H/2, glowR, 0, Math.PI * 2);
    ctx.fill();

    if (prog > 0.5) {
      ctx.strokeStyle = `rgba(255,255,100,${(prog - 0.5) * 2})`;
      ctx.lineWidth = 2;
      for (let b = 0; b < 3; b++) {
        ctx.beginPath();
        let lx = W/2 - separation - 20, ly = H/2 + (b - 1) * 30;
        ctx.moveTo(lx, ly);
        for (let s = 0; s < 4; s++) {
          lx += separation / 2;
          ly += (Math.random() - 0.5) * 40;
          ctx.lineTo(lx, ly);
        }
        ctx.stroke();
      }
    }

    const textAlpha = Math.min(1, prog * 2);
    ctx.fillStyle = `rgba(255,200,100,${textAlpha})`;
    ctx.font = `bold ${Math.min(36, W * 0.05)}px monospace`;
    ctx.textAlign = 'center';
    ctx.shadowColor = '#ff4400';
    ctx.shadowBlur = 20;
    if (prog < 0.25) ctx.fillText('What is happening...', W/2, H * 0.15);
    else if (prog < 0.5) ctx.fillText('They\'re... merging?!', W/2, H * 0.15);
    else if (prog < 0.75) ctx.fillText('IMPOSSIBLE!', W/2, H * 0.15);
    else ctx.fillText('\u2605 FUSION COMPLETE \u2605', W/2, H * 0.15);
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, 55);
    ctx.fillRect(0, H - 55, W, 55);

    ctx.fillStyle = '#ffffff33';
    ctx.fillRect(W - 110, 12, 100, 28);
    ctx.strokeStyle = '#ffffff55';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 110, 12, 100, 28);
    ctx.fillStyle = '#ccc';
    ctx.font = 'bold 12px monospace';
    ctx.fillText('SKIP \u25ba\u25ba', W - 60, 31);
  }

  if (state === 'fusionfight') {

    const hpW = 200;
    ctx.fillStyle = '#00000099';
    ctx.fillRect(15, 8, hpW + 14, 30);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(17, 10, hpW + 10, 26);
    const phpPctF = player.hp / player.maxHp;
    const phpGradF = ctx.createLinearGradient(22, 0, 22 + hpW, 0);
    const phpColsF = cbHP(phpPctF);
    phpGradF.addColorStop(0, phpColsF.a);
    phpGradF.addColorStop(1, phpColsF.b);
    ctx.fillStyle = phpGradF;
    ctx.fillRect(22, 14, hpW * phpPctF, 18);
    ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/200)*0.1+0.1})`;
    ctx.fillRect(22, 14, hpW * phpPctF * 0.5, 6);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(22, 14, hpW, 18);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`\u2764 ${player.hp}/${player.maxHp}`, 28, 29);

    if (fusionBoss && !fusionBoss.dead) {
      const fHudW = Math.min(550, W * 0.55, W - 260);
      const fHpPct = fusionBoss.hp / fusionBoss.maxHp;
      const barX = Math.max(240, W/2 - fHudW/2);

      ctx.fillStyle = '#000000cc';
      ctx.fillRect(barX - 5, 5, fHudW + 10, 40);

      const fName = fusionBoss.phase === 2 ? '\u2605\u2605 TRUMPSTEIN - UNLEASHED \u2605\u2605' : '\u2605 TRUMPSTEIN \u2605';
      ctx.fillStyle = fusionBoss.phase === 2 ? '#ff4400' : '#ff8844';
      ctx.font = `bold ${fusionBoss.phase === 2 ? 14 : 13}px monospace`;
      ctx.textAlign = 'center';
      ctx.shadowColor = '#ff4400';
      ctx.shadowBlur = fusionBoss.phase * 8;
      ctx.fillText(fName, W/2, 19);
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#1a0a0a';
      ctx.fillRect(barX, 24, fHudW, 16);
      const fGrad = ctx.createLinearGradient(barX, 0, barX + fHudW, 0);
      fGrad.addColorStop(0, '#cc2200');
      fGrad.addColorStop(0.5, '#ff6644');
      fGrad.addColorStop(1, '#8844ff');
      ctx.fillStyle = fGrad;
      ctx.fillRect(barX, 24, fHudW * fHpPct, 16);
      ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/150)*0.12+0.08})`;
      ctx.fillRect(barX, 24, fHudW * fHpPct * 0.4, 5);
      ctx.fillStyle = '#ffffff66';
      ctx.fillRect(barX + fHudW * 0.4, 24, 2, 16);
      ctx.strokeStyle = fusionBoss.phase === 2 ? '#ff440088' : '#ff884444';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, 24, fHudW, 16);
      ctx.fillStyle = '#ffffffcc';
      ctx.font = 'bold 10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`${fusionBoss.hp} / ${fusionBoss.maxHp}`, W/2, 36);
    }

    if (fusionBoss && !fusionBoss.dead && fusionBoss.phase === 2) {
      ctx.fillStyle = '#ff440088';
      ctx.font = 'bold 16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('PHASE 2', W/2, 58);
    }

    drawTouchButtons();

    ctx.fillStyle = '#ffffff55';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(_isTouchDev ? 'Defeat TRUMPSTEIN!' : 'Defeat TRUMPSTEIN!  |  Click/F Throw  |  \u2190 \u2192 Move  |  \u2191/Space Jump', W / 2, H - 10);
  }

  if (state === 'splitfight') {

    if (bossIntroTimer > 0) {
      const introT = 1800;
      const prog = 1 - bossIntroTimer / introT;
      const t = Date.now() / 1000;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const globalZoom = 1 + prog * 0.04;
      ctx.save();
      ctx.translate(W/2, H/2);
      ctx.scale(globalZoom, globalZoom);
      ctx.translate(-W/2, -H/2);

      const scenes_t = [0.03, 0.055, 0.14, 0.24, 0.34, 0.44, 0.59];
      let chromatic = 0;
      for (const st of scenes_t) {
        const d = Math.abs(prog - st);
        if (d < 0.01) chromatic = Math.max(chromatic, (0.01 - d) / 0.01);
      }

      let bassDrop = 0;
      for (const st of scenes_t) {
        const d = prog - st;
        if (d > 0 && d < 0.015) bassDrop = Math.max(bassDrop, 1 - d / 0.015);
      }
      if (bassDrop > 0) {

        const shockR = (1 - bassDrop) * Math.max(W, H);
        ctx.strokeStyle = `rgba(255,255,255,${bassDrop * 0.4})`;
        ctx.lineWidth = 3 + bassDrop * 8;
        ctx.beginPath();
        ctx.arc(W/2, H/2, shockR, 0, Math.PI * 2);
        ctx.stroke();
      }

      const barH = 50;

      if (prog < 0.03) {
        const sp = prog / 0.03;

        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, W, H);

        if (sp > 0.2) {
          const tAlpha = Math.min(1, (sp - 0.2) / 0.3);
          ctx.globalAlpha = tAlpha * 0.6;
          ctx.fillStyle = '#888';
          ctx.font = `${Math.min(11, W*0.015)}px monospace`;
          ctx.textAlign = 'center';
          ctx.fillText('S E C U R E   L I N E   E S T A B L I S H E D', W/2, H/2 - 20);
          ctx.globalAlpha = 1;
        }
        if (sp > 0.5) {
          const tAlpha2 = Math.min(1, (sp - 0.5) / 0.3);
          ctx.globalAlpha = tAlpha2 * 0.4;
          ctx.fillStyle = '#ff4400';
          ctx.font = `bold ${Math.min(14, W*0.02)}px monospace`;
          ctx.fillText('C L A S S I F I E D', W/2, H/2 + 10);
          ctx.globalAlpha = 1;

          const scanY = H/2 - 30 + ((t * 60) % 60);
          ctx.fillStyle = 'rgba(255,68,0,0.03)';
          ctx.fillRect(0, scanY, W, 2);
        }

        if (sp > 0.7) {
          const pulseA = Math.sin((sp - 0.7) / 0.3 * Math.PI) * 0.08;
          ctx.fillStyle = `rgba(255,0,0,${pulseA})`;
          ctx.fillRect(0, 0, W, H);
        }
      }

      if (prog >= 0.03 && prog < 0.055) {
        const sp = (prog - 0.03) / 0.025;

        const tableGrad = ctx.createRadialGradient(W/2, H/2, 50, W/2, H/2, H);
        tableGrad.addColorStop(0, '#0a0612');
        tableGrad.addColorStop(1, '#000000');
        ctx.fillStyle = tableGrad;
        ctx.fillRect(0, 0, W, H);

        ctx.strokeStyle = '#0f0a1808';
        ctx.lineWidth = 1;
        for (let wg = 0; wg < 25; wg++) {
          const wy = H * (wg / 25) + Math.sin(wg * 3.7) * 8;
          ctx.beginPath(); ctx.moveTo(0, wy); ctx.lineTo(W, wy + Math.sin(wg)*5); ctx.stroke();
        }

        const ambGlow = ctx.createRadialGradient(W/2, H/2, 30, W/2, H/2, 300);
        ambGlow.addColorStop(0, 'rgba(136,68,255,0.08)');
        ambGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = ambGlow;
        ctx.fillRect(0, 0, W, H);

        ctx.fillStyle = '#121218';
        ctx.fillRect(W*0.28, H*0.6, 35, 15); ctx.fillRect(W*0.68, H*0.55, 50, 25);
        ctx.fillStyle = '#1a1620';
        ctx.fillRect(W*0.72, H*0.42, 20, 30);

        const phoneW = 200, phoneH = 360;
        const phoneX = W/2 - phoneW/2, phoneY = H/2 - phoneH/2;
        ctx.globalAlpha = Math.min(1, sp * 3);

        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath();
        ctx.roundRect(phoneX - 4, phoneY - 8, phoneW + 20, phoneH + 36, 20);
        ctx.fill();

        ctx.fillStyle = '#0a0a0a';
        ctx.beginPath();
        ctx.roundRect(phoneX - 10, phoneY - 18, phoneW + 20, phoneH + 36, 20);
        ctx.fill();

        ctx.fillStyle = '#060606';
        ctx.beginPath();
        ctx.roundRect(phoneX + phoneW/2 - 40, phoneY - 15, 80, 22, 12);
        ctx.fill();
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.arc(phoneX + phoneW/2, phoneY - 5, 4, 0, Math.PI*2); ctx.fill();

        const scrGrad = ctx.createLinearGradient(phoneX, phoneY, phoneX, phoneY + phoneH);
        scrGrad.addColorStop(0, '#1a0a2e');
        scrGrad.addColorStop(0.4, '#120828');
        scrGrad.addColorStop(1, '#0a0418');
        ctx.fillStyle = scrGrad;
        ctx.beginPath();
        ctx.roundRect(phoneX, phoneY, phoneW, phoneH, 4);
        ctx.fill();

        ctx.fillStyle = '#ffffff15';
        ctx.fillRect(phoneX, phoneY, phoneW, 20);
        ctx.fillStyle = '#888';
        ctx.font = '9px monospace';
        ctx.textAlign = 'left';
        ctx.fillText('9:41 PM', phoneX + 10, phoneY + 14);
        ctx.textAlign = 'right';
        ctx.fillText('5G ■ ■ ■ 📡87%', phoneX + phoneW - 10, phoneY + 14);

        ctx.textAlign = 'center';
        const ringPulse = Math.sin(sp * Math.PI * 8) * 0.5 + 0.5;

        for (let rr = 0; rr < 4; rr++) {
          ctx.strokeStyle = `rgba(136,68,255,${(0.4 - rr*0.1) + ringPulse * 0.3})`;
          ctx.lineWidth = 3 - rr*0.5;
          ctx.beginPath();
          ctx.arc(W/2, phoneY + 120, 35 + ringPulse * 12 + rr * 18, 0, Math.PI*2);
          ctx.stroke();
        }

        ctx.save();
        ctx.shadowColor = '#8844ff';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(W/2, phoneY + 120, 36, 0, Math.PI*2);
        ctx.fillStyle = '#8844ff';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(W/2, phoneY + 120, 33, 0, Math.PI*2);
        ctx.clip();
        ctx.drawImage(epsteinImg, W/2 - 33, phoneY + 87, 66, 66);
        ctx.restore();

        const thumbNames = ['T','E','M','C','H'];
        const thumbCols = ['#ff4400','#8844ff','#4488ff','#cc2222','#44ff88'];
        for (let th = 0; th < 5; th++) {
          const thx = phoneX + 30 + th * 35;
          ctx.fillStyle = thumbCols[th] + '44';
          ctx.beginPath(); ctx.arc(thx, phoneY + 45, 10, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 8px monospace';
          ctx.fillText(thumbNames[th], thx, phoneY + 48);
        }

        ctx.fillStyle = '#cc88ff';
        ctx.font = 'bold 16px monospace';
        ctx.fillText('EPSTEIN', W/2, phoneY + 180);
        ctx.fillStyle = '#999';
        ctx.font = '11px monospace';
        ctx.fillText('Group Call • 5 members', W/2, phoneY + 198);
        ctx.fillStyle = '#666';
        ctx.font = '9px monospace';
        ctx.fillText('End-to-End Encrypted', W/2, phoneY + 215);

        ctx.fillStyle = `rgba(136,68,255,${0.6 + ringPulse * 0.4})`;
        ctx.font = 'bold 13px monospace';
        ctx.fillText(sp > 0.5 ? '● CONNECTING...' : '● INCOMING CALL', W/2, phoneY + 260);

        if (sp > 0.5) {
          for (let sg = 0; sg < 4; sg++) {
            ctx.fillStyle = `rgba(136,68,255,${Math.sin(t*6 + sg)*0.3 + 0.5})`;
            ctx.fillRect(phoneX + 30 + sg*12, phoneY + 270, 8, 4);
          }
        }

        ctx.fillStyle = '#22cc44';
        ctx.shadowColor = '#22cc44';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(W/2 - 45, phoneY + 310, 20, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowColor = '#cc2222';
        ctx.fillStyle = '#cc2222';
        ctx.beginPath();
        ctx.arc(W/2 + 45, phoneY + 310, 20, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#fff';
        ctx.font = '12px monospace';
        ctx.fillText('\u260E', W/2 - 45, phoneY + 314);
        ctx.fillText('\u2716', W/2 + 45, phoneY + 314);
        ctx.fillStyle = '#aaa';
        ctx.font = '8px monospace';
        ctx.fillText('Accept', W/2 - 45, phoneY + 335);
        ctx.fillText('Decline', W/2 + 45, phoneY + 335);
        ctx.globalAlpha = 1;

        for (let or2 = 0; or2 < 3; or2++) {
          ctx.strokeStyle = `rgba(136,68,255,${ringPulse * 0.12 / (or2+1)})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(W/2, H/2, 180 + ringPulse * 50 + or2 * 60, 0, Math.PI*2);
          ctx.stroke();
        }

        if (sp < 0.5 && Math.sin(t*25) > 0.8) {
          ctx.translate(Math.sin(t*40)*2, 0);
        }
      }

      if (prog >= 0.055 && prog < 0.14) {
        const sp = (prog - 0.055) / 0.085;
        ctx.save();

        const ambGrad = ctx.createRadialGradient(W/2, H*0.45, 50, W/2, H*0.45, H);
        ambGrad.addColorStop(0, '#1a0a2a');
        ambGrad.addColorStop(0.5, '#0d0518');
        ambGrad.addColorStop(1, '#000000');
        ctx.fillStyle = ambGrad;
        ctx.fillRect(0, 0, W, H);

        ctx.fillStyle = '#0e0818';
        for (let bk = 0; bk < 8; bk++) {
          for (let bk2 = 0; bk2 < 15; bk2++) {
            const bxo = (bk % 2) * 45;
            ctx.fillRect(bk2 * 90 + bxo, bk * 45, 86, 42);
          }
        }

        for (let dc = 0; dc < 8; dc++) {
          ctx.fillStyle = `rgba(20,8,35,${0.3 + dc*0.02})`;
          ctx.fillRect(dc * 8, 0, 10, H);
          ctx.fillRect(W - dc * 8 - 10, 0, 10, H);
        }

        ctx.globalAlpha = 0.04;
        ctx.save();
        ctx.translate(W*0.3, H*0.1);
        ctx.rotate(t * 1.5);
        for (let fb = 0; fb < 4; fb++) {
          ctx.fillStyle = '#000';
          ctx.fillRect(-5, -60, 10, 120);
          ctx.rotate(Math.PI/2);
        }
        ctx.restore();
        ctx.globalAlpha = 1;

        for (let dp = 0; dp < 40; dp++) {
          const dpx = (dp * 137.5 + t * 12) % W;
          const dpy = (dp * 89.3 + Math.sin(t*0.7 + dp) * 40) % H;
          const dpSize = Math.max(0.1, 0.5 + Math.sin(dp*2.3) * 0.8);
          ctx.fillStyle = `rgba(136,68,255,${0.06 + Math.sin(t*2+dp)*0.06})`;
          ctx.beginPath();
          ctx.arc(dpx, dpy, dpSize, 0, Math.PI*2);
          ctx.fill();
        }

        ctx.fillStyle = '#0a0614';
        ctx.fillRect(W*0.15, H*0.62, W*0.7, H*0.06);
        ctx.fillStyle = '#08050f';
        ctx.fillRect(W*0.18, H*0.68, 15, H*0.2);
        ctx.fillRect(W*0.72, H*0.68, 15, H*0.2);

        for (let pp = 0; pp < 4; pp++) {
          ctx.save();
          ctx.translate(W*0.25 + pp*80, H*0.61);
          ctx.rotate((pp-2)*0.08);
          ctx.fillStyle = '#1a1428';
          ctx.fillRect(0, 0, 30, 40);
          ctx.restore();
        }

        ctx.fillStyle = '#1a1225';
        ctx.fillRect(W*0.7, H*0.58, 18, 22);
        ctx.strokeStyle = '#221830';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(W*0.7+24, H*0.58+11, 8, -Math.PI/2, Math.PI/2); ctx.stroke();

        const eSize = Math.min(W * 0.28, 200);
        const ex = W * 0.5, ey = H * 0.08;
        const enterSlide = Math.min(1, sp * 2.5);
        const easeEnter = 1 - Math.pow(1 - enterSlide, 3);
        ctx.globalAlpha = easeEnter;

        ctx.shadowColor = '#8844ff';
        ctx.shadowBlur = 60 + Math.sin(t*3)*15;
        ctx.drawImage(epsteinImg, ex - eSize/2, ey + (1-easeEnter)*80, eSize, imgH(epsteinImg, eSize));
        ctx.shadowBlur = 0;

        const phoneGlow = ctx.createRadialGradient(ex, ey + eSize * 1.1, 5, ex, ey + eSize * 1.1, 80);
        phoneGlow.addColorStop(0, `rgba(136,68,255,${0.5 + Math.sin(t*4)*0.15})`);
        phoneGlow.addColorStop(0.5, `rgba(136,68,255,0.1)`);
        phoneGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = phoneGlow;
        ctx.fillRect(ex - 80, ey + eSize * 0.7, 160, 120);

        ctx.fillStyle = '#222';
        ctx.beginPath(); ctx.roundRect(ex - 20, ey + eSize * 0.96, 40, 56, 4); ctx.fill();
        ctx.fillStyle = `rgba(136,68,255,${0.5 + Math.sin(t*5)*0.2})`;
        ctx.fillRect(ex - 17, ey + eSize * 0.99, 34, 42);

        ctx.fillStyle = '#eee';
        ctx.font = '5px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GROUP', ex, ey + eSize * 1.02 + 8);
        ctx.fillText('CALL', ex, ey + eSize * 1.02 + 16);
        ctx.fillStyle = '#44ff88';
        ctx.fillText('● LIVE', ex, ey + eSize * 1.02 + 26);

        if (sp > 0.2) {
          ctx.globalAlpha = Math.min(0.2, (sp - 0.2) * 0.3);
          for (let ray = 0; ray < 12; ray++) {
            const angle = (ray / 12) * Math.PI * 2 + t * 0.2;
            const rayWidth = 2 + Math.sin(t*2 + ray) * 2;
            ctx.strokeStyle = '#8844ff';
            ctx.lineWidth = rayWidth;
            ctx.beginPath();
            ctx.moveTo(ex, ey + eSize * 0.6);
            ctx.lineTo(ex + Math.cos(angle) * 600, ey + eSize * 0.6 + Math.sin(angle) * 600);
            ctx.stroke();
          }
        }

        ctx.globalAlpha = Math.min(0.8, sp * 3);
        ctx.fillStyle = '#0a0518cc';
        ctx.fillRect(W*0.25, H*0.04, W*0.5, 28);
        ctx.strokeStyle = '#8844ff44';
        ctx.lineWidth = 1;
        ctx.strokeRect(W*0.25, H*0.04, W*0.5, 28);
        ctx.fillStyle = '#8866cc';
        ctx.font = `bold ${Math.min(12, W*0.017)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('UNDISCLOSED SAFEHOUSE - LOCATION UNKNOWN', W/2, H*0.04 + 18);
        ctx.globalAlpha = 1;

        const lines2 = ['"They separated us..."', '"But we\'re not done yet."', '"Everyone. It\'s time."'];
        const lineIdx = Math.min(2, Math.floor(sp * 3));
        const lineLocalProg = sp * 3 - lineIdx;
        const lineAlpha = Math.min(1, lineLocalProg * 4);
        ctx.globalAlpha = lineAlpha;
        ctx.fillStyle = '#cc88ff';
        ctx.font = `italic ${Math.min(24, W*0.033)}px monospace`;
        ctx.textAlign = 'center';
        ctx.shadowColor = '#8844ff';
        ctx.shadowBlur = 10;
        const fullLine = lines2[lineIdx];
        const charsToShow = Math.floor(fullLine.length * Math.min(1, lineLocalProg * 2.5));
        ctx.fillText(fullLine.substring(0, charsToShow), W/2, H * 0.82);
        ctx.shadowBlur = 0;

        if (charsToShow < fullLine.length && Math.sin(t*10) > 0) {
          const measured = ctx.measureText(fullLine.substring(0, charsToShow));
          ctx.fillRect(W/2 + measured.width/2 + 2, H*0.82 - 16, 2, 20);
        }

        ctx.globalAlpha = 0.5;
        const vig = ctx.createRadialGradient(W/2, H/2, H*0.25, W/2, H/2, H*0.75);
        vig.addColorStop(0, 'rgba(0,0,0,0)');
        vig.addColorStop(1, 'rgba(0,0,0,0.8)');
        ctx.fillStyle = vig;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      if (prog >= 0.14 && prog < 0.24) {
        const sp = (prog - 0.14) / 0.1;
        ctx.save();

        const goldGrad = ctx.createLinearGradient(0, 0, W, H);
        goldGrad.addColorStop(0, '#2a1a00');
        goldGrad.addColorStop(0.3, '#3a2a10');
        goldGrad.addColorStop(0.5, '#4a3518');
        goldGrad.addColorStop(0.7, '#3a2a10');
        goldGrad.addColorStop(1, '#1a0a00');
        ctx.fillStyle = goldGrad;
        ctx.fillRect(0, 0, W, H);

        ctx.fillStyle = '#ffffff03';
        for (let mx = 0; mx < W; mx += 60) {
          for (let my = 0; my < H*0.65; my += 80) {
            ctx.fillRect(mx, my, 58, 78);
            ctx.strokeStyle = '#ffcc4408';
            ctx.lineWidth = 1;
            ctx.strokeRect(mx, my, 58, 78);
          }
        }

        for (let i = 0; i < 8; i++) {
          const cx2 = W * 0.05 + W * 0.9 * (i/7);

          ctx.fillStyle = '#ffcc4410';
          ctx.fillRect(cx2 - 10, 0, 20, H);
          ctx.strokeStyle = '#ffcc4418';
          ctx.lineWidth = 1;
          ctx.strokeRect(cx2 - 10, 0, 20, H);

          ctx.fillStyle = '#ffcc4418';
          ctx.fillRect(cx2 - 18, 0, 36, 28);
          ctx.fillRect(cx2 - 18, H*0.63, 36, 10);

          ctx.fillStyle = '#ffcc4410';
          ctx.beginPath();
          ctx.arc(cx2, 14, 10, 0, Math.PI*2);
          ctx.fill();
        }

        ctx.fillStyle = '#1a1208';
        ctx.fillRect(0, H*0.65, W, H*0.35);

        for (let fx = 0; fx < W; fx += 60) {
          for (let fy = 0; fy < H*0.35; fy += 60) {
            ctx.fillStyle = (Math.floor(fx/60) + Math.floor(fy/60)) % 2 === 0 ? '#1e1610' : '#16100a';
            ctx.fillRect(fx, H*0.65 + fy, 60, 60);
          }
        }
        ctx.fillStyle = '#ffffff04';
        ctx.fillRect(0, H*0.65, W, H*0.35);

        const chanX = W*0.5, chanY = H*0.02;

        ctx.strokeStyle = '#ffcc4433';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(chanX, 0); ctx.lineTo(chanX, chanY + 15); ctx.stroke();

        ctx.fillStyle = '#ffcc4420';
        ctx.beginPath(); ctx.ellipse(chanX, chanY + 20, 60, 12, 0, 0, Math.PI*2); ctx.fill();

        for (let cr = 0; cr < 8; cr++) {
          const crx = chanX - 50 + cr * 14;
          const cry = chanY + 25 + Math.sin(cr*1.5)*5;
          ctx.strokeStyle = '#ffcc4422';
          ctx.beginPath(); ctx.moveTo(crx, chanY + 20); ctx.lineTo(crx, cry + 15); ctx.stroke();
          ctx.fillStyle = `rgba(255,220,100,${0.1 + Math.sin(t*2+cr)*0.05})`;
          ctx.beginPath(); ctx.arc(crx, cry + 18, 3, 0, Math.PI*2); ctx.fill();
        }

        const chanGlow = ctx.createRadialGradient(chanX, chanY + 20, 10, chanX, chanY + 20, 200);
        chanGlow.addColorStop(0, 'rgba(255,204,68,0.12)');
        chanGlow.addColorStop(0.5, 'rgba(255,180,40,0.04)');
        chanGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = chanGlow;
        ctx.fillRect(0, 0, W, H*0.4);

        ctx.fillStyle = '#0a0808';
        ctx.fillRect(W*0.72, H*0.12, W*0.22, H*0.35);
        ctx.strokeStyle = '#ffcc4422';
        ctx.lineWidth = 3;
        ctx.strokeRect(W*0.72, H*0.12, W*0.22, H*0.35);

        ctx.strokeStyle = '#ffcc4415';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(W*0.83, H*0.12); ctx.lineTo(W*0.83, H*0.47); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.72, H*0.30); ctx.lineTo(W*0.94, H*0.30); ctx.stroke();

        ctx.fillStyle = '#080808';
        for (let bld = 0; bld < 12; bld++) {
          const bx = W*0.73 + bld*14;
          const bh = 20 + Math.sin(bld*2.3)*15 + bld*3;
          ctx.fillRect(bx, H*0.47 - bh, 11, bh);

          for (let wl = 0; wl < bh/8; wl++) {
            if (Math.sin(bld*7+wl*3+t*0.5) > 0.3) {
              ctx.fillStyle = '#ffdd8822';
              ctx.fillRect(bx+2, H*0.47-bh+wl*8+2, 3, 3);
            }
            ctx.fillStyle = '#080808';
          }
        }

        ctx.fillStyle = '#0a0500dd';
        ctx.fillRect(W*0.2, H*0.06, W*0.6, 32);
        ctx.strokeStyle = '#ffcc4466';
        ctx.lineWidth = 1;
        ctx.strokeRect(W*0.2, H*0.06, W*0.6, 32);
        ctx.fillStyle = '#ffdd88';
        ctx.font = `bold ${Math.min(14, W*0.019)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('\u2605 TRUMP TOWER - 58TH FLOOR PENTHOUSE \u2605', W/2, H*0.06 + 21);

        const tSize = Math.min(W * 0.26, 180);
        const tx = W * 0.3;
        const tEnter = Math.min(1, sp * 2.5);
        const tEase = 1 - Math.pow(1 - tEnter, 3);
        ctx.globalAlpha = tEase;
        ctx.shadowColor = '#ff4400';
        ctx.shadowBlur = 50 + Math.sin(t*2)*15;
        ctx.drawImage(bossIntroImg, tx - tSize/2, H * 0.16 + (1-tEase)*60, tSize, imgH(bossIntroImg, tSize));
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#3a2810';
        ctx.fillRect(W*0.52, H*0.48, W*0.38, H*0.14);
        ctx.strokeStyle = '#ffcc4433';
        ctx.lineWidth = 2;
        ctx.strokeRect(W*0.52, H*0.48, W*0.38, H*0.14);

        ctx.fillStyle = '#ffcc4418';
        ctx.fillRect(W*0.52, H*0.48, W*0.38, 3);

        ctx.fillStyle = '#2a1a08';
        ctx.fillRect(W*0.54, H*0.62, 12, H*0.12);
        ctx.fillRect(W*0.87, H*0.62, 12, H*0.12);

        ctx.fillStyle = '#2a1a08';
        ctx.fillRect(W*0.86, H*0.44, 22, 35);
        ctx.fillStyle = '#332208';
        ctx.fillRect(W*0.86, H*0.44, 22, 5);

        ctx.fillStyle = '#ffcc4430';
        ctx.fillRect(W*0.55, H*0.50, 70, 12);
        ctx.fillStyle = '#ffdd88';
        ctx.font = 'bold 7px monospace';
        ctx.fillText('PRESIDENT', W*0.59, H*0.50 + 9);

        ctx.strokeStyle = '#ffcc4415';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(W*0.82, H*0.46, 14, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.ellipse(W*0.82, H*0.46, 14, 5, 0.3, 0, Math.PI*2); ctx.stroke();

        ctx.fillStyle = '#cc222244';
        ctx.fillRect(W*0.08, H*0.12, 28, 18);
        ctx.fillStyle = '#112266';
        ctx.fillRect(W*0.08, H*0.12, 12, 10);
        ctx.strokeStyle = '#44220088';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(W*0.08, H*0.12); ctx.lineTo(W*0.08, H*0.45); ctx.stroke();

        const phoneX = W * 0.68;
        const phoneY = H * 0.46;
        const buzz = Math.sin(t * 25) * (sp < 0.5 ? 4 : 0);
        ctx.fillStyle = '#222';
        ctx.beginPath(); ctx.roundRect(phoneX - 14 + buzz, phoneY, 28, 46, 4); ctx.fill();
        ctx.fillStyle = `rgba(136,68,255,${0.5 + Math.sin(t*6)*0.3})`;
        ctx.fillRect(phoneX - 12 + buzz, phoneY + 3, 24, 34);
        ctx.fillStyle = '#fff';
        ctx.font = '6px monospace';
        ctx.fillText('CALL', phoneX + buzz, phoneY + 22);

        if (sp < 0.5) {
          for (let vr = 1; vr <= 4; vr++) {
            ctx.strokeStyle = `rgba(136,68,255,${0.3/vr})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(phoneX + buzz, phoneY + 20, 20 + vr*10 + Math.sin(t*8)*4, 0, Math.PI*2);
            ctx.stroke();
          }
        }

        const phase = sp > 0.5;
        ctx.textAlign = 'center';
        if (!phase) {
          ctx.fillStyle = '#ffcc88';
          ctx.font = `italic ${Math.min(18, W*0.025)}px monospace`;
          ctx.fillText('*phone buzzes on the gold desk*', W/2, H * 0.8);
        } else {
          ctx.fillStyle = '#ff4400';
          ctx.font = `bold italic ${Math.min(22, W*0.03)}px monospace`;
          ctx.shadowColor = '#ff4400';
          ctx.shadowBlur = 20;
          const line = '"I never left. Let\'s finish this."';
          const chars = Math.floor(line.length * Math.min(1, (sp-0.5)*4));
          ctx.fillText(line.substring(0, chars), W/2, H * 0.8);
          ctx.shadowBlur = 0;

          if (chars < line.length && Math.sin(t*10) > 0) {
            const m3 = ctx.measureText(line.substring(0, chars));
            ctx.fillRect(W/2 + m3.width/2 + 2, H*0.8 - 16, 2, 20);
          }
        }

        ctx.globalAlpha = 0.5;
        const tVig = ctx.createRadialGradient(W/2, H/2, H*0.25, W/2, H/2, H*0.75);
        tVig.addColorStop(0, 'rgba(0,0,0,0)');
        tVig.addColorStop(1, 'rgba(0,0,0,0.6)');
        ctx.fillStyle = tVig;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      if (prog >= 0.24 && prog < 0.34) {
        const sp = (prog - 0.24) / 0.1;
        ctx.save();

        const techGrad = ctx.createLinearGradient(0, 0, W, H);
        techGrad.addColorStop(0, '#000a1a');
        techGrad.addColorStop(0.3, '#001133');
        techGrad.addColorStop(0.7, '#001540');
        techGrad.addColorStop(1, '#000a1a');
        ctx.fillStyle = techGrad;
        ctx.fillRect(0, 0, W, H);

        ctx.strokeStyle = '#4488ff08';
        ctx.lineWidth = 1;
        for (let pnl = 0; pnl < 6; pnl++) {
          const px = pnl * W/6;
          ctx.strokeRect(px + 5, 5, W/6 - 10, H - 10);

          ctx.fillStyle = '#4488ff10';
          ctx.beginPath(); ctx.arc(px + 12, 12, 3, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(px + W/6 - 7, 12, 3, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(px + 12, H - 12, 3, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(px + W/6 - 7, H - 12, 3, 0, Math.PI*2); ctx.fill();
        }

        ctx.strokeStyle = '#4488ff0a';
        ctx.lineWidth = 1;
        for (let i = 0; i < 30; i++) {
          ctx.beginPath();
          ctx.moveTo(0, H * (i/30));
          ctx.lineTo(W, H * (i/30));
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(W * (i/30), 0);
          ctx.lineTo(W * (i/30), H);
          ctx.stroke();
        }

        for (let ds = 0; ds < 8; ds++) {
          const dsx = (ds * W/8 + t * 30) % W;
          ctx.fillStyle = `rgba(68,136,255,${0.08 + Math.sin(t+ds)*0.04})`;
          ctx.fillRect(dsx, 0, 2, H);
        }

        ctx.fillStyle = '#060e1a';
        ctx.fillRect(0, H*0.7, W, H*0.3);
        ctx.strokeStyle = '#4488ff08';
        for (let fl = 0; fl < W; fl += 80) {
          ctx.beginPath(); ctx.moveTo(fl, H*0.7); ctx.lineTo(fl, H); ctx.stroke();
        }

        ctx.fillStyle = `rgba(68,136,255,${0.15 + Math.sin(t*2)*0.1})`;
        ctx.fillRect(0, H*0.7, W, 2);

        ctx.fillStyle = '#001a33dd';
        ctx.fillRect(W*0.25, H*0.05, W*0.5, 30);
        ctx.strokeStyle = '#4488ff66';
        ctx.lineWidth = 1;
        ctx.strokeRect(W*0.25, H*0.05, W*0.5, 30);

        const scanX = (t * 60) % (W*0.5);
        ctx.fillStyle = '#4488ff22';
        ctx.fillRect(W*0.25 + scanX, H*0.05, 30, 30);
        ctx.fillStyle = '#88ccff';
        ctx.font = `bold ${Math.min(14, W*0.02)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('SPACEX HQ - CLASSIFIED LABORATORY LVL.7', W/2, H*0.05 + 20);

        ctx.fillStyle = '#001020';
        ctx.fillRect(W*0.05, H*0.15, W*0.35, H*0.48);
        ctx.strokeStyle = '#4488ff55';
        ctx.lineWidth = 2;
        ctx.strokeRect(W*0.05, H*0.15, W*0.35, H*0.48);

        ctx.fillStyle = '#4488ff22';
        ctx.fillRect(W*0.05, H*0.15, W*0.35, 18);
        ctx.fillStyle = '#4488ff';
        ctx.font = '8px monospace';
        ctx.textAlign = 'left';
        ctx.fillText('■ NEURALINK COMBAT SYS v4.2.0', W*0.07, H*0.15 + 12);

        ctx.fillStyle = '#44ff88';
        ctx.beginPath(); ctx.arc(W*0.38, H*0.15 + 9, 3, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = '#4488ff';
        ctx.font = '8px monospace';
        const codeLines = ['>> NEURAL_LINK_v','>> COMBAT_AI_mod.','>> WEAPONS_SYS.','>> SHIELD_GEN.','>> TARGET_ACQ.','>> MOBILITY.','>> PROJECTILE.','>> HOMING_v','>> BURST_FIRE.','>> DASH_PROTO.','>> UPLOAD_ALL.','>> STATUS:'];
        for (let l = 0; l < 12; l++) {
          ctx.globalAlpha = 0.3 + Math.sin(l + t*3) * 0.2;
          ctx.textAlign = 'left';
          const codeTxt = codeLines[l] + (l+1) + '.INIT()';
          ctx.fillText(codeTxt, W*0.07, H*0.19 + l * 16);

          const prog2 = Math.min(1, (sp * 2 + Math.sin(l + t*2) * 0.3));
          ctx.fillStyle = '#4488ff22';
          ctx.fillRect(W*0.28, H*0.185 + l * 16, 50, 8);
          ctx.fillStyle = l === 11 ? '#44ff88' : '#4488ff';
          ctx.fillRect(W*0.28, H*0.185 + l * 16, 50 * prog2, 8);
          ctx.fillStyle = '#4488ff';
        }
        ctx.globalAlpha = 1;

        ctx.fillStyle = '#001020';
        ctx.fillRect(W*0.05, H*0.66, W*0.17, H*0.14);
        ctx.strokeStyle = '#4488ff33';
        ctx.lineWidth = 1;
        ctx.strokeRect(W*0.05, H*0.66, W*0.17, H*0.14);

        ctx.strokeStyle = '#44ff8844';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let wf = 0; wf < 60; wf++) {
          const wx = W*0.05 + wf * (W*0.17/60);
          const wy = H*0.73 + Math.sin(wf*0.5 + t*4) * 15;
          wf === 0 ? ctx.moveTo(wx, wy) : ctx.lineTo(wx, wy);
        }
        ctx.stroke();

        const mSize = Math.min(W * 0.24, 170);
        ctx.globalAlpha = Math.min(1, sp * 2);
        ctx.shadowColor = '#4488ff';
        ctx.shadowBlur = 40;
        ctx.drawImage(muskImg, W * 0.65 - mSize/2, H * 0.15, mSize, imgH(muskImg, mSize));
        ctx.shadowBlur = 0;

        if (sp > 0.2) {
          ctx.strokeStyle = '#4488ff44';
          ctx.lineWidth = 4;
          const armAngle = Math.sin(t*0.8) * 0.3;
          ctx.save();
          ctx.translate(W*0.85, H*0.12);
          ctx.rotate(armAngle);
          ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 80); ctx.stroke();
          ctx.translate(0, 80);
          ctx.rotate(armAngle * 1.5);
          ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 60); ctx.stroke();

          ctx.beginPath(); ctx.moveTo(-8, 60); ctx.lineTo(0, 70); ctx.lineTo(8, 60); ctx.stroke();

          ctx.fillStyle = '#4488ff33';
          ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI*2); ctx.fill();
          ctx.restore();

          ctx.fillStyle = '#4488ff22';
          ctx.fillRect(W*0.83, H*0.1, 25, 12);
        }

        ctx.globalAlpha = 0.06 + Math.sin(t)*0.03;
        ctx.fillStyle = '#4488ff';
        ctx.fillRect(W*0.78, H*0.52 + Math.sin(t*1.5)*8, 40, 18);
        ctx.fillRect(W*0.82, H*0.48 + Math.sin(t*1.5)*8, 25, 12);

        ctx.beginPath(); ctx.arc(W*0.82, H*0.71 + Math.sin(t*1.5)*8, 5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(W*0.815, H*0.71 + Math.sin(t*1.5)*8, 5, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;

        const phase = sp > 0.5;
        ctx.textAlign = 'center';
        if (!phase) {
          ctx.fillStyle = '#88ccff';
          ctx.font = `italic ${Math.min(18, W*0.025)}px monospace`;
          ctx.fillText('*encrypted transmission received*', W/2, H * 0.8);

          ctx.fillStyle = '#001a33ee';
          ctx.fillRect(W*0.3, H*0.84, W*0.4, 48);
          ctx.strokeStyle = '#4488ff44';
          ctx.strokeRect(W*0.3, H*0.84, W*0.4, 48);

          ctx.fillStyle = '#ff8844';
          ctx.font = 'bold 14px monospace';
          ctx.fillText('⚠', W*0.33, H*0.84 + 20);
          ctx.fillStyle = '#4488ff';
          ctx.font = '9px monospace';
          ctx.fillText('FROM: [REDACTED] | PRIORITY: OMEGA', W/2, H*0.84 + 16);
          ctx.fillStyle = '#88ccff';
          ctx.fillText('CABAL_REGROUP.exe — DECRYPT & EXECUTE?', W/2, H*0.84 + 30);
          ctx.fillStyle = '#44ff88';
          ctx.font = '8px monospace';
          ctx.fillText('[Y] CONFIRM    [N] DENY', W/2, H*0.84 + 42);
        } else {
          ctx.fillStyle = '#4488ff';
          ctx.font = `bold italic ${Math.min(22, W*0.03)}px monospace`;
          ctx.shadowColor = '#4488ff';
          ctx.shadowBlur = 20;
          const line = '"Finally. Uploading combat protocols."';
          const chars = Math.floor(line.length * Math.min(1, (sp-0.5)*4));
          ctx.fillText(line.substring(0, chars), W/2, H * 0.82);
          ctx.shadowBlur = 0;
          if (chars < line.length && Math.sin(t*10) > 0) {
            const m4 = ctx.measureText(line.substring(0, chars));
            ctx.fillRect(W/2 + m4.width/2 + 2, H*0.82 - 16, 2, 20);
          }
        }

        ctx.globalAlpha = 0.04;
        for (let sl = 0; sl < H; sl += 3) {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, sl, W, 1);
        }
        ctx.globalAlpha = 1;

        ctx.fillStyle = `rgba(68,136,255,${0.06 + Math.sin(t*1.5)*0.03})`;
        ctx.fillRect(0, 0, W, 4);
        ctx.fillRect(0, H*0.7 - 3, W, 3);

        ctx.globalAlpha = 0.4;
        const mVig = ctx.createRadialGradient(W/2, H/2, H*0.25, W/2, H/2, H*0.8);
        mVig.addColorStop(0, 'rgba(0,0,0,0)');
        mVig.addColorStop(1, 'rgba(0,0,0,0.7)');
        ctx.fillStyle = mVig;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      if (prog >= 0.34 && prog < 0.44) {
        const sp = (prog - 0.34) / 0.1;
        ctx.save();

        const offGrad = ctx.createRadialGradient(W*0.4, H*0.4, 100, W*0.4, H*0.4, H);
        offGrad.addColorStop(0, '#2a0a0a');
        offGrad.addColorStop(0.5, '#1a0505');
        offGrad.addColorStop(1, '#0a0202');
        ctx.fillStyle = offGrad;
        ctx.fillRect(0, 0, W, H);

        for (let wp = 0; wp < 14; wp++) {
          const wpx = W * (wp/14);
          const wpw = W/14;
          ctx.fillStyle = wp % 2 === 0 ? '#1a0808' : '#180707';
          ctx.fillRect(wpx, 0, wpw, H*0.68);
          ctx.strokeStyle = '#33111120';
          ctx.lineWidth = 1;
          ctx.strokeRect(wpx, 0, wpw, H*0.68);

          for (let wgl = 0; wgl < 8; wgl++) {
            ctx.strokeStyle = '#ffffff03';
            ctx.beginPath();
            ctx.moveTo(wpx + 3, wgl * H*0.085);
            ctx.lineTo(wpx + wpw - 3, wgl * H*0.085 + Math.sin(wp+wgl)*3);
            ctx.stroke();
          }
        }

        for (let shelf = 0; shelf < 3; shelf++) {
          const shelfY = H*0.12 + shelf * H*0.18;

          ctx.fillStyle = '#2a1212';
          ctx.fillRect(W*0.7, shelfY + H*0.14, W*0.26, 4);

          for (let bk = 0; bk < 10; bk++) {
            const bookCol = ['#331818','#222833','#2a2218','#1a2a28','#2a1a2a','#282218','#1a1830','#301818','#182a1a','#221a2a'][bk];
            const bookH = 25 + Math.sin(bk*3.7+shelf) * 8;
            ctx.fillStyle = bookCol;
            ctx.fillRect(W*0.71 + bk*22, shelfY + H*0.14 - bookH, 18, bookH);

            ctx.fillStyle = '#ffffff08';
            ctx.fillRect(W*0.71 + bk*22 + 8, shelfY + H*0.14 - bookH + 3, 1, bookH - 6);
          }
        }

        ctx.fillStyle = '#1a0808';
        ctx.fillRect(0, H*0.68, W, H*0.32);

        ctx.strokeStyle = '#cc222208';
        ctx.lineWidth = 1;
        for (let cp = 0; cp < W; cp += 30) {
          for (let cp2 = 0; cp2 < H*0.32; cp2 += 30) {
            ctx.strokeRect(cp, H*0.68 + cp2, 28, 28);
          }
        }

        ctx.fillStyle = '#1a0a0a';
        ctx.fillRect(W*0.02, H*0.28, W*0.14, H*0.35);
        ctx.fillStyle = '#120606';
        ctx.fillRect(W*0.04, H*0.32, W*0.1, H*0.25);

        ctx.fillStyle = '#2a1414';
        ctx.fillRect(W*0.01, H*0.26, W*0.16, H*0.03);

        const fireGlow = ctx.createRadialGradient(W*0.09, H*0.5, 5, W*0.09, H*0.5, 80);
        fireGlow.addColorStop(0, `rgba(255,100,30,${0.12 + Math.sin(t*6)*0.06})`);
        fireGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = fireGlow;
        ctx.fillRect(0, H*0.3, W*0.25, H*0.4);

        for (let fl = 0; fl < 5; fl++) {
          const flx = W*0.05 + fl * W*0.02;
          const flh = 15 + Math.sin(t*8 + fl*2) * 10;
          ctx.fillStyle = `rgba(255,${80+fl*20},0,${0.3 + Math.sin(t*10+fl)*0.15})`;
          ctx.beginPath();
          ctx.moveTo(flx, H*0.57);
          ctx.quadraticCurveTo(flx + 4, H*0.57 - flh, flx + 8, H*0.57);
          ctx.fill();
        }

        ctx.fillStyle = '#2a1818';
        ctx.beginPath(); ctx.arc(W*0.09, H*0.24, 12, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#ffcc4422';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(W*0.09, H*0.24, 12, 0, Math.PI*2); ctx.stroke();

        ctx.strokeStyle = '#ffcc4444';
        ctx.beginPath(); ctx.moveTo(W*0.09, H*0.24); ctx.lineTo(W*0.09, H*0.24-8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.09, H*0.24); ctx.lineTo(W*0.09+5, H*0.24+2); ctx.stroke();

        ctx.fillStyle = '#cc222240';
        ctx.fillRect(W*0.25, H*0.05, W*0.5, 30);
        ctx.strokeStyle = '#cc222266';
        ctx.lineWidth = 1;
        ctx.strokeRect(W*0.25, H*0.05, W*0.5, 30);
        ctx.fillStyle = '#ff6666';
        ctx.font = `bold ${Math.min(14, W*0.02)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('UNDISCLOSED LOCATION - WASHINGTON, D.C.', W/2, H*0.05 + 20);

        const cSize = Math.min(W * 0.25, 175);
        ctx.globalAlpha = Math.min(1, sp * 2);
        ctx.shadowColor = '#cc2222';
        ctx.shadowBlur = 40;
        ctx.drawImage(clintonImg, W * 0.38 - cSize/2, H * 0.15, cSize, imgH(clintonImg, cSize));
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#2a1515';
        ctx.fillRect(W*0.52, H*0.4, W*0.4, H*0.22);
        ctx.strokeStyle = '#cc222220';
        ctx.lineWidth = 2;
        ctx.strokeRect(W*0.52, H*0.4, W*0.4, H*0.22);

        ctx.fillStyle = '#221010';
        ctx.fillRect(W*0.54, H*0.62, 10, H*0.1);
        ctx.fillRect(W*0.89, H*0.62, 10, H*0.1);

        ctx.fillStyle = '#1a0a0a';
        ctx.fillRect(W*0.86, H*0.28, 6, H*0.12);
        ctx.fillStyle = '#2a1818';
        ctx.beginPath(); ctx.moveTo(W*0.82, H*0.28); ctx.lineTo(W*0.93, H*0.28); ctx.lineTo(W*0.89, H*0.22); ctx.closePath(); ctx.fill();

        const lampGlow = ctx.createRadialGradient(W*0.89, H*0.35, 5, W*0.89, H*0.35, 80);
        lampGlow.addColorStop(0, 'rgba(255,200,100,0.08)');
        lampGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = lampGlow;
        ctx.fillRect(W*0.78, H*0.25, W*0.2, H*0.3);

        for (let d = 0; d < 7; d++) {
          ctx.save();
          ctx.translate(W*0.56 + d*35, H*0.42 + Math.sin(d*2.3)*8);
          ctx.rotate((d-3)*0.08);
          ctx.fillStyle = '#f0e8d0';
          ctx.fillRect(0, 0, 28, 38);

          ctx.fillStyle = '#cc222288';
          ctx.font = 'bold 5px monospace';
          ctx.textAlign = 'center';
          ctx.fillText('TOP', 14, 13);
          ctx.fillText('SECRET', 14, 20);

          ctx.fillStyle = '#222';
          for (let rl = 0; rl < 3; rl++) {
            ctx.fillRect(4, 25 + rl*4, 20, 2);
          }
          ctx.restore();
        }

        ctx.strokeStyle = '#88333344';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(W*0.58, H*0.44);
        ctx.quadraticCurveTo(W*0.583, H*0.38, W*0.585, H*0.34);
        ctx.stroke();

        ctx.strokeStyle = '#88333330';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(W*0.585, H*0.32, 10, 14, 0, 0, Math.PI*2);
        ctx.stroke();

        ctx.fillStyle = '#661818';
        ctx.beginPath();
        ctx.ellipse(W*0.585, H*0.34, 8, 5, 0, 0, Math.PI);
        ctx.fill();

        ctx.fillStyle = '#88333330';
        ctx.fillRect(W*0.575, H*0.44, 12, 3);

        ctx.fillStyle = '#2a1818';
        ctx.fillRect(W*0.84, H*0.36, 22, 28);
        ctx.fillStyle = '#1a1010';
        ctx.fillRect(W*0.845, H*0.365, 18, 22);

        const phase = sp > 0.5;
        ctx.textAlign = 'center';
        if (!phase) {
          ctx.fillStyle = '#ff8888';
          ctx.font = `italic ${Math.min(18, W*0.025)}px monospace`;
          ctx.fillText('*a familiar number appears*', W/2, H * 0.8);

          ctx.fillStyle = '#1a0a0a';
          ctx.fillRect(W*0.76, H*0.43, 35, 22);

          ctx.fillStyle = '#120808';
          ctx.fillRect(W*0.765, H*0.41, 30, 8);
          const phonePulse = Math.sin(t*8) * 0.3 + 0.5;

          ctx.fillStyle = `rgba(204,34,34,${phonePulse})`;
          ctx.beginPath(); ctx.arc(W*0.78, H*0.45, 3, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = '#fff';
          ctx.font = '4px monospace';
          ctx.fillText('LINE 1', W*0.78, H*0.455 + 8);
        } else {
          ctx.fillStyle = '#cc2222';
          ctx.font = `bold italic ${Math.min(22, W*0.03)}px monospace`;
          ctx.shadowColor = '#cc2222';
          ctx.shadowBlur = 20;
          const line = '"Some things never stay buried."';
          const chars = Math.floor(line.length * Math.min(1, (sp-0.5)*4));
          ctx.fillText(line.substring(0, chars), W/2, H * 0.82);
          ctx.shadowBlur = 0;
          if (chars < line.length && Math.sin(t*10) > 0) {
            const m5 = ctx.measureText(line.substring(0, chars));
            ctx.fillRect(W/2 + m5.width/2 + 2, H*0.82 - 16, 2, 20);
          }
        }

        ctx.globalAlpha = 0.55;
        const cVig = ctx.createRadialGradient(W*0.4, H*0.4, H*0.2, W*0.4, H*0.4, H*0.8);
        cVig.addColorStop(0, 'rgba(0,0,0,0)');
        cVig.addColorStop(1, 'rgba(0,0,0,0.8)');
        ctx.fillStyle = cVig;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      if (prog >= 0.44 && prog < 0.59) {
        const sp = (prog - 0.44) / 0.15;
        ctx.save();

        const graveGrad = ctx.createLinearGradient(0, 0, 0, H);
        graveGrad.addColorStop(0, '#020208');
        graveGrad.addColorStop(0.3, '#060612');
        graveGrad.addColorStop(0.7, '#0a0a18');
        graveGrad.addColorStop(1, '#0e0e14');
        ctx.fillStyle = graveGrad;
        ctx.fillRect(0, 0, W, H);

        for (let star = 0; star < 60; star++) {
          const sx = (star * 97.3) % W;
          const sy = (star * 53.7) % (H * 0.45);
          const twinkle = Math.sin(t*2 + star*1.7) * 0.3 + 0.5;
          const starSize = (star % 3 === 0) ? 2 : 1;
          ctx.fillStyle = `rgba(200,200,220,${twinkle * (star % 5 === 0 ? 0.5 : 0.25)})`;
          ctx.fillRect(sx, sy, starSize, starSize);

          if (star % 7 === 0) {
            ctx.fillRect(sx - 1, sy, 3, 1);
            ctx.fillRect(sx, sy - 1, 1, 3);
          }
        }

        const shootStar = (t * 0.3) % 3;
        if (shootStar < 0.5) {
          const ssX = W * 0.9 - shootStar * W * 0.6;
          const ssY = H * 0.05 + shootStar * H * 0.15;
          ctx.strokeStyle = `rgba(220,220,255,${(0.5 - shootStar) * 1.5})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(ssX, ssY);
          ctx.lineTo(ssX + 40, ssY - 8);
          ctx.stroke();
        }

        for (let cl = 0; cl < 4; cl++) {
          const cx3 = (cl * 400 + t * (8 + cl*3)) % (W + 300) - 150;
          const cy3 = H * 0.08 + cl * 40;
          ctx.fillStyle = `rgba(10,10,20,${0.3 + cl*0.05})`;
          ctx.beginPath();
          ctx.ellipse(cx3, cy3, 120 + cl*20, 25 + cl*5, 0, 0, Math.PI*2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(cx3 + 60, cy3 - 10, 80, 20, 0, 0, Math.PI*2);
          ctx.fill();
        }

        const moonX = W * 0.82, moonY = H * 0.1;

        const moonHalo = ctx.createRadialGradient(moonX, moonY, 30, moonX, moonY, 120);
        moonHalo.addColorStop(0, 'rgba(180,180,200,0.08)');
        moonHalo.addColorStop(0.5, 'rgba(100,100,140,0.03)');
        moonHalo.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = moonHalo;
        ctx.fillRect(moonX - 120, moonY - 120, 240, 240);

        ctx.fillStyle = '#445';
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(moonX, moonY, 35, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#556';
        ctx.globalAlpha = 0.25;
        ctx.beginPath();
        ctx.arc(moonX - 3, moonY - 2, 32, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.globalAlpha = 0.04;
        ctx.fillStyle = '#aabbcc';
        ctx.beginPath();
        ctx.moveTo(moonX - 20, moonY + 35);
        ctx.lineTo(W/2 - 80, H * 0.7);
        ctx.lineTo(W/2 + 80, H * 0.7);
        ctx.lineTo(moonX + 20, moonY + 35);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.strokeStyle = 'rgba(150,160,180,0.15)';
        ctx.lineWidth = 1;
        for (let rain = 0; rain < 60; rain++) {
          const rx = (rain * 43.7 + t * 80) % (W + 100) - 50;
          const ry = (rain * 67.3 + t * 250) % (H + 50) - 25;
          ctx.beginPath();
          ctx.moveTo(rx, ry);
          ctx.lineTo(rx - 2, ry + 12);
          ctx.stroke();
        }

        const fogY = H * 0.62;
        for (let fg = 0; fg < 10; fg++) {
          const fgx = (fg * W/10 + Math.sin(t*0.3 + fg) * 50) % W;
          const fogGrad = ctx.createRadialGradient(fgx, fogY + 20, 10, fgx, fogY + 20, 120 + fg*15);
          fogGrad.addColorStop(0, `rgba(15,15,25,${0.15 + Math.sin(t*0.5+fg)*0.05})`);
          fogGrad.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = fogGrad;
          ctx.fillRect(fgx - 140, fogY - 40, 280, 120);
        }

        ctx.globalAlpha = 0.06;
        for (let mt = 0; mt < 15; mt++) {
          const mtx = (mt * 97 + t * 12) % W;
          const mty = fogY + 30 + Math.sin(t*0.8+mt)*15;
          ctx.fillStyle = '#aabbcc';
          ctx.beginPath();
          ctx.ellipse(mtx, mty, 50 + mt*5, 4, 0, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        const groundY = H * 0.7;
        ctx.fillStyle = '#121218';
        ctx.fillRect(0, groundY, W, H - groundY);

        ctx.fillStyle = '#18181e';
        ctx.fillRect(W*0.35, groundY, W*0.3, H - groundY);

        ctx.strokeStyle = '#1a2a1a';
        ctx.lineWidth = 1;
        for (let gs = 0; gs < 40; gs++) {
          const gsx = gs * W/40 + Math.sin(gs*4)*5;
          for (let gb = 0; gb < 3; gb++) {
            ctx.beginPath();
            ctx.moveTo(gsx + gb*3, groundY);
            ctx.lineTo(gsx + gb*3 + Math.sin(t+gs+gb)*2, groundY - 4 - Math.random()*4);
            ctx.stroke();
          }
        }

        ctx.fillStyle = '#ffffff02';
        for (let dt = 0; dt < 50; dt++) {
          ctx.fillRect((dt * 73) % W, groundY + (dt * 37) % (H*0.3), 1, 1);
        }

        ctx.strokeStyle = '#1a1a22';
        ctx.lineWidth = 6;
        ctx.beginPath(); ctx.moveTo(W*0.12, groundY); ctx.lineTo(W*0.11, groundY - 140); ctx.stroke();
        ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(W*0.11, groundY - 100); ctx.lineTo(W*0.06, groundY - 160); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.11, groundY - 80); ctx.lineTo(W*0.16, groundY - 130); ctx.stroke();
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(W*0.06, groundY - 160); ctx.lineTo(W*0.04, groundY - 175); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.06, groundY - 160); ctx.lineTo(W*0.08, groundY - 180); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.16, groundY - 130); ctx.lineTo(W*0.18, groundY - 150); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.16, groundY - 130); ctx.lineTo(W*0.15, groundY - 155); ctx.stroke();

        ctx.lineWidth = 5;
        ctx.beginPath(); ctx.moveTo(W*0.92, groundY); ctx.lineTo(W*0.91, groundY - 120); ctx.stroke();
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(W*0.91, groundY - 80); ctx.lineTo(W*0.95, groundY - 140); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.91, groundY - 90); ctx.lineTo(W*0.87, groundY - 130); ctx.stroke();

        ctx.strokeStyle = '#222230';
        ctx.lineWidth = 2;
        const fenceY = groundY - 5;

        ctx.beginPath(); ctx.moveTo(0, fenceY - 25); ctx.lineTo(W*0.3, fenceY - 25); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.7, fenceY - 25); ctx.lineTo(W, fenceY - 25); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, fenceY - 10); ctx.lineTo(W*0.3, fenceY - 10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.7, fenceY - 10); ctx.lineTo(W, fenceY - 10); ctx.stroke();

        for (let fp = 0; fp < 20; fp++) {
          const fpx = fp * W/20 + 10;
          if (fpx < W*0.3 || fpx > W*0.7) {
            ctx.beginPath(); ctx.moveTo(fpx, fenceY); ctx.lineTo(fpx, fenceY - 35); ctx.stroke();

            ctx.beginPath(); ctx.moveTo(fpx-3, fenceY - 35); ctx.lineTo(fpx, fenceY - 42); ctx.lineTo(fpx+3, fenceY - 35); ctx.closePath();
            ctx.fillStyle = '#222230'; ctx.fill();
          }
        }

        ctx.fillStyle = '#1e1e26';
        for (let g = 0; g < 8; g++) {
          const gx = W * 0.05 + g * W * 0.125;
          if (Math.abs(gx - W/2) > 90) {
            const gh = 28 + g*4;

            ctx.fillRect(gx - 12, groundY - gh, 24, gh);
            ctx.beginPath();
            ctx.arc(gx, groundY - gh, 12, Math.PI, 0);
            ctx.fill();

            if (g % 3 === 0) {
              ctx.fillStyle = '#2a2a34';
              ctx.fillRect(gx - 2, groundY - gh - 18, 4, 22);
              ctx.fillRect(gx - 8, groundY - gh - 10, 16, 4);
              ctx.fillStyle = '#1e1e26';
            }

            if (g % 2 === 0) {
              ctx.fillStyle = '#2a1a2a';
              ctx.beginPath(); ctx.arc(gx + 15, groundY - 3, 4, 0, Math.PI*2); ctx.fill();
              ctx.fillStyle = '#1e1e26';
            }
          }
        }

        const gsX = W/2, gsY = groundY;

        ctx.fillStyle = '#0a0a10';
        ctx.beginPath();
        ctx.ellipse(gsX, gsY + 5, 50, 8, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = '#222228';
        ctx.fillRect(gsX - 45, gsY - 8, 90, 12);

        ctx.fillStyle = '#2a2a30';
        ctx.fillRect(gsX - 38, gsY - 90, 76, 86);
        ctx.beginPath();
        ctx.arc(gsX, gsY - 90, 38, Math.PI, 0);
        ctx.fill();

        ctx.fillStyle = '#1a2818';
        ctx.globalAlpha = 0.2;
        ctx.fillRect(gsX - 35, gsY - 30, 15, 25);
        ctx.fillRect(gsX + 15, gsY - 50, 12, 35);
        ctx.globalAlpha = 1;

        ctx.strokeStyle = '#3a3a44';
        ctx.lineWidth = 1;
        ctx.strokeRect(gsX - 32, gsY - 83, 64, 75);

        ctx.fillStyle = '#3a3a44';
        ctx.fillRect(gsX - 3, gsY - 120, 6, 22);
        ctx.fillRect(gsX - 10, gsY - 112, 20, 5);

        ctx.fillStyle = '#606068';
        ctx.font = `bold ${Math.min(12, W*0.016)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('STEPHEN', gsX, gsY - 65);
        ctx.fillText('WILLIAM', gsX, gsY - 52);
        ctx.fillText('HAWKING', gsX, gsY - 39);
        ctx.fillStyle = '#4a4a52';
        ctx.font = `${Math.min(9, W*0.012)}px monospace`;
        ctx.fillText('CH CBE FRS FRSA', gsX, gsY - 24);
        ctx.fillText('1942 - 2018', gsX, gsY - 12);

        ctx.fillStyle = '#38383f';
        ctx.font = `italic ${Math.min(7, W*0.009)}px monospace`;
        ctx.fillText('AD ASTRA PER ASPERA', gsX, gsY - 1);

        ctx.fillStyle = '#2a1a2a';
        ctx.beginPath(); ctx.arc(gsX - 25, gsY - 5, 6, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(gsX - 18, gsY - 8, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#1a2818';
        ctx.fillRect(gsX - 28, gsY - 5, 3, 10);
        ctx.fillRect(gsX - 22, gsY - 8, 2, 12);

        const phoneBuzz = sp > 0.15 && sp < 0.45;
        const buzzOff = phoneBuzz ? Math.sin(t * 25) * 4 : 0;
        ctx.fillStyle = '#222';
        ctx.fillRect(gsX + 40 + buzzOff, gsY - 30, 22, 35);
        if (phoneBuzz) {

          ctx.fillStyle = `rgba(255,200,0,${0.4 + Math.sin(t*8)*0.3})`;
          ctx.fillRect(gsX + 42 + buzzOff, gsY - 28, 18, 25);
          ctx.fillStyle = '#fff';
          ctx.font = '5px monospace';
          ctx.fillText('CALL', gsX + 51 + buzzOff, gsY - 15);

          ctx.strokeStyle = `rgba(255,200,0,${Math.sin(t*12)*0.3})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(gsX + 51 + buzzOff, gsY - 12, 20 + Math.sin(t*10)*5, 0, Math.PI*2);
          ctx.stroke();
        }

        if (sp > 0.4) {
          const crackProg = (sp - 0.4) / 0.3;

          ctx.strokeStyle = `rgba(255,200,0,${Math.min(0.8, crackProg)})`;
          ctx.lineWidth = 2 + crackProg * 2;
          const crackLen = crackProg * 200;

          ctx.beginPath();
          ctx.moveTo(gsX - 20, gsY);
          ctx.lineTo(gsX - 20 - crackLen * 0.4, gsY + crackLen * 0.1);
          ctx.lineTo(gsX - 20 - crackLen * 0.7, gsY + crackLen * 0.05);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(gsX + 20, gsY);
          ctx.lineTo(gsX + 20 + crackLen * 0.5, gsY + crackLen * 0.08);
          ctx.lineTo(gsX + 20 + crackLen * 0.8, gsY - crackLen * 0.03);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(gsX, gsY);
          ctx.lineTo(gsX + crackLen * 0.1, gsY + crackLen * 0.3);
          ctx.stroke();

          const glowAlpha = crackProg * 0.5;
          const underGlow = ctx.createRadialGradient(gsX, gsY + 10, 5, gsX, gsY + 10, 100 + crackProg * 100);
          underGlow.addColorStop(0, `rgba(255,200,0,${glowAlpha})`);
          underGlow.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = underGlow;
          ctx.fillRect(gsX - 200, gsY - 50, 400, 150);

          if (crackProg > 0.3) {
            const shk = crackProg * 1.5;
            ctx.translate(Math.sin(t*30)*shk, Math.cos(t*25)*shk);
          }
        }

        if (sp > 0.7) {
          const riseProg = (sp - 0.7) / 0.3;

          if (riseProg < 0.08) {
            ctx.fillStyle = `rgba(255,200,0,${(0.08 - riseProg) * 8})`;
            ctx.fillRect(0, 0, W, H);
          }

          if (riseProg > 0.15 && riseProg < 0.2) {
            ctx.fillStyle = `rgba(255,255,255,${(0.2 - riseProg) * 12})`;
            ctx.fillRect(0, 0, W, H);
          }

          const shk = riseProg * 3;
          ctx.translate(Math.sin(t*35)*shk, Math.cos(t*28)*shk);

          if (riseProg > 0.1) {
            const pillarAlpha = Math.min(0.4, (riseProg - 0.1) * 0.8);
            const pillarGrad = ctx.createLinearGradient(gsX - 40, 0, gsX + 40, 0);
            pillarGrad.addColorStop(0, 'rgba(0,0,0,0)');
            pillarGrad.addColorStop(0.3, `rgba(255,200,0,${pillarAlpha * 0.5})`);
            pillarGrad.addColorStop(0.5, `rgba(255,200,0,${pillarAlpha})`);
            pillarGrad.addColorStop(0.7, `rgba(255,200,0,${pillarAlpha * 0.5})`);
            pillarGrad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = pillarGrad;
            ctx.fillRect(gsX - 80, 0, 160, gsY);
          }

          const riseY = gsY - riseProg * 160;
          const hSize = Math.min(W * 0.25, 180);
          ctx.globalAlpha = Math.min(1, riseProg * 2);

          for (let aLayer = 0; aLayer < 3; aLayer++) {
            const aRad = hSize * (1.2 + aLayer * 0.5);
            const hAura = ctx.createRadialGradient(gsX, riseY + hSize*0.5, 10, gsX, riseY + hSize*0.5, aRad);
            hAura.addColorStop(0, `rgba(255,200,0,${(0.3 - aLayer*0.08) * riseProg})`);
            hAura.addColorStop(0.5, `rgba(255,200,0,${(0.1 - aLayer*0.03) * riseProg})`);
            hAura.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = hAura;
            ctx.beginPath();
            ctx.arc(gsX, riseY + hSize*0.5, aRad, 0, Math.PI*2);
            ctx.fill();
          }

          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 50 + riseProg * 60;
          ctx.drawImage(hawkingGoldImg, gsX - hSize/2, riseY, hSize, imgH(hawkingGoldImg, hSize));
          ctx.drawImage(hawkingGoldImg, gsX - hSize/2, riseY, hSize, imgH(hawkingGoldImg, hSize));
          ctx.shadowBlur = 0;

          ctx.globalAlpha = 1;

          ctx.fillStyle = '#121218';
          ctx.fillRect(0, gsY, W, H - gsY);

          ctx.fillStyle = '#18181e';
          ctx.fillRect(W*0.35, gsY, W*0.3, H - gsY);

          ctx.fillStyle = '#121218';
          ctx.beginPath();
          ctx.ellipse(gsX, gsY + 5, 100, 18, 0, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = '#1a1a20';
          ctx.beginPath();
          ctx.ellipse(gsX, gsY + 2, 70, 12, 0, 0, Math.PI*2);
          ctx.fill();

          ctx.fillStyle = '#ffffff02';
          for (let dt = 0; dt < 50; dt++) {
            ctx.fillRect((dt * 73) % W, gsY + (dt * 37) % (H*0.3), 1, 1);
          }

          for (let d = 0; d < 16; d++) {
            const dAngle = (d / 16) * Math.PI * 2 + t * 2;
            const dDist = 30 + d * 12 + Math.sin(t*3 + d) * 15;
            const dx = gsX + Math.cos(dAngle) * dDist;
            const dy = gsY - riseProg * (20 + d*15) + Math.sin(d + t*4) * 12;
            ctx.fillStyle = d % 3 === 0 ? '#4a4a40' : '#2a2a20';
            ctx.globalAlpha = Math.max(0, 1 - riseProg * 1.2);
            const dSize = 3 + d%5;
            ctx.save();
            ctx.translate(dx, dy);
            ctx.rotate(t * 3 + d);
            ctx.fillRect(-dSize/2, -dSize/2, dSize, dSize * 0.7);
            ctx.restore();
          }
          ctx.globalAlpha = 1;

          if (riseProg > 0.2) {
            const ringProg = (riseProg - 0.2) / 0.8;
            for (let r = 0; r < 5; r++) {
              const rDelay = r * 0.12;
              const rp = Math.max(0, (ringProg - rDelay) / (1 - rDelay));
              if (rp <= 0) continue;
              const rr = rp * (120 + r * 70);
              ctx.strokeStyle = `rgba(255,200,0,${Math.max(0, (0.7 - rp * 0.8) * (1 - r*0.15))})`;
              ctx.lineWidth = 4 - r * 0.7;
              ctx.beginPath();
              ctx.arc(gsX, riseY + hSize*0.5, rr, 0, Math.PI*2);
              ctx.stroke();
            }
          }

          if (riseProg > 0.05 && riseProg < 0.5) {
            const lFreq = Math.sin(t*20);
            if (lFreq > 0.7) {
              ctx.strokeStyle = `rgba(255,200,0,0.6)`;
              ctx.lineWidth = 2;
              ctx.beginPath();
              let lx = gsX + (Math.random()-0.5)*40, ly = 0;
              ctx.moveTo(lx, ly);
              for (let seg = 0; seg < 8; seg++) {
                lx += (Math.random()-0.5) * 50;
                ly += gsY / 8;
                ctx.lineTo(lx, ly);
              }
              ctx.stroke();
            }
          }
        }

        ctx.textAlign = 'center';
        if (sp < 0.15) {
          const locAlpha = Math.min(1, sp * 8);
          ctx.globalAlpha = locAlpha;
          ctx.fillStyle = '#555';
          ctx.font = `${Math.min(12, W*0.017)}px monospace`;
          ctx.fillText('WESTMINSTER ABBEY  \u2022  CAMBRIDGE, ENGLAND', W/2, H * 0.86);
          ctx.fillStyle = '#444';
          ctx.font = `${Math.min(10, W*0.014)}px monospace`;
          ctx.fillText('2:47 AM', W/2, H * 0.9);
          ctx.globalAlpha = 1;
        } else if (sp < 0.4) {
          const buzzAlpha = 0.6 + Math.sin(t*12) * 0.3;
          ctx.fillStyle = `rgba(255,200,0,${buzzAlpha})`;
          ctx.font = `italic ${Math.min(18, W*0.025)}px monospace`;
          ctx.fillText('*bzzzz . . . bzzzz . . . bzzzz . . .*', W/2, H * 0.88);
        } else if (sp < 0.7) {
          const crackAlpha = Math.min(1, (sp-0.4)*5);
          ctx.globalAlpha = crackAlpha;
          ctx.fillStyle = '#ffd700';
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 10;
          ctx.font = `italic ${Math.min(22, W*0.03)}px monospace`;
          const crackLine = sp < 0.55 ? '"Did you really think..."' : '"...death could stop me?"';
          ctx.fillText(crackLine, W/2, H * 0.88);
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1;
        } else {
          const riseProg = (sp - 0.7) / 0.3;
          ctx.fillStyle = '#ffd700';
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 25 + riseProg * 20;
          if (riseProg < 0.4) {
            const s1 = Math.min(1, riseProg * 4);
            ctx.font = `bold ${Math.min(26, W*0.036)}px monospace`;
            const line1 = '"THE UNIVERSE ISN\'T DONE WITH ME."';
            const c1 = Math.floor(line1.length * s1);
            ctx.fillText(line1.substring(0, c1), W/2, H * 0.87);
          } else {

            const s2 = Math.min(1, (riseProg - 0.4) * 3);
            const finalSize = Math.min(36, W*0.048) * (1 + (1-s2)*0.3);
            ctx.font = `bold ${finalSize}px monospace`;
            ctx.fillText('"I. AM. INEVITABLE."', W/2, H * 0.87);
          }
          ctx.shadowBlur = 0;
        }
        ctx.restore();
      }

      if (prog >= 0.59) {
        const sp = (prog - 0.59) / 0.41;
        ctx.save();

        const voidGrad = ctx.createRadialGradient(W/2, H*0.35, 50, W/2, H*0.35, H*1.2);
        voidGrad.addColorStop(0, '#0a0515');
        voidGrad.addColorStop(0.3, '#060310');
        voidGrad.addColorStop(0.6, '#030208');
        voidGrad.addColorStop(1, '#000000');
        ctx.fillStyle = voidGrad;
        ctx.fillRect(0, 0, W, H);

        for (let vs = 0; vs < 80; vs++) {
          const vsx = (vs * 83.7) % W;
          const vsy = (vs * 47.3) % H;
          const twinkle = 0.1 + Math.sin(t * 2 + vs*2)*0.08 + Math.sin(t*3.7+vs*5)*0.05;
          ctx.fillStyle = `rgba(200,180,255,${twinkle})`;
          const starSize = vs % 7 === 0 ? 2 : 1;
          ctx.fillRect(vsx, vsy, starSize, starSize);
        }

        const allCols = ['#ff4400','#8844ff','#4488ff','#cc2222','#44ff88'];
        const allImgs = [bossImg, epsteinImg, muskImg, clintonImg, hawkingImg];
        const allNames = ['TRUMP','EPSTEIN','MUSK','CLINTON','HAWKING'];
        const allTitles = ['The Tyrant','The Shadow','The Architect','The Schemer','THE MASTERMIND'];

        const vortexIntensity = Math.min(1, sp * 2);
        ctx.globalAlpha = 0.06 * vortexIntensity;
        for (let ring = 0; ring < 18; ring++) {
          const rAngle = t * (0.3 + ring * 0.08) + ring * 0.35;
          const rDist = 50 + ring * 28;
          ctx.strokeStyle = allCols[ring % 5];
          ctx.lineWidth = 3 - ring * 0.1;
          ctx.beginPath();
          ctx.arc(W/2, H*0.38, rDist, rAngle, rAngle + Math.PI * (0.6 + Math.sin(t + ring)*0.2));
          ctx.stroke();
        }
        ctx.globalAlpha = 1;

        if (sp > 0.04) {
          const rayAlpha = Math.min(0.08, (sp - 0.04) * 0.2);
          for (let c = 0; c < 15; c++) {
            const ray = t * 1.2 + c * (Math.PI*2/15);
            ctx.strokeStyle = allCols[c % 5];
            ctx.globalAlpha = rayAlpha;
            ctx.lineWidth = 2 + Math.sin(t*2 + c) * 1.5;
            ctx.beginPath();
            ctx.moveTo(W/2, H*0.38);
            ctx.lineTo(W/2 + Math.cos(ray) * W, H*0.38 + Math.sin(ray) * H);
            ctx.stroke();
          }
          ctx.globalAlpha = 1;
        }

        const pCount = Math.floor(Math.min(60, sp * 100));
        for (let pp = 0; pp < pCount; pp++) {
          const ppx = (pp * 47.3 + t * (30 + pp%3 * 10)) % W;
          const ppy = (pp * 31.7 + t * (50 + pp%4 * 8)) % H;
          ctx.fillStyle = allCols[pp % 5];
          ctx.globalAlpha = 0.15 + Math.sin(t*3 + pp) * 0.1;
          const ppSize = pp % 5 === 0 ? 3 : (pp % 3 === 0 ? 2 : 1);
          ctx.fillRect(ppx, ppy, ppSize, ppSize);
        }
        ctx.globalAlpha = 1;

        if (sp < 0.04) {
          const gatherProg = sp / 0.04;

          ctx.globalAlpha = Math.sin(gatherProg * Math.PI);
          ctx.fillStyle = '#666';
          ctx.font = `${Math.min(14, W*0.02)}px monospace`;
          ctx.textAlign = 'center';
          const txt = 'T H E Y   A R E   C O M I N G';
          const charCount = Math.floor(txt.length * gatherProg);
          ctx.fillText(txt.substring(0, charCount), W/2, H/2);
          ctx.globalAlpha = 1;

          const rumble = Math.sin(t * 8) * gatherProg * 0.05;
          ctx.fillStyle = `rgba(100,0,0,${rumble})`;
          ctx.fillRect(0, 0, W, H);
        }

        const revealTimes = [0.04, 0.12, 0.20, 0.28, 0.38];
        const assemblyPos = [
          { x: 0.12, y: 0.35, s: 0.85 },
          { x: 0.30, y: 0.35, s: 0.9 },
          { x: 0.70, y: 0.35, s: 0.9 },
          { x: 0.88, y: 0.35, s: 0.85 },
          { x: 0.50, y: 0.18, s: 1.7 },
        ];

        for (let i = 0; i < 5; i++) {
          if (sp < revealTimes[i]) continue;
          const isHawking = i === 4;
          const fadeProg = Math.min(1, (sp - revealTimes[i]) / 0.06);
          const fadeEase = 1 - Math.pow(1 - fadeProg, 3);

          const aPos = assemblyPos[i];
          const baseSize = Math.min(W * 0.11, 75);
          const pSize = baseSize * aPos.s;
          const px = W * aPos.x;
          const py = H * aPos.y;
          const pH = imgH(allImgs[i], pSize);
          const drawX = px - pSize / 2;
          const drawY = py;

          ctx.globalAlpha = fadeEase;

          const pillarW = isHawking ? 50 : 30;
          const pillarGrad = ctx.createLinearGradient(px - pillarW, 0, px + pillarW, 0);
          pillarGrad.addColorStop(0, 'rgba(0,0,0,0)');
          pillarGrad.addColorStop(0.5, allCols[i] + '15');
          pillarGrad.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = pillarGrad;
          ctx.fillRect(px - pillarW, 0, pillarW * 2, H);

          const glowSize = pSize * (isHawking ? 2.5 : 2.0);
          const pGlow = ctx.createRadialGradient(px, drawY + pH*0.5, 5, px, drawY + pH*0.5, glowSize);
          pGlow.addColorStop(0, allCols[i] + (isHawking ? '88' : '55'));
          pGlow.addColorStop(0.3, allCols[i] + '25');
          pGlow.addColorStop(0.7, allCols[i] + '08');
          pGlow.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = pGlow;
          ctx.beginPath();
          ctx.arc(px, drawY + pH*0.5, glowSize, 0, Math.PI*2);
          ctx.fill();

          ctx.strokeStyle = allCols[i];
          ctx.lineWidth = isHawking ? 4 : 2;
          ctx.shadowColor = allCols[i];
          ctx.shadowBlur = isHawking ? 60 : 25;
          ctx.strokeRect(drawX - 6, drawY - 6, pSize + 12, pH + 12);
          ctx.shadowBlur = 0;

          ctx.drawImage(allImgs[i], drawX, drawY, pSize, pH);
          if (isHawking) {
            ctx.globalAlpha = fadeEase * 0.3;
            ctx.drawImage(allImgs[i], drawX - 3, drawY - 3, pSize + 6, pH + 6);
            ctx.globalAlpha = fadeEase;
          }

          const cornerLen = isHawking ? 18 : 12;
          ctx.strokeStyle = allCols[i];
          ctx.lineWidth = isHawking ? 3 : 2;
          const fx = drawX - 6, fy = drawY - 6, fw = pSize + 12, fh = pH + 12;
          ctx.beginPath(); ctx.moveTo(fx, fy + cornerLen); ctx.lineTo(fx, fy); ctx.lineTo(fx + cornerLen, fy); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(fx + fw - cornerLen, fy); ctx.lineTo(fx + fw, fy); ctx.lineTo(fx + fw, fy + cornerLen); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(fx, fy + fh - cornerLen); ctx.lineTo(fx, fy + fh); ctx.lineTo(fx + cornerLen, fy + fh); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(fx + fw - cornerLen, fy + fh); ctx.lineTo(fx + fw, fy + fh); ctx.lineTo(fx + fw, fy + fh - cornerLen); ctx.stroke();

          if (fadeProg < 0.3) {
            const shockProg = fadeProg / 0.3;
            const shockR = pSize * (1 + shockProg * (isHawking ? 5 : 3));
            ctx.globalAlpha = (1 - shockProg) * 0.7;
            ctx.strokeStyle = allCols[i];
            ctx.lineWidth = (isHawking ? 5 : 3) * (1 - shockProg);
            ctx.beginPath();
            ctx.arc(px, drawY + pH * 0.5, shockR, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = allCols[i];
            ctx.globalAlpha = (1 - shockProg) * (isHawking ? 0.25 : 0.12);
            ctx.fillRect(0, 0, W, H);
            ctx.globalAlpha = fadeEase;
          }

          const npY = drawY + pH + 8;
          const npH = isHawking ? 50 : 32;
          const npW = pSize + 20;
          const npX = px - npW / 2;
          const plateGrad = ctx.createLinearGradient(npX, npY, npX, npY + npH);
          plateGrad.addColorStop(0, '#111111ee');
          plateGrad.addColorStop(1, '#000000ee');
          ctx.fillStyle = plateGrad;
          ctx.fillRect(npX, npY, npW, npH);
          ctx.strokeStyle = allCols[i] + '88';
          ctx.lineWidth = 1;
          ctx.strokeRect(npX, npY, npW, npH);
          ctx.fillStyle = allCols[i];
          const nameSize = isHawking ? 20 : 13;
          ctx.font = `bold ${nameSize}px monospace`;
          ctx.textAlign = 'center';
          ctx.shadowColor = allCols[i];
          ctx.shadowBlur = 12;
          ctx.fillText(allNames[i], px, npY + nameSize + 2);
          ctx.shadowBlur = 0;
          const titleSize = isHawking ? 12 : 9;
          ctx.fillStyle = isHawking ? '#ffd700' : '#999';
          ctx.font = `${isHawking ? 'bold ' : ''}${titleSize}px monospace`;
          ctx.fillText(allTitles[i], px, npY + nameSize + titleSize + 6);
        }

        if (sp > 0.34 && sp < 0.38) {
          const tensionProg = (sp - 0.34) / 0.04;

          const flicker = Math.sin(t * 30) * Math.sin(t * 17) * Math.sin(t * 43);
          if (flicker > 0.3) {
            ctx.fillStyle = `rgba(255,200,0,${tensionProg * 0.15})`;
            ctx.fillRect(0, 0, W, H);
          }

          ctx.fillStyle = `rgba(255,200,0,${tensionProg * 0.5})`;
          ctx.font = `bold ${60 + Math.sin(t*8)*10}px monospace`;
          ctx.textAlign = 'center';
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 40;
          ctx.fillText('?', W/2, H/2 + 20);
          ctx.shadowBlur = 0;
        }

        if (sp > 0.52) {
          const pentAlpha = Math.min(0.06, (sp - 0.52) * 0.2);
          ctx.globalAlpha = pentAlpha + Math.sin(t*1.5)*0.02;
          ctx.strokeStyle = '#ffdd44';
          ctx.lineWidth = 1;
          const pentR = 250;
          const pentPoints = [];
          for (let pp2 = 0; pp2 < 5; pp2++) {
            const pAngle = (pp2 / 5) * Math.PI * 2 - Math.PI/2 + t * 0.1;
            pentPoints.push({ x: W/2 + Math.cos(pAngle) * pentR, y: H*0.38 + Math.sin(pAngle) * pentR * 0.7 });
          }
          ctx.beginPath();
          ctx.moveTo(pentPoints[0].x, pentPoints[0].y);
          ctx.lineTo(pentPoints[2].x, pentPoints[2].y);
          ctx.lineTo(pentPoints[4].x, pentPoints[4].y);
          ctx.lineTo(pentPoints[1].x, pentPoints[1].y);
          ctx.lineTo(pentPoints[3].x, pentPoints[3].y);
          ctx.closePath();
          ctx.stroke();
          ctx.globalAlpha = 1;
        }

        if (sp > 0.55) {
          const connAlpha = Math.min(0.3, (sp - 0.55) * 0.6);
          ctx.globalAlpha = connAlpha;
          for (let a = 0; a < 5; a++) {
            for (let b = a + 1; b < 5; b++) {
              const ax = W * assemblyPos[a].x, ay = H * assemblyPos[a].y + 50;
              const bx = W * assemblyPos[b].x, by = H * assemblyPos[b].y + 50;

              ctx.strokeStyle = allCols[a];
              ctx.lineWidth = 1;
              ctx.beginPath(); ctx.moveTo(ax, ay); ctx.lineTo(bx, by); ctx.stroke();

              const dotProg = (t * 0.5 + a * 0.3 + b * 0.7) % 1;
              const dotX = ax + (bx - ax) * dotProg;
              const dotY = ay + (by - ay) * dotProg;
              ctx.fillStyle = allCols[a];
              ctx.globalAlpha = connAlpha * 0.8;
              ctx.beginPath(); ctx.arc(dotX, dotY, 3, 0, Math.PI*2); ctx.fill();
              ctx.globalAlpha = connAlpha;
            }
          }
          ctx.globalAlpha = 1;
        }

        if (sp > 0.60 && sp < 0.70) {
          const vsProg = (sp - 0.60) / 0.10;
          const vsEase = 1 - Math.pow(1 - Math.min(1, vsProg * 2), 3);
          ctx.globalAlpha = vsEase * (vsProg > 0.7 ? Math.max(0, 1 - (vsProg - 0.7) / 0.3) : 1);

          ctx.strokeStyle = '#ffdd44';
          ctx.lineWidth = 4;
          ctx.shadowColor = '#ffdd44';
          ctx.shadowBlur = 30;
          ctx.beginPath();
          ctx.moveTo(W * 0.45, 0);
          ctx.lineTo(W * 0.55, H);
          ctx.stroke();
          ctx.shadowBlur = 0;

          const vsSize = Math.min(80, W * 0.1) * (1 + Math.sin(t * 4) * 0.05);
          ctx.fillStyle = '#ffdd44';
          ctx.font = `bold ${vsSize}px monospace`;
          ctx.textAlign = 'center';
          ctx.shadowColor = '#ff4400';
          ctx.shadowBlur = 80;
          ctx.fillText('VS', W/2, H/2 + vsSize * 0.3);
          ctx.shadowColor = '#ffdd44';
          ctx.shadowBlur = 40;
          ctx.fillText('VS', W/2, H/2 + vsSize * 0.3);
          ctx.shadowBlur = 0;

          ctx.fillStyle = '#4488ff';
          ctx.font = `bold ${Math.min(30, W*0.04)}px monospace`;
          ctx.shadowColor = '#4488ff';
          ctx.shadowBlur = 20;
          ctx.fillText('Y O U', W * 0.25, H/2 + 10);
          ctx.shadowBlur = 0;

          ctx.fillStyle = '#ff4400';
          ctx.font = `bold ${Math.min(26, W*0.035)}px monospace`;
          ctx.shadowColor = '#ff4400';
          ctx.shadowBlur = 20;
          ctx.fillText('T H E  C A B A L', W * 0.75, H/2 + 10);
          ctx.shadowBlur = 0;

          ctx.globalAlpha = 1;
        }

        if (sp > 0.65) {
          const titleProg = Math.min(1, (sp - 0.65) / 0.15);
          const titleEase = 1 - Math.pow(1 - titleProg, 3);
          ctx.globalAlpha = titleEase;

          const barGrad = ctx.createLinearGradient(0, H * 0.62, 0, H * 0.98);
          barGrad.addColorStop(0, 'rgba(0,0,0,0)');
          barGrad.addColorStop(0.08, 'rgba(0,0,0,0.9)');
          barGrad.addColorStop(0.92, 'rgba(0,0,0,0.9)');
          barGrad.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = barGrad;
          ctx.fillRect(0, H * 0.62, W, H * 0.36);

          const lineExpand = Math.min(1, titleProg * 2);
          const lineHalf = W * 0.4 * lineExpand;
          ctx.strokeStyle = '#ffdd44';
          ctx.lineWidth = 2;
          ctx.globalAlpha = titleEase * 0.7;
          ctx.beginPath(); ctx.moveTo(W/2 - lineHalf, H * 0.66); ctx.lineTo(W/2 + lineHalf, H * 0.66); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(W/2 - lineHalf, H * 0.95); ctx.lineTo(W/2 + lineHalf, H * 0.95); ctx.stroke();

          const diaPos = [[W/2 - lineHalf, H*0.66], [W/2 + lineHalf, H*0.66], [W/2 - lineHalf, H*0.95], [W/2 + lineHalf, H*0.95]];
          for (const dp of diaPos) {
            if (lineExpand > 0.5) {
              ctx.save();
              ctx.translate(dp[0], dp[1]);
              ctx.rotate(Math.PI/4);
              ctx.fillStyle = '#ffdd44';
              ctx.fillRect(-3, -3, 6, 6);
              ctx.restore();
            }
          }
          ctx.globalAlpha = titleEase;

          ctx.fillStyle = '#ffdd44';
          const titleSize = Math.min(56, W * 0.07) * (1 + (1-titleEase)*0.5);
          ctx.font = `bold ${titleSize}px monospace`;
          ctx.textAlign = 'center';

          ctx.shadowColor = '#ff4400';
          ctx.shadowBlur = 80;
          ctx.fillText('\u2605 THE FINAL STAND \u2605', W/2, H * 0.74);

          ctx.shadowColor = '#ff8844';
          ctx.shadowBlur = 50;
          ctx.fillText('\u2605 THE FINAL STAND \u2605', W/2, H * 0.74);

          ctx.shadowColor = '#ffdd44';
          ctx.shadowBlur = 25;
          ctx.fillText('\u2605 THE FINAL STAND \u2605', W/2, H * 0.74);
          ctx.shadowBlur = 0;

          if (sp > 0.72) {
            const subProg = Math.min(1, (sp - 0.72) / 0.08);
            ctx.globalAlpha = subProg;
            ctx.fillStyle = '#ff8844';
            ctx.font = `bold ${Math.min(22, W*0.03)}px monospace`;
            const subText = 'DEFEAT THEM ALL.  HAWKING IS LAST.';
            const subChars = Math.floor(subText.length * subProg);
            ctx.fillText(subText.substring(0, subChars), W/2, H * 0.80);
          }

          if (sp > 0.78) {
            const warnProg = Math.min(1, (sp - 0.78) / 0.06);
            ctx.globalAlpha = warnProg;
            const warnPulse = 0.7 + Math.sin(t * 4) * 0.3;
            ctx.fillStyle = `rgba(68,170,255,${warnPulse})`;
            ctx.font = `bold ${Math.min(15, W*0.02)}px monospace`;
            ctx.shadowColor = '#44aaff';
            ctx.shadowBlur = 15;
            ctx.fillText('\u26a1 HAWKING IS SHIELDED UNTIL OTHERS FALL \u26a1', W/2, H * 0.86);
            ctx.shadowBlur = 0;
          }

          if (sp > 0.82) {
            const hpProg = Math.min(1, (sp - 0.82) / 0.05);
            ctx.globalAlpha = hpProg;
            ctx.fillStyle = '#44ff88';
            ctx.font = `bold ${Math.min(18, W*0.024)}px monospace`;
            ctx.shadowColor = '#44ff88';
            ctx.shadowBlur = 10;
            ctx.fillText('\u2764 HP: 50 / 50', W/2, H * 0.92);
            ctx.shadowBlur = 0;
          }

          if (sp > 0.90) {
            const readyProg = (sp - 0.90) / 0.10;
            const readyFlash = Math.sin(t * 6) > 0 ? 1 : 0.3;
            ctx.globalAlpha = readyProg * readyFlash;
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${Math.min(28, W*0.038)}px monospace`;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 20;
            ctx.fillText('G E T   R E A D Y', W/2, H * 0.58);
            ctx.shadowBlur = 0;
          }
        }
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      const scenes = [0.03, 0.055, 0.14, 0.24, 0.34, 0.44, 0.59];
      for (const s of scenes) {
        const dist = Math.abs(prog - s);
        if (dist < 0.02) {
          const glitchIntensity = 1 - dist / 0.02;

          ctx.fillStyle = `rgba(255,255,255,${glitchIntensity * 0.7})`;
          ctx.fillRect(0, 0, W, H);

          for (let gb = 0; gb < 12; gb++) {
            const gy = Math.random() * H;
            const gHt = 2 + Math.random() * 15;
            ctx.fillStyle = `rgba(${Math.random()>0.5?255:0},${Math.random()>0.5?255:0},${Math.random()>0.5?255:0},${glitchIntensity * 0.4})`;
            ctx.fillRect(0, gy, W, gHt);
          }

          if (glitchIntensity > 0.3) {
            for (let sl = 0; sl < 3; sl++) {
              const slice = Math.floor(Math.random() * H);
              const sliceH = 10 + Math.random() * 40;
              ctx.drawImage(canvas, 0, slice, W, sliceH, (Math.random()-0.5)*40 * glitchIntensity, slice, W, sliceH);
            }
          }

          if (glitchIntensity > 0.5) {
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = `rgba(255,0,0,${glitchIntensity * 0.08})`;
            ctx.fillRect(-3, 0, W, H);
            ctx.fillStyle = `rgba(0,0,255,${glitchIntensity * 0.08})`;
            ctx.fillRect(3, 0, W, H);
            ctx.globalCompositeOperation = 'source-over';
          }

          ctx.globalAlpha = glitchIntensity * 0.15;
          for (let n = 0; n < 80; n++) {
            ctx.fillStyle = Math.random() > 0.5 ? '#fff' : '#000';
            ctx.fillRect(Math.random() * W, Math.random() * H, Math.random() * 4 + 1, Math.random() * 2 + 1);
          }
          ctx.globalAlpha = 1;
        }
      }

      const heartRate = prog > 0.5 ? 5.0 : 3.5;
      const heartbeat = Math.pow(Math.sin(t * heartRate), 20);
      if (heartbeat > 0.1) {
        const hbIntensity = prog > 0.5 ? 0.15 : 0.08;
        ctx.fillStyle = `rgba(100,0,0,${heartbeat * hbIntensity})`;
        ctx.fillRect(0, 0, W, H);
      }

      ctx.restore();

      const vigIntensity = 0.3 + prog * 0.4;
      const vigGrad = ctx.createRadialGradient(W/2, H/2, W*0.25, W/2, H/2, W*0.75);
      vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
      vigGrad.addColorStop(0.6, `rgba(0,0,0,${vigIntensity * 0.3})`);
      vigGrad.addColorStop(1, `rgba(0,0,0,${vigIntensity})`);
      ctx.fillStyle = vigGrad;
      ctx.fillRect(0, 0, W, H);

      const barSlide = Math.min(1, prog * 8);
      const actualBarH = (barH + 15) * barSlide;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, actualBarH);
      ctx.fillRect(0, H - actualBarH, W, actualBarH);

      if (actualBarH > 2) {
        ctx.fillStyle = '#ffdd4422';
        ctx.fillRect(0, actualBarH - 2, W, 2);
        ctx.fillRect(0, H - actualBarH, W, 2);
        ctx.fillStyle = '#ffdd4411';
        ctx.fillRect(0, actualBarH - 4, W, 1);
        ctx.fillRect(0, H - actualBarH + 2, W, 1);

        const accentX = (t * 80) % W;
        const accentX2 = (W - (t * 120) % W);
        ctx.fillStyle = '#ffdd4455';
        ctx.fillRect(accentX, actualBarH - 2, 100, 2);
        ctx.fillRect(W - accentX - 100, H - actualBarH, 100, 2);
        ctx.fillStyle = '#ffdd4433';
        ctx.fillRect(accentX2, actualBarH - 2, 50, 2);
        ctx.fillRect(W - accentX2 - 50, H - actualBarH, 50, 2);
      }

      const sceneNum = prog < 0.03 ? 0 : prog < 0.055 ? 1 : prog < 0.14 ? 2 : prog < 0.24 ? 3 : prog < 0.34 ? 4 : prog < 0.44 ? 5 : prog < 0.59 ? 6 : 7;
      if (sceneNum > 0 && sceneNum < 7 && actualBarH > 20) {
        ctx.fillStyle = '#ffffff22';
        ctx.font = `${Math.min(9, W*0.012)}px monospace`;
        ctx.textAlign = 'left';
        ctx.fillText(`SCENE ${sceneNum} / 7`, 15, actualBarH - 8);

        const scProgress = prog < 0.59 ? prog / 0.59 : 1;
        ctx.fillStyle = '#ffffff11';
        ctx.fillRect(W * 0.3, actualBarH - 5, W * 0.4, 2);
        ctx.fillStyle = '#ffdd4444';
        ctx.fillRect(W * 0.3, actualBarH - 5, W * 0.4 * scProgress, 2);
      }

      ctx.globalAlpha = 0.04;
      for (let gg = 0; gg < 350; gg++) {
        const gx = Math.random() * W;
        const gy = Math.random() * H;
        ctx.fillStyle = Math.random() > 0.5 ? '#fff' : '#000';
        ctx.fillRect(gx, gy, Math.random() > 0.8 ? 2 : 1, 1);
      }
      ctx.globalAlpha = 1;

      ctx.globalAlpha = 0.015;
      for (let sl = 0; sl < H; sl += 3) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, sl, W, 1);
      }
      ctx.globalAlpha = 1;

      if (prog > 0.97) {
        const fadeOut = (prog - 0.97) / 0.03;
        ctx.fillStyle = `rgba(255,255,255,${fadeOut * fadeOut})`;
        ctx.fillRect(0, 0, W, H);
      }

      if (prog > 0.05) {
        ctx.fillStyle = `rgba(255,255,255,${Math.min(0.25, (prog-0.05)*0.4)})`;
        ctx.font = '10px monospace';
        ctx.textAlign = 'right';
        ctx.fillText('CLICK TO SKIP \u25B6', W - 20, actualBarH - 8);
      }
    }

    const hpW = 200;
    ctx.fillStyle = '#00000099';
    ctx.fillRect(15, 8, hpW + 14, 30);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(17, 10, hpW + 10, 26);
    const phpPctS = player.hp / player.maxHp;
    const phpGradS = ctx.createLinearGradient(22, 0, 22 + hpW, 0);
    const phpColsS = cbHP(phpPctS);
    phpGradS.addColorStop(0, phpColsS.a);
    phpGradS.addColorStop(1, phpColsS.b);
    ctx.fillStyle = phpGradS;
    ctx.fillRect(22, 14, hpW * phpPctS, 18);
    ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/200)*0.1+0.1})`;
    ctx.fillRect(22, 14, hpW * phpPctS * 0.5, 6);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(22, 14, hpW, 18);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`\u2764 ${player.hp}/${player.maxHp}`, 28, 29);

    const alive = miniBosses.filter(m => !m.dead);
    const total = miniBosses.length;
    const miniBossW = Math.min(400, W - 260);
    ctx.fillStyle = '#000000cc';
    ctx.fillRect(Math.max(240, W/2 - miniBossW/2), 5, miniBossW, 38);
    ctx.fillStyle = '#ff8844';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#ff4400';
    ctx.shadowBlur = 8;
    const othersUp = miniBosses.filter(m => !m.dead && m.name !== 'HAWKING').length;
    const statusText = hawkingPhase2 ? '★★ HAWKING TRANSCENDED ★★' : (othersUp === 0 ? '★ HAWKING EXPOSED ★' : `DEFEAT THEM ALL  (${total - alive.length}/${total})`);
    ctx.fillStyle = hawkingPhase2 ? '#ffd700' : (othersUp === 0 ? '#44ff88' : '#ff8844');
    ctx.fillText(statusText, W/2, 19);
    ctx.shadowBlur = 0;

    const startX = W/2 - (alive.length * 55) / 2;
    alive.forEach((mb, i) => {
      const bx = startX + i * 55;
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(bx, 25, 50, 10);

      const isShielded = mb.name === 'HAWKING' && othersUp > 0;
      const shieldBarCol = hawkingPhase2 ? [255,200,0] : [68,255,136];
      ctx.fillStyle = isShielded ? `rgba(${shieldBarCol},${0.3 + Math.sin(Date.now()/200)*0.2})` : mb.color;
      ctx.fillRect(bx, 25, 50 * (mb.hp / mb.maxHp), 10);
      ctx.strokeStyle = isShielded ? (hawkingPhase2 ? '#ffd700' : '#44ff88') : '#ffffff33';
      ctx.lineWidth = isShielded ? 2 : 1;
      ctx.strokeRect(bx, 25, 50, 10);
      ctx.fillStyle = '#fff';
      ctx.font = '6px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(isShielded ? '🛡' + mb.name : mb.name, bx + 25, 33);
    });

    drawTouchButtons();

    ctx.fillStyle = '#ffffff55';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(_isTouchDev ? 'Defeat them all!' : 'Defeat them all!  |  Click/F Throw  |  \u2190 \u2192 Move  |  \u2191/Space Jump', W / 2, H - 10);
  }

  if (state === 'cutscene') {

    ctx.fillStyle = `rgba(0, 0, 0, ${cutscene.fadeAlpha})`;
    ctx.fillRect(0, 0, W, H);

    if (cutscene.phase >= 1) {

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const vigGrad = ctx.createRadialGradient(W/2, H/2, H*0.25, W/2, H/2, H*0.8);
      vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
      vigGrad.addColorStop(1, 'rgba(180,0,0,0.4)');
      ctx.fillStyle = vigGrad;
      ctx.fillRect(0, 0, W, H);

      ctx.strokeStyle = '#ff222233';
      ctx.lineWidth = 2;
      for (let i = 0; i < 20; i++) {
        const lx = (i * 97 + cutscene.timer * 2) % (W + 200) - 100;
        ctx.beginPath();
        ctx.moveTo(lx, 0);
        ctx.lineTo(lx - 50, H);
        ctx.stroke();
      }

      const imgW = Math.min(W * 0.35, 350);
      const imgH = imgW * 1.3;
      const imgX = W / 2 - imgW / 2;
      const imgY = H * 0.06;

      ctx.fillStyle = '#daa520';
      ctx.fillRect(imgX - 8, imgY - 8, imgW + 16, imgH + 16);
      ctx.fillStyle = '#b8860b';
      ctx.fillRect(imgX - 4, imgY - 4, imgW + 8, imgH + 8);

      ctx.drawImage(bossIntroImg, imgX, imgY, imgW, imgH);

      if (cutscene.phase === 1 && cutscene.timer < 15) {
        ctx.fillStyle = `rgba(255, 255, 255, ${1 - cutscene.timer / 15})`;
        ctx.fillRect(0, 0, W, H);
      }

      const titleY = imgY + imgH + 45;
      ctx.shadowColor = '#ff4444';
      ctx.shadowBlur = 20;
      ctx.fillStyle = '#ff2222';
      ctx.font = `bold ${Math.min(48, W * 0.06)}px monospace`;
      ctx.textAlign = 'center';
      ctx.fillText('\u2605 BOSS ENCOUNTER \u2605', W / 2, titleY);
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#ffcc00';
      ctx.font = `bold ${Math.min(36, W * 0.045)}px monospace`;
      ctx.fillText('DONALD J. TRUMP', W / 2, titleY + 38);

      ctx.fillStyle = '#ccc';
      ctx.font = `${Math.min(16, W * 0.022)}px monospace`;
      ctx.fillText('"The Wall Builder"', W / 2, titleY + 60);

      if (cutscene.phase === 1) {
        const blink = Math.sin(Date.now() / 300) > 0;
        if (blink) {
          ctx.fillStyle = '#888';
          ctx.font = '14px monospace';
          ctx.fillText(_isTouchDev ? '[ Tap to continue ]' : '[ Click / Press SPACE to continue ]', W / 2, H - 40);
        }
      }

      if (cutscene.phase === 2 && cutscene.dialogueIndex < cutscene.dialogues.length) {
        const dialogueText = cutscene.dialogues[cutscene.dialogueIndex];

        const boxH = 110;
        const boxY = H - boxH - 30;
        ctx.fillStyle = '#111111ee';
        ctx.fillRect(40, boxY, W - 80, boxH);
        ctx.strokeStyle = '#daa520';
        ctx.lineWidth = 3;
        ctx.strokeRect(40, boxY, W - 80, boxH);

        ctx.fillStyle = '#ff4444';
        ctx.font = 'bold 18px monospace';
        ctx.textAlign = 'left';
        ctx.fillText('TRUMP:', 65, boxY + 30);

        const charsToShow = Math.min(dialogueText.length, Math.floor(cutscene.timer * 0.8));
        const visibleText = dialogueText.substring(0, charsToShow);
        ctx.fillStyle = '#fff';
        ctx.font = '16px monospace';
        ctx.fillText(visibleText, 65, boxY + 62);

        if (charsToShow >= dialogueText.length) {
          const blink = Math.sin(Date.now() / 300) > 0;
          if (blink) {
            ctx.fillStyle = '#888';
            ctx.font = '12px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(_isTouchDev ? '[ Tap \u25ba ]' : '[ Click / SPACE \u25ba ]', W - 55, boxY + boxH - 14);
          }
        }
      }

      if (cutscene.phase === 3) {
        ctx.fillStyle = `rgba(0, 0, 0, ${1 - cutscene.fadeAlpha})`;
        ctx.fillRect(0, 0, W, H);
      }

      ctx.fillStyle = '#ffffff33';
      ctx.fillRect(W - 110, 10, 100, 30);
      ctx.strokeStyle = '#ffffff55';
      ctx.lineWidth = 1;
      ctx.strokeRect(W - 110, 10, 100, 30);
      ctx.fillStyle = '#ccc';
      ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('SKIP ▶▶', W - 60, 30);
    }
  }

  if (state === 'bossdialogue' && bossDialogue.active) {

    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.fillRect(0, 0, W, H);

    const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
    ctx.strokeStyle = `rgba(255, 50, 0, ${pulse * 0.5})`;
    ctx.lineWidth = 4;
    ctx.strokeRect(20, 20, W - 40, H - 40);

    const phaseNum = boss ? boss.phase : 2;
    const phaseNames = { 2: 'PHASE 2: ENRAGED', 3: 'PHASE 3: FINAL FORM' };
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 30;
    ctx.fillStyle = phaseNum === 3 ? '#ff0000' : '#ff6600';
    ctx.font = `bold ${Math.min(42, W * 0.05)}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(phaseNames[phaseNum] || 'PHASE SHIFT', W / 2, H * 0.2);
    ctx.shadowBlur = 0;

    const portW = Math.min(140, W * 0.15);
    const portH = portW * 1.3;
    const portX = 60;
    const portY = H * 0.35;

    ctx.fillStyle = '#daa520';
    ctx.fillRect(portX - 4, portY - 4, portW + 8, portH + 8);
    ctx.fillStyle = '#b8860b';
    ctx.fillRect(portX - 2, portY - 2, portW + 4, portH + 4);
    ctx.drawImage(bossIntroImg, portX, portY, portW, portH);

    ctx.fillStyle = phaseNum === 3 ? 'rgba(255, 0, 0, 0.25)' : 'rgba(255, 100, 0, 0.15)';
    ctx.fillRect(portX, portY, portW, portH);

    const boxX = portX + portW + 30;
    const boxW = W - boxX - 60;
    const boxH = 120;
    const boxY = portY + portH / 2 - boxH / 2;

    ctx.fillStyle = '#111111ee';
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.strokeStyle = phaseNum === 3 ? '#ff2222' : '#daa520';
    ctx.lineWidth = 3;
    ctx.strokeRect(boxX, boxY, boxW, boxH);

    ctx.fillStyle = phaseNum === 3 ? '#ff0000' : '#ff4444';
    ctx.font = 'bold 18px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('TRUMP:', boxX + 20, boxY + 30);

    if (bossDialogue.index < bossDialogue.texts.length) {
      const dialogueText = bossDialogue.texts[bossDialogue.index];
      const charsToShow = Math.min(dialogueText.length, Math.floor(bossDialogue.timer * 0.8));
      const visibleText = dialogueText.substring(0, charsToShow);

      ctx.fillStyle = '#fff';
      ctx.font = '15px monospace';

      const maxLineW = boxW - 40;
      const words = visibleText.split(' ');
      let line = '';
      let lineY = boxY + 60;
      for (const word of words) {
        const testLine = line + word + ' ';
        if (ctx.measureText(testLine).width > maxLineW && line.length > 0) {
          ctx.fillText(line.trim(), boxX + 20, lineY);
          line = word + ' ';
          lineY += 22;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line.trim(), boxX + 20, lineY);

      if (charsToShow >= dialogueText.length) {
        const blink = Math.sin(Date.now() / 300) > 0;
        if (blink) {
          ctx.fillStyle = '#888';
          ctx.font = '12px monospace';
          ctx.textAlign = 'right';
          ctx.fillText(_isTouchDev ? '[ Tap ◸ ]' : '[ Click / SPACE ◸ ]', boxX + boxW - 15, boxY + boxH - 12);
        }
      }
    }

    ctx.textAlign = 'center';
    for (let d = 0; d < bossDialogue.texts.length; d++) {
      ctx.fillStyle = d <= bossDialogue.index ? '#ff6644' : '#555';
      ctx.beginPath();
      ctx.arc(W / 2 - (bossDialogue.texts.length - 1) * 10 + d * 20, H * 0.85, 5, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.fillStyle = '#ffffff33';
    ctx.fillRect(W - 110, 10, 100, 28);
    ctx.strokeStyle = '#ffffff55';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 110, 10, 100, 28);
    ctx.fillStyle = '#ccc';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SKIP \u25b6\u25b6', W - 60, 28);
  }

  if (state === 'intro') {

    if (introPhase === 0) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const dotAlpha = 0.3 + 0.2 * Math.sin(introTimer * 0.1);
      ctx.fillStyle = `rgba(240, 192, 64, ${dotAlpha})`;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(W/2 - 20 + i * 20, H/2, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    if (introPhase === 1) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const titleProgress = Math.min(1, introTimer / 20);
      const titleScale = titleProgress < 1 ? 3 - 2 * titleProgress : 1;
      const titleAlpha = Math.min(1, introTimer / 15);
      const titleShake = introTimer < 15 ? (15 - introTimer) * 0.5 * Math.sin(introTimer * 2) : 0;

      ctx.save();
      ctx.translate(W/2 + titleShake, H/2 - 40);
      ctx.scale(titleScale, titleScale);
      ctx.globalAlpha = titleAlpha;
      ctx.textAlign = 'center';
      ctx.font = 'bold 52px monospace';

      ctx.shadowColor = '#f0c040';
      ctx.shadowBlur = 30;
      ctx.fillStyle = '#f0c040';
      ctx.fillText('CRUZA LA FRONTERA', 0, 0);
      ctx.shadowBlur = 0;
      ctx.restore();

      if (introTimer < 8) {
        ctx.fillStyle = `rgba(255, 220, 100, ${(8 - introTimer) / 16})`;
        ctx.fillRect(0, 0, W, H);
      }

      if (introTimer < 10) {
        for (let i = 0; i < 5; i++) {
          const sx = W/2 + (Math.random() - 0.5) * 400;
          const sy = H/2 - 40 + (Math.random() - 0.5) * 30;
          ctx.fillStyle = `rgba(255, ${180 + Math.random()*75}, 50, ${Math.random()})`;
          ctx.fillRect(sx, sy, 2 + Math.random()*4, 2);
        }
      }
    }

    if (introPhase === 2) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      ctx.textAlign = 'center';
      ctx.font = 'bold 52px monospace';
      ctx.shadowColor = '#f0c040';
      ctx.shadowBlur = 20;
      ctx.fillStyle = '#f0c040';
      ctx.fillText('CRUZA LA FRONTERA', W/2, H/2 - 40);
      ctx.shadowBlur = 0;

      const subProgress = Math.min(1, introTimer / 30);
      const subX = W/2 + (1 - subProgress) * 300;
      ctx.globalAlpha = subProgress;
      ctx.font = '18px monospace';
      ctx.fillStyle = '#ff6644';
      ctx.fillText('Cross the border. Fight the power. Survive.', subX, H/2 + 20);
      ctx.globalAlpha = 1;

      const lineW = 300 * subProgress;
      ctx.strokeStyle = '#f0c04088';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(W/2 - lineW/2, H/2 - 15);
      ctx.lineTo(W/2 + lineW/2, H/2 - 15);
      ctx.stroke();

      if (introTimer > 40) {
        const hintAlpha = Math.min(1, (introTimer - 40) / 20);
        ctx.globalAlpha = hintAlpha * 0.6;
        ctx.font = '13px monospace';
        ctx.fillStyle = '#888';
        ctx.fillText(_isTouchDev ? 'Use on-screen controls to play' : 'Arrow Keys / WASD to move · Space / Up to jump · F to throw', W/2, H/2 + 60);
        ctx.globalAlpha = 1;
      }
    }

    if (introPhase === 3) {

      const grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, 'rgba(0,0,0,0.5)');
      grad.addColorStop(0.3, 'rgba(0,0,0,0.1)');
      grad.addColorStop(0.7, 'rgba(0,0,0,0.1)');
      grad.addColorStop(1, 'rgba(0,0,0,0.5)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);

      ctx.textAlign = 'center';
      ctx.font = 'bold 16px monospace';
      ctx.fillStyle = '#f0c04088';
      ctx.fillText('THE BORDER...', W/2, H * 0.15);

      for (const ip of introParticles) {
        ctx.globalAlpha = ip.life / 60;
        ctx.fillStyle = ip.color;
        ctx.fillRect(ip.x - cameraX, ip.y, ip.size, ip.size);
      }
      ctx.globalAlpha = 1;

      if (introTimer > 60) {
        const skipAlpha = 0.4 + 0.2 * Math.sin(Date.now() / 400);
        ctx.globalAlpha = skipAlpha;
        ctx.font = '12px monospace';
        ctx.fillStyle = '#aaa';
        ctx.fillText(_isTouchDev ? 'Tap to skip' : 'Press SPACE to skip', W/2, H * 0.9);
        ctx.globalAlpha = 1;
      }
    }

    if (introPhase === 4) {
      const grad2 = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, W * 0.7);
      grad2.addColorStop(0, 'rgba(0,0,0,0)');
      grad2.addColorStop(1, 'rgba(0,0,0,0.6)');
      ctx.fillStyle = grad2;
      ctx.fillRect(0, 0, W, H);

      ctx.textAlign = 'center';
      ctx.font = 'bold 20px monospace';
      ctx.fillStyle = '#88ff88';
      const readyAlpha = Math.min(1, introTimer / 20);
      ctx.globalAlpha = readyAlpha;
      ctx.fillText('GET READY...', W/2, H * 0.2);
      ctx.globalAlpha = 1;
    }

    if (introPhase === 5) {
      if (introTimer < 30) {
        const goScale = 1 + (30 - introTimer) / 30 * 2;
        const goAlpha = introTimer < 20 ? 1 : (30 - introTimer) / 10;
        ctx.save();
        ctx.translate(W/2, H/2);
        ctx.scale(goScale, goScale);
        ctx.globalAlpha = goAlpha;
        ctx.textAlign = 'center';
        ctx.font = 'bold 72px monospace';
        ctx.shadowColor = '#88ff88';
        ctx.shadowBlur = 40;
        ctx.fillStyle = '#88ff88';
        ctx.fillText('¡VAMOS!', 0, 0);
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    if (introPhase >= 3) drawTouchButtons();

    const barH2 = introPhase >= 3 ? 50 : (introPhase >= 1 ? 35 : 0);
    if (barH2 > 0) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, barH2);
      ctx.fillRect(0, H - barH2, W, barH2);
    }
  }

  }

  if (state === 'menu') {

    const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
    bgGrad.addColorStop(0, '#0a0515');
    bgGrad.addColorStop(0.5, '#1a0a2e');
    bgGrad.addColorStop(0.8, '#2a1020');
    bgGrad.addColorStop(1, '#0a0515');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#ffffff33';
    for (let i = 0; i < 50; i++) {
      const sx = ((i * 137 + menuBgTimer * 0.3) % (W + 20));
      const sy = (i * 97 + 30) % (H * 0.6);
      ctx.fillRect(sx, sy, 1 + (i % 3), 1);
    }

    ctx.fillStyle = '#3a2515';
    ctx.fillRect(0, menuBgFloorY, W, H - menuBgFloorY);
    ctx.fillStyle = '#5a3520';
    ctx.fillRect(0, menuBgFloorY, W, 4);

    ctx.fillStyle = '#2a1a0a';
    for (let i = 0; i < 30; i++) {
      const gx = ((i * 80 - menuBgTimer * 2) % (W + 80)) - 40;
      ctx.fillRect(gx, menuBgFloorY + 10, 30, 3);
      ctx.fillRect(gx + 40, menuBgFloorY + 25, 20, 3);
    }

    for (const b of menuBgBullets) {
      ctx.shadowColor = '#ff4444';
      ctx.shadowBlur = 8;
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    for (let ri = 0; ri < menuBgRunners.length; ri++) {
      const r = menuBgRunners[ri];
      ctx.globalAlpha = 0.6;
      ctx.save();

      const bob = Math.sin(r.frame * Math.PI / 2) * 3;
      const mrW = r.w * PLAYER_IMG_SCALE;
      const mrH = r.h * PLAYER_IMG_SCALE;
      const mrOffX = (r.w - mrW) / 2;
      const mrOffY = r.h - mrH;
      ctx.drawImage(playerImg, r.x + mrOffX, r.y + mrOffY + bob, mrW, mrH);

      ctx.globalAlpha = 0.15;
      for (let t = 1; t <= 3; t++) {
        ctx.drawImage(playerImg, r.x + mrOffX - t * 18, r.y + mrOffY + bob, mrW, mrH);
      }
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(0, 0, W, H);

    ctx.textAlign = 'center';

    const titlePulse = 1 + Math.sin(Date.now() / 600) * 0.03;
    ctx.save();
    ctx.translate(W/2, H * 0.18);
    ctx.scale(titlePulse, titlePulse);
    ctx.shadowColor = '#f0c040';
    ctx.shadowBlur = 30;
    ctx.fillStyle = '#f0c040';
    ctx.font = `bold ${Math.min(56, W * 0.07)}px monospace`;
    ctx.fillText('CRUZA LA FRONTERA', 0, 0);
    ctx.shadowBlur = 15;
    ctx.fillText('CRUZA LA FRONTERA', 0, 0);
    ctx.shadowBlur = 0;
    ctx.restore();

    ctx.fillStyle = '#cc6644';
    ctx.font = `${Math.min(16, W * 0.022)}px monospace`;
    ctx.fillText('Cross the Border · Fight the Power · Survive', W/2, H * 0.24);

    const lineW2 = 300;
    ctx.strokeStyle = '#f0c04066';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(W/2 - lineW2/2, H * 0.27);
    ctx.lineTo(W/2 + lineW2/2, H * 0.27);
    ctx.stroke();

    function drawMenuIcon(type, x, y, size, color) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      const s = size;
      if (type === 'play') {

        ctx.beginPath();
        ctx.moveTo(x - s*0.4, y - s*0.5);
        ctx.lineTo(x + s*0.5, y);
        ctx.lineTo(x - s*0.4, y + s*0.5);
        ctx.closePath();
        ctx.fill();
      } else if (type === 'endless') {

        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.bezierCurveTo(x - s*0.6, y - s*0.6, x - s*0.8, y + s*0.6, x, y);
        ctx.bezierCurveTo(x + s*0.8, y - s*0.6, x + s*0.6, y + s*0.6, x, y);
        ctx.stroke();
      } else if (type === 'difficulty') {

        ctx.beginPath();
        ctx.moveTo(x - s*0.5, y - s*0.5);
        ctx.lineTo(x + s*0.5, y + s*0.5);
        ctx.moveTo(x + s*0.5, y - s*0.5);
        ctx.lineTo(x - s*0.5, y + s*0.5);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x - s*0.2, y - s*0.1);
        ctx.lineTo(x + s*0.2, y - s*0.1);
        ctx.moveTo(x - s*0.2, y + s*0.1);
        ctx.lineTo(x + s*0.2, y + s*0.1);
        ctx.stroke();
      } else if (type === 'settings') {

        ctx.beginPath();
        ctx.arc(x, y, s*0.25, 0, Math.PI*2);
        ctx.stroke();
        for (let a = 0; a < 6; a++) {
          const angle = a * Math.PI / 3;
          ctx.beginPath();
          ctx.moveTo(x + Math.cos(angle)*s*0.3, y + Math.sin(angle)*s*0.3);
          ctx.lineTo(x + Math.cos(angle)*s*0.5, y + Math.sin(angle)*s*0.5);
          ctx.stroke();
        }
      } else if (type === 'controls') {

        ctx.beginPath();
        ctx.roundRect(x - s*0.5, y - s*0.25, s, s*0.5, s*0.15);
        ctx.stroke();

        ctx.fillRect(x - s*0.35, y - s*0.05, s*0.2, s*0.1);
        ctx.fillRect(x - s*0.3, y - s*0.15, s*0.1, s*0.3);

        ctx.beginPath();
        ctx.arc(x + s*0.25, y - s*0.05, s*0.06, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + s*0.35, y + s*0.05, s*0.06, 0, Math.PI*2);
        ctx.fill();
      } else if (type === 'credits') {

        ctx.beginPath();
        ctx.roundRect(x - s*0.3, y - s*0.45, s*0.6, s*0.9, s*0.05);
        ctx.stroke();

        for (let l = 0; l < 3; l++) {
          ctx.fillRect(x - s*0.15, y - s*0.2 + l * s*0.2, s*0.3, s*0.04);
        }
      } else if (type === 'easy') {

        ctx.beginPath();
        ctx.arc(x, y, s*0.4, 0, Math.PI*2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x - s*0.15, y - s*0.1, s*0.05, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + s*0.15, y - s*0.1, s*0.05, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x, y + s*0.05, s*0.2, 0.1, Math.PI - 0.1);
        ctx.stroke();
      } else if (type === 'normal') {

        ctx.beginPath();
        ctx.arc(x, y, s*0.4, 0, Math.PI*2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x - s*0.15, y - s*0.1, s*0.05, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + s*0.15, y - s*0.1, s*0.05, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x - s*0.15, y + s*0.15);
        ctx.lineTo(x + s*0.15, y + s*0.15);
        ctx.stroke();
      } else if (type === 'hard') {

        ctx.beginPath();
        ctx.arc(x, y, s*0.4, 0, Math.PI*2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x - s*0.15, y - s*0.05, s*0.05, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + s*0.15, y - s*0.05, s*0.05, 0, Math.PI*2);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(x - s*0.25, y - s*0.2);
        ctx.lineTo(x - s*0.08, y - s*0.15);
        ctx.moveTo(x + s*0.25, y - s*0.2);
        ctx.lineTo(x + s*0.08, y - s*0.15);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(x, y + s*0.25, s*0.15, Math.PI + 0.3, -0.3);
        ctx.stroke();
      } else if (type === 'insane') {

        ctx.beginPath();
        ctx.arc(x, y - s*0.1, s*0.35, Math.PI, 0);
        ctx.lineTo(x + s*0.35, y + s*0.15);
        ctx.lineTo(x + s*0.15, y + s*0.4);
        ctx.lineTo(x + s*0.05, y + s*0.3);
        ctx.lineTo(x - s*0.05, y + s*0.4);
        ctx.lineTo(x - s*0.15, y + s*0.3);
        ctx.lineTo(x - s*0.35, y + s*0.15);
        ctx.closePath();
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(x - s*0.15, y - s*0.05, s*0.08, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + s*0.15, y - s*0.05, s*0.08, 0, Math.PI*2);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(x, y + s*0.05);
        ctx.lineTo(x - s*0.05, y + s*0.15);
        ctx.lineTo(x + s*0.05, y + s*0.15);
        ctx.closePath();
        ctx.fill();
      } else if (type === 'move') {

        ctx.beginPath();
        ctx.moveTo(x - s*0.5, y);
        ctx.lineTo(x - s*0.2, y - s*0.3);
        ctx.moveTo(x - s*0.5, y);
        ctx.lineTo(x - s*0.2, y + s*0.3);
        ctx.moveTo(x + s*0.5, y);
        ctx.lineTo(x + s*0.2, y - s*0.3);
        ctx.moveTo(x + s*0.5, y);
        ctx.lineTo(x + s*0.2, y + s*0.3);
        ctx.moveTo(x - s*0.5, y);
        ctx.lineTo(x + s*0.5, y);
        ctx.stroke();
      } else if (type === 'jump') {

        ctx.beginPath();
        ctx.moveTo(x, y - s*0.5);
        ctx.lineTo(x - s*0.3, y);
        ctx.moveTo(x, y - s*0.5);
        ctx.lineTo(x + s*0.3, y);
        ctx.moveTo(x, y - s*0.5);
        ctx.lineTo(x, y + s*0.5);
        ctx.stroke();
      } else if (type === 'combat') {

        ctx.beginPath();
        ctx.arc(x, y, s*0.35, 0, Math.PI*2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y - s*0.5);
        ctx.lineTo(x, y + s*0.5);
        ctx.moveTo(x - s*0.5, y);
        ctx.lineTo(x + s*0.5, y);
        ctx.stroke();
      } else if (type === 'wall') {

        ctx.strokeRect(x - s*0.4, y - s*0.4, s*0.8, s*0.8);
        ctx.beginPath();
        ctx.moveTo(x - s*0.4, y - s*0.13); ctx.lineTo(x + s*0.4, y - s*0.13);
        ctx.moveTo(x - s*0.4, y + s*0.13); ctx.lineTo(x + s*0.4, y + s*0.13);
        ctx.moveTo(x, y - s*0.4); ctx.lineTo(x, y - s*0.13);
        ctx.moveTo(x - s*0.2, y - s*0.13); ctx.lineTo(x - s*0.2, y + s*0.13);
        ctx.moveTo(x + s*0.2, y + s*0.13); ctx.lineTo(x + s*0.2, y + s*0.4);
        ctx.stroke();
      } else if (type === 'tip') {

        ctx.beginPath();
        ctx.arc(x, y - s*0.1, s*0.3, Math.PI*0.8, Math.PI*0.2, true);
        ctx.lineTo(x + s*0.15, y + s*0.2);
        ctx.lineTo(x - s*0.15, y + s*0.2);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x - s*0.12, y + s*0.3);
        ctx.lineTo(x + s*0.12, y + s*0.3);
        ctx.moveTo(x - s*0.08, y + s*0.38);
        ctx.lineTo(x + s*0.08, y + s*0.38);
        ctx.stroke();
      }
      ctx.restore();
    }

    if (menuState === 'main') {
      const optionNames = ['PLAY', 'ENDLESS', 'MULTIPLAYER', 'DIFFICULTY', 'SETTINGS', 'CONTROLS', 'FRIENDS', 'CREDITS', 'CHEATS'];
      const optionIcons = ['play', 'endless', 'controls', 'difficulty', 'settings', 'controls', 'credits', 'credits', 'settings'];
      const menuY = H * 0.35;
      const menuSpacing = Math.min(40, (H * 0.40) / (optionNames.length - 1));
      for (let i = 0; i < optionNames.length; i++) {
        const selected = menuSelection === i;
        const y = menuY + i * menuSpacing;

        if (selected) {
          const selW = 280;
          ctx.fillStyle = '#f0c04022';
          ctx.fillRect(W/2 - selW/2, y - 16, selW, 32);
          ctx.strokeStyle = '#f0c040';
          ctx.lineWidth = 2;
          ctx.strokeRect(W/2 - selW/2, y - 16, selW, 32);

          ctx.fillStyle = '#f0c040';
          ctx.font = 'bold 19px monospace';
          ctx.shadowColor = '#f0c040';
          ctx.shadowBlur = 10;
        } else {
          ctx.fillStyle = '#aaa';
          ctx.font = '16px monospace';
          ctx.shadowBlur = 0;
        }
        drawMenuIcon(optionIcons[i], W/2 - 80, y, 18, selected ? '#f0c040' : '#aaa');
        ctx.fillText(optionNames[i], W/2 + 20, y + 5);
        ctx.shadowBlur = 0;
      }

      const menuBot = menuY + (optionNames.length - 1) * menuSpacing + 30;
      const infoStartY = Math.max(menuBot, H * 0.78);
      const infoGap = Math.min(22, (H - infoStartY - 10) / 5);

      if (playerUsername) {
        ctx.fillStyle = '#88ff88';
        ctx.font = '11px monospace';
        ctx.fillText(`Logged in: ${playerUsername}`, W/2, infoStartY);
      }

      ctx.fillStyle = '#666';
      ctx.font = '12px monospace';
      ctx.fillText(`Difficulty: ${settings.difficulty.toUpperCase()}`, W/2, infoStartY + infoGap);

      ctx.fillStyle = '#555';
      ctx.font = '11px monospace';
      ctx.fillText(_isTouchDev ? 'Tap to select' : 'Click / Tap / Arrow Keys + ENTER', W/2, infoStartY + infoGap * 2);

      ctx.fillStyle = '#333';
      ctx.font = '10px monospace';
      ctx.fillText('v3.0', W/2, infoStartY + infoGap * 3);

      const campaignPulse = 0.7 + Math.sin(Date.now() / 800) * 0.3;
      ctx.globalAlpha = campaignPulse;
      ctx.fillStyle = '#ffaa00';
      ctx.font = 'bold 13px monospace';
      ctx.shadowColor = '#ff880088';
      ctx.shadowBlur = 10;
      ctx.fillText('CAMPAIGN MODE — COMING SOON', W / 2, infoStartY + infoGap * 4);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;

    } else if (menuState === 'multiplayer') {

      ctx.fillStyle = '#44bbff';
      ctx.font = 'bold 28px monospace';
      ctx.fillText('MULTIPLAYER', W/2, H * 0.28);

      const mpItems = ['CREATE ROOM', 'JOIN ROOM', 'FRIENDS', 'BACK'];
      const mpColors = ['#88ff88', '#ffcc44', '#88ccff', '#ff8844'];
      const mpY = H * 0.40;
      const mpSpacing = Math.min(50, (H * 0.28) / (mpItems.length - 1));
      for (let i = 0; i < mpItems.length; i++) {
        const selected = mpMenuSelection === i;
        const y = mpY + i * mpSpacing;

        if (selected) {
          ctx.fillStyle = mpColors[i] + '22';
          ctx.fillRect(W/2 - 160, y - 20, 320, 40);
          ctx.strokeStyle = mpColors[i];
          ctx.lineWidth = 2;
          ctx.strokeRect(W/2 - 160, y - 20, 320, 40);
          ctx.fillStyle = mpColors[i];
          ctx.font = 'bold 20px monospace';
        } else {
          ctx.fillStyle = '#aaa';
          ctx.font = '18px monospace';
        }
        ctx.fillText(mpItems[i], W/2, y + 6);
      }

      if (activeTextInput === 'roomcode') {
        ctx.fillStyle = '#000000cc';
        ctx.fillRect(W/2 - 200, H/2 - 60, 400, 120);
        ctx.strokeStyle = '#ffcc44';
        ctx.lineWidth = 2;
        ctx.strokeRect(W/2 - 200, H/2 - 60, 400, 120);
        ctx.fillStyle = '#ffcc44';
        ctx.font = 'bold 18px monospace';
        ctx.fillText('ENTER ROOM CODE', W/2, H/2 - 30);

        ctx.fillStyle = '#111';
        ctx.fillRect(W/2 - 100, H/2 - 10, 200, 36);
        ctx.strokeStyle = '#ffcc44';
        ctx.strokeRect(W/2 - 100, H/2 - 10, 200, 36);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px monospace';
        const cursor = textCursorBlink < 30 ? '|' : '';
        ctx.fillText(joinRoomInput + cursor, W/2, H/2 + 16);
        ctx.fillStyle = '#888';
        ctx.font = '12px monospace';
        ctx.fillText(_isTouchDev ? 'Type 6-letter code' : 'Type 6-letter code + ENTER', W/2, H/2 + 48);

        if (_isTouchDev) {
          ctx.fillStyle = '#ff6644';
          ctx.fillRect(W/2 - 60, H/2 + 68, 120, 32);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 14px monospace';
          ctx.fillText('CANCEL', W/2, H/2 + 88);
        }
      }

      if (!playerUsername) {
        ctx.fillStyle = '#ff8844';
        ctx.font = '14px monospace';
        const notLogY = Math.max(mpY + (mpItems.length - 1) * mpSpacing + 50, H * 0.72);
        ctx.fillText('You need an account to play multiplayer', W/2, notLogY);
        ctx.fillStyle = '#ffcc44';
        ctx.font = 'bold 14px monospace';
        ctx.fillText('[ Click here to Login / Register ]', W/2, notLogY + 24);
      } else {

        const logY = Math.max(mpY + (mpItems.length - 1) * mpSpacing + 50, H * 0.72);
        ctx.fillStyle = '#88ff88';
        ctx.font = '12px monospace';
        ctx.fillText('Logged in as: ' + playerUsername, W/2, logY);
        const logoutSel = mpMenuSelection === 4;
        ctx.fillStyle = logoutSel ? '#ff6666' : '#aa6666';
        ctx.font = (logoutSel ? 'bold ' : '') + '13px monospace';
        ctx.fillText('[ LOGOUT ]', W/2, logY + 22);
      }

      if (authError) {
        ctx.fillStyle = '#ff4444';
        ctx.font = '13px monospace';
        ctx.fillText(authError, W/2, H * 0.87);
      }

      ctx.fillStyle = '#555';
      ctx.font = '12px monospace';
      ctx.fillText(_isTouchDev ? '< Tap to go back' : 'ESC to go back', W/2, H * 0.92);

    } else if (menuState === 'account') {

      ctx.fillStyle = '#44bbff';
      ctx.font = 'bold 26px monospace';
      ctx.fillText(authScreen === 'register' ? 'CREATE ACCOUNT' : 'LOGIN', W/2, H * 0.28);

      if (authLoading) {
        ctx.fillStyle = '#ffcc44';
        ctx.font = '16px monospace';
        ctx.fillText('Loading...', W/2, H * 0.5);
      } else {
        const accY = H * 0.38;

        ctx.fillStyle = '#888';
        ctx.font = '13px monospace';
        ctx.textAlign = 'left';
        ctx.fillText('Username:', W/2 - 140, accY);
        ctx.fillStyle = activeTextInput === 'username' ? '#222' : '#111';
        ctx.fillRect(W/2 - 140, accY + 4, 280, 28);
        ctx.strokeStyle = activeTextInput === 'username' ? '#ffcc44' : '#555';
        ctx.lineWidth = 1;
        ctx.strokeRect(W/2 - 140, accY + 4, 280, 28);
        ctx.fillStyle = '#fff';
        ctx.font = '14px monospace';
        ctx.fillText(authInputs.username + (activeTextInput === 'username' && textCursorBlink < 30 ? '|' : ''), W/2 - 132, accY + 22);

        const passY = accY + 45;
        ctx.fillStyle = '#888';
        ctx.font = '13px monospace';
        ctx.fillText('Password:', W/2 - 140, passY);
        ctx.fillStyle = activeTextInput === 'password' ? '#222' : '#111';
        ctx.fillRect(W/2 - 140, passY + 4, 280, 28);
        ctx.strokeStyle = activeTextInput === 'password' ? '#ffcc44' : '#555';
        ctx.strokeRect(W/2 - 140, passY + 4, 280, 28);
        ctx.fillStyle = '#fff';
        ctx.font = '14px monospace';
        ctx.fillText('*'.repeat(authInputs.password.length) + (activeTextInput === 'password' && textCursorBlink < 30 ? '|' : ''), W/2 - 132, passY + 22);

        let btnBaseY = passY + 60;
        if (authScreen === 'register') {
          const confY = passY + 45;
          ctx.fillStyle = '#888';
          ctx.font = '13px monospace';
          ctx.fillText('Confirm:', W/2 - 140, confY);
          ctx.fillStyle = activeTextInput === 'confirm' ? '#222' : '#111';
          ctx.fillRect(W/2 - 140, confY + 4, 280, 28);
          ctx.strokeStyle = activeTextInput === 'confirm' ? '#ffcc44' : '#555';
          ctx.strokeRect(W/2 - 140, confY + 4, 280, 28);
          ctx.fillStyle = '#fff';
          ctx.font = '14px monospace';
          ctx.fillText('*'.repeat(authInputs.confirm.length) + (activeTextInput === 'confirm' && textCursorBlink < 30 ? '|' : ''), W/2 - 132, confY + 22);
          btnBaseY = confY + 50;
        }

        ctx.textAlign = 'center';

        ctx.fillStyle = '#88ff8833';
        ctx.fillRect(W/2 - 100, btnBaseY, 200, 32);
        ctx.strokeStyle = '#88ff88';
        ctx.lineWidth = 1;
        ctx.strokeRect(W/2 - 100, btnBaseY, 200, 32);
        ctx.fillStyle = '#88ff88';
        ctx.font = 'bold 16px monospace';
        ctx.fillText(authScreen === 'register' ? 'REGISTER' : 'LOGIN', W/2, btnBaseY + 22);

        ctx.fillStyle = '#88ccff';
        ctx.font = '13px monospace';
        ctx.fillText(authScreen === 'login' ? 'No account? Click to Register' : 'Have account? Click to Login', W/2, btnBaseY + 55);

        ctx.fillStyle = '#aaa';
        ctx.font = '13px monospace';
        ctx.fillText('[ Play as Guest ]', W/2, btnBaseY + 80);

        ctx.fillStyle = '#666';
        ctx.font = '11px monospace';
        ctx.fillText('Tap a field to type', W/2, btnBaseY + 105);
      }

      if (authError) {
        ctx.fillStyle = '#ff4444';
        ctx.font = '13px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(authError, W/2, H * 0.88);
      }

      ctx.textAlign = 'center';
      ctx.fillStyle = '#555';
      ctx.font = '12px monospace';
      ctx.fillText(_isTouchDev ? '< Tap to go back' : 'ESC to go back', W/2, H * 0.94);

    } else if (menuState === 'lobby') {

      ctx.fillStyle = '#44bbff';
      ctx.font = 'bold 22px monospace';
      ctx.fillText('LOBBY', W/2, H * 0.06);

      const rcText = 'Room: ' + (currentRoom || '???');
      ctx.fillStyle = '#00000066';
      const rcW = ctx.measureText(rcText).width + 30;
      ctx.fillRect(W/2 - rcW/2, H * 0.09, rcW, 30);
      ctx.fillStyle = '#ffcc44';
      ctx.font = 'bold 16px monospace';
      ctx.fillText(rcText, W/2, H * 0.09 + 20);

      const colW = Math.min(230, (W - 30) / 2);
      const colL = W/2 - colW - 5;
      const colR = W/2 + 5;

      const pids = Object.keys(roomPlayers);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 13px monospace';
      ctx.textAlign = 'left';
      ctx.fillText('PLAYERS (' + pids.length + '/4)', colL, H * 0.20);
      const pListY = H * 0.24;
      for (let i = 0; i < pids.length; i++) {
        const rp = roomPlayers[pids[i]];
        const y = pListY + i * 22;
        const isMe = pids[i] === myUid();
        ctx.fillStyle = isMe ? '#ffcc44' : '#ccc';
        ctx.font = `${isMe ? 'bold ' : ''}12px monospace`;
        ctx.fillText((rp.username || 'Player') + (isMe ? ' (you)' : ''), colL + 4, y);
      }

      const chatBoxY = H * 0.42;
      const chatBoxH = H * 0.40;
      ctx.fillStyle = '#ffffff08';
      ctx.fillRect(colL, chatBoxY, colW, chatBoxH);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.strokeRect(colL, chatBoxY, colW, chatBoxH);

      ctx.fillStyle = '#666';
      ctx.font = 'bold 10px monospace';
      ctx.fillText('CHAT (tap to type)', colL + 4, chatBoxY - 4);

      const chatStartY = chatBoxY + 16;
      const maxChatVisible = Math.floor((chatBoxH - 30) / 16);
      const chatSlice = roomChat.slice(-maxChatVisible);
      for (let i = 0; i < chatSlice.length; i++) {
        const msg = chatSlice[i];
        ctx.fillStyle = '#88ccff';
        ctx.font = 'bold 10px monospace';
        ctx.fillText(msg.username + ':', colL + 4, chatStartY + i * 16);
        ctx.fillStyle = '#ccc';
        ctx.font = '10px monospace';
        ctx.fillText(msg.text, colL + 4 + (msg.username.length + 1) * 7, chatStartY + i * 16);
      }

      if (chatOpen || activeTextInput === 'chat') {
        ctx.fillStyle = '#222';
        ctx.fillRect(colL + 2, chatBoxY + chatBoxH - 22, colW - 4, 20);
        ctx.strokeStyle = '#ffcc44';
        ctx.strokeRect(colL + 2, chatBoxY + chatBoxH - 22, colW - 4, 20);
        ctx.fillStyle = '#fff';
        ctx.font = '11px monospace';
        ctx.fillText(chatInput + (textCursorBlink < 30 ? '|' : ''), colL + 6, chatBoxY + chatBoxH - 7);
      }

      ctx.textAlign = 'left';
      ctx.fillStyle = '#ffcc44';
      ctx.font = 'bold 13px monospace';
      ctx.fillText('MATCH SETTINGS', colR, H * 0.20);

      if (!isHost) {
        ctx.fillStyle = '#888';
        ctx.font = '10px monospace';
        ctx.fillText('(Host controls)', colR, H * 0.23);
      }

      const settY = H * 0.26;
      const SETT_SPACING = _isTouchDev ? 34 : 26;
      const settItems = [
        { label: 'Game Mode', value: mpGameMode.toUpperCase(), key: 'gameMode' },
        { label: 'Difficulty', value: settings.difficulty.toUpperCase(), key: 'difficulty' },
        { label: 'Double Jump', value: settings.doubleJump ? 'ON' : 'OFF', key: 'doubleJump' },
        { label: 'God Mode', value: cheats.godMode ? 'ON' : 'OFF', key: 'godMode' },
        { label: 'One Hit Kill', value: cheats.oneHitKill ? 'ON' : 'OFF', key: 'oneHitKill' },
        { label: 'Infinite Jumps', value: cheats.infiniteJumps ? 'ON' : 'OFF', key: 'infiniteJumps' },
        { label: 'Speed Boost', value: cheats.speedBoost ? 'ON' : 'OFF', key: 'speedBoost' },
        { label: 'Big Projectiles', value: cheats.bigProjectiles ? 'ON' : 'OFF', key: 'bigProjectiles' },
        { label: 'No Cooldown', value: cheats.noCooldown ? 'ON' : 'OFF', key: 'noCooldown' },
      ];
      for (let i = 0; i < settItems.length; i++) {
        const y = settY + i * SETT_SPACING;
        const sel = isHost && mpSettingsSelection === i;

        if (_isTouchDev && isHost) {
          ctx.fillStyle = sel ? '#ffffff18' : (i % 2 === 0 ? '#ffffff08' : '#ffffff04');
          ctx.fillRect(colR, y - 12, colW, SETT_SPACING - 2);
        }
        ctx.fillStyle = sel ? '#ffcc44' : '#aaa';
        ctx.font = `${sel ? 'bold ' : ''}12px monospace`;
        ctx.fillText(settItems[i].label + ':', colR + 4, y);

        const valColor = settItems[i].value === 'ON' ? '#88ff88' : settItems[i].value === 'OFF' ? '#ff6666' : '#ffffff';
        ctx.fillStyle = sel ? '#ffffff' : valColor;
        ctx.font = `bold 12px monospace`;
        ctx.textAlign = 'right';
        ctx.fillText(settItems[i].value, colR + colW - 4, y);
        ctx.textAlign = 'left';
      }

      ctx.textAlign = 'center';

      if (isHost) {
        ctx.fillStyle = '#88ff8833';
        ctx.fillRect(W/2 - 100, H * 0.88, 200, 32);
        ctx.strokeStyle = '#88ff88';
        ctx.strokeRect(W/2 - 100, H * 0.88, 200, 32);
        ctx.fillStyle = '#88ff88';
        ctx.font = 'bold 16px monospace';
        ctx.fillText('START GAME', W/2, H * 0.88 + 22);
      } else {
        ctx.fillStyle = '#888';
        ctx.font = '14px monospace';
        ctx.fillText('Waiting for host to start...', W/2, H * 0.91);
      }

      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 12px monospace';
      ctx.fillText('< LEAVE', 60, 28);

    } else if (menuState === 'friends') {

      ctx.fillStyle = '#88ccff';
      ctx.font = 'bold 26px monospace';
      ctx.fillText('FRIENDS', W/2, H * 0.18);

      if (!currentUser) {
        ctx.fillStyle = '#ff8844';
        ctx.font = '16px monospace';
        ctx.fillText('Login to use friends!', W/2, H * 0.5);
        ctx.fillStyle = '#555';
        ctx.font = '12px monospace';
        ctx.fillText(_isTouchDev ? '< Tap to go back' : 'ESC to go back', W/2, H * 0.9);
      } else {

        const tabs = ['FRIENDS', 'REQUESTS', 'BLOCKED', 'ADD'];
        const tabW = W / 4;
        for (let i = 0; i < tabs.length; i++) {
          const tx = i * tabW;
          const selected = friendTab === i;
          ctx.fillStyle = selected ? '#88ccff22' : '#00000022';
          ctx.fillRect(tx, H * 0.25, tabW, H * 0.07);
          ctx.strokeStyle = selected ? '#88ccff' : '#444';
          ctx.lineWidth = 1;
          ctx.strokeRect(tx, H * 0.25, tabW, H * 0.07);
          ctx.fillStyle = selected ? '#88ccff' : '#888';
          ctx.font = `${selected ? 'bold ' : ''}13px monospace`;
          ctx.fillText(tabs[i], tx + tabW/2, H * 0.29);
        }

        const listY = H * 0.38;

        if (friendTab === 0) {

          if (friendsList.length === 0) {
            ctx.fillStyle = '#666';
            ctx.font = '14px monospace';
            ctx.fillText('No friends yet', W/2, listY + 20);
          }
          for (let i = 0; i < friendsList.length; i++) {
            const f = friendsList[i];
            const y = listY + i * 36;
            const sel = friendMenuSelection === i;
            if (sel) {
              ctx.fillStyle = '#ffffff11';
              ctx.fillRect(W/2 - 200, y - 10, 400, 30);
            }
            ctx.fillStyle = f.online ? '#88ff88' : '#888';
            ctx.font = '14px monospace';
            ctx.textAlign = 'left';
            ctx.fillText((f.online ? '\u25CF ' : '\u25CB ') + f.username, W/2 - 180, y + 8);

            ctx.fillStyle = '#ff4444';
            ctx.font = '11px monospace';
            ctx.textAlign = 'right';
            ctx.fillText('[REMOVE]', W/2 + 180, y + 8);
            ctx.textAlign = 'center';
          }
        } else if (friendTab === 1) {

          if (friendRequests.length === 0) {
            ctx.fillStyle = '#666';
            ctx.font = '14px monospace';
            ctx.fillText('No pending requests', W/2, listY + 20);
          }
          for (let i = 0; i < friendRequests.length; i++) {
            const r = friendRequests[i];
            const y = listY + i * 36;
            ctx.fillStyle = '#ccc';
            ctx.font = '14px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(r.username, W/2 - 180, y + 8);
            ctx.fillStyle = '#88ff88';
            ctx.font = '11px monospace';
            ctx.textAlign = 'right';
            ctx.fillText('[ACCEPT]', W/2 + 120, y + 8);
            ctx.fillStyle = '#ff4444';
            ctx.fillText('[DENY]', W/2 + 180, y + 8);
            ctx.textAlign = 'center';
          }
        } else if (friendTab === 2) {

          if (blockedUsers.length === 0) {
            ctx.fillStyle = '#666';
            ctx.font = '14px monospace';
            ctx.fillText('No blocked users', W/2, listY + 20);
          }
          for (let i = 0; i < blockedUsers.length; i++) {
            const b = blockedUsers[i];
            const y = listY + i * 36;
            ctx.fillStyle = '#ff8844';
            ctx.font = '14px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(b.username, W/2 - 180, y + 8);
            ctx.fillStyle = '#88ff88';
            ctx.font = '11px monospace';
            ctx.textAlign = 'right';
            ctx.fillText('[UNBLOCK]', W/2 + 180, y + 8);
            ctx.textAlign = 'center';
          }
        } else if (friendTab === 3) {

          ctx.fillStyle = '#ccc';
          ctx.font = '14px monospace';
          ctx.fillText('Enter username to add:', W/2, listY);

          ctx.fillStyle = activeTextInput === 'friendadd' ? '#222' : '#111';
          ctx.fillRect(W/2 - 140, listY + 10, 280, 30);
          ctx.strokeStyle = activeTextInput === 'friendadd' ? '#ffcc44' : '#555';
          ctx.lineWidth = 1;
          ctx.strokeRect(W/2 - 140, listY + 10, 280, 30);
          ctx.fillStyle = '#fff';
          ctx.font = '14px monospace';
          ctx.fillText(friendInput + (activeTextInput === 'friendadd' && textCursorBlink < 30 ? '|' : ''), W/2, listY + 30);

          ctx.fillStyle = '#888';
          ctx.font = '12px monospace';
          ctx.fillText('Tap field + type name + ENTER', W/2, listY + 60);
        }

        if (authError) {
          ctx.fillStyle = '#ff8844';
          ctx.font = '13px monospace';
          ctx.fillText(authError, W/2, H * 0.82);
        } else if (authSuccessMsg) {
          ctx.fillStyle = '#88ff88';
          ctx.font = '13px monospace';
          ctx.fillText(authSuccessMsg, W/2, H * 0.82);
        }

        ctx.fillStyle = '#555';
        ctx.font = '12px monospace';
        ctx.fillText(_isTouchDev ? 'Tap tabs to switch' : 'ESC to go back | \u2190 \u2192 tabs', W/2, H * 0.92);
      }

    } else if (menuState === 'difficulty') {

      ctx.fillStyle = '#f0c040';
      ctx.font = 'bold 28px monospace';
      drawMenuIcon('difficulty', W/2 - 130, H * 0.32 - 4, 22, '#f0c040');
      ctx.fillText('DIFFICULTY', W/2, H * 0.32);

      const diffs = [
        { name: 'EASY', desc: 'More HP, weaker enemies, slower bullets', color: '#88ff88', icon: 'easy' },
        { name: 'NORMAL', desc: 'Balanced challenge', color: '#ffdd44', icon: 'normal' },
        { name: 'HARD', desc: 'Less HP, tougher enemies, faster bullets', color: '#ff8844', icon: 'hard' },
        { name: 'INSANE', desc: 'Minimal HP, brutal enemies, insane speed', color: '#ff2222', icon: 'insane' },
      ];
      const diffY = H * 0.42;
      for (let i = 0; i < diffs.length; i++) {
        const selected = menuSelection === i;
        const current = settings.difficulty === diffs[i].name.toLowerCase();
        const y = diffY + i * 55;

        if (selected) {
          ctx.fillStyle = `${diffs[i].color}22`;
          ctx.fillRect(W/2 - 200, y - 20, 400, 50);
          ctx.strokeStyle = diffs[i].color;
          ctx.lineWidth = 2;
          ctx.strokeRect(W/2 - 200, y - 20, 400, 50);
        }

        if (current) {
          ctx.fillStyle = diffs[i].color;
          ctx.font = 'bold 18px monospace';
          ctx.textAlign = 'left';
          ctx.fillText('\u2713', W/2 - 185, y + 6);
        }

        const iconColor = selected ? diffs[i].color : (current ? diffs[i].color : '#888');
        drawMenuIcon(diffs[i].icon, W/2 - 150, y, 22, iconColor);
        ctx.fillStyle = iconColor;
        ctx.font = `${selected ? 'bold ' : ''}20px monospace`;
        ctx.textAlign = 'left';
        ctx.fillText(diffs[i].name, W/2 - 110, y + 6);
        ctx.textAlign = 'center';

        if (selected) {
          ctx.fillStyle = '#999';
          ctx.font = '12px monospace';
          ctx.fillText(diffs[i].desc, W/2, y + 26);
        }
      }

      ctx.fillStyle = '#666';
      ctx.font = '13px monospace';
      ctx.fillText(`Current: ${settings.difficulty.toUpperCase()}`, W/2, H * 0.82);

      ctx.fillStyle = '#555';
      ctx.font = '12px monospace';
      ctx.fillText(_isTouchDev ? 'Tap to select' : 'Click / ENTER to select -- ESC to go back', W/2, H * 0.88);

    } else if (menuState === 'settings') {

      ctx.fillStyle = '#f0c040';
      ctx.font = 'bold 28px monospace';
      drawMenuIcon('settings', W/2 - 100, H * 0.28 - 4, 22, '#f0c040');
      ctx.fillText('SETTINGS', W/2, H * 0.28);

      const settingsItems = [
        { name: 'Screen Shake', value: settings.screenShake },
        { name: 'Particles', value: settings.particles },
        { name: 'Show FPS', value: settings.showFPS },
        { name: 'Double Jump', value: settings.doubleJump },
        { name: 'Show Timer', value: settings.showTimer },
        { name: 'Colorblind Mode', value: settings.colorblind },
        { name: 'Touch Controls \u25b6', value: 'page' },
        { name: 'BACK', value: null },
      ];
      const setY = H * 0.36;
      for (let i = 0; i < settingsItems.length; i++) {
        const selected = menuSelection === i;
        const y = setY + i * 40;
        const item = settingsItems[i];

        if (selected) {
          ctx.fillStyle = '#f0c04015';
          ctx.fillRect(W/2 - 200, y - 14, 400, 32);
          ctx.strokeStyle = '#f0c04088';
          ctx.lineWidth = 1;
          ctx.strokeRect(W/2 - 200, y - 14, 400, 32);
        }

        if (item.value === null) {
          ctx.fillStyle = selected ? '#ff8844' : '#888';
          ctx.font = `${selected ? 'bold ' : ''}16px monospace`;
          ctx.fillText('<- ' + item.name, W/2, y + 6);
        } else if (item.value === 'page') {
          ctx.fillStyle = selected ? '#88ddff' : '#6699bb';
          ctx.font = `${selected ? 'bold ' : ''}15px monospace`;
          ctx.fillText(item.name, W/2, y + 6);
        } else {
          ctx.fillStyle = selected ? '#fff' : '#aaa';
          ctx.font = `${selected ? 'bold ' : ''}15px monospace`;
          ctx.fillText(item.name, W/2 - 80, y + 6);

          const toggleX = W/2 + 110;
          const toggleW = 40, toggleH = 18;
          ctx.fillStyle = item.value ? (selected ? '#88ff88' : '#448844') : (selected ? '#ff4444' : '#884444');
          ctx.beginPath();
          ctx.roundRect(toggleX - toggleW/2, y - toggleH/2 + 2, toggleW, toggleH, toggleH/2);
          ctx.fill();
          ctx.fillStyle = '#fff';
          const knobX = item.value ? toggleX + toggleW/2 - toggleH/2 : toggleX - toggleW/2 + toggleH/2;
          ctx.beginPath();
          ctx.arc(knobX, y + 2, toggleH/2 - 2, 0, Math.PI*2);
          ctx.fill();
        }
      }

      ctx.fillStyle = '#555';
      ctx.font = '12px monospace';
      ctx.fillText(_isTouchDev ? 'Tap to toggle' : 'Click / ENTER to toggle -- ESC Back', W/2, H * 0.88);

    } else if (menuState === 'touchcontrols') {

      ctx.fillStyle = '#88ddff';
      ctx.font = 'bold 24px monospace';
      ctx.fillText('TOUCH CONTROLS', W/2, H * 0.12);

      ctx.fillStyle = '#aaa';
      ctx.font = '13px monospace';
      ctx.fillText('Current: ' + (touchPresetName === 'custom' ? 'Custom' : TOUCH_PRESETS[touchPresetName]?.name || touchPresetName), W/2, H * 0.18);

      const presetKeys = Object.keys(TOUCH_PRESETS);
      const tcY = H * 0.24;
      for (let i = 0; i < presetKeys.length; i++) {
        const key = presetKeys[i];
        const preset = TOUCH_PRESETS[key];
        const y = tcY + i * 32;
        const selected = touchPresetName === key;
        ctx.fillStyle = selected ? '#88ddff' : '#777';
        ctx.font = `${selected ? 'bold ' : ''}14px monospace`;
        if (selected) {
          ctx.fillStyle = '#88ddff20';
          ctx.fillRect(W/2 - 100, y - 10, 200, 24);
          ctx.strokeStyle = '#88ddff66';
          ctx.lineWidth = 1;
          ctx.strokeRect(W/2 - 100, y - 10, 200, 24);
          ctx.fillStyle = '#88ddff';
        }
        ctx.fillText(preset.name, W/2, y + 6);
      }

      const sizeY = tcY + presetKeys.length * 32 + 16;
      ctx.fillStyle = '#aaa';
      ctx.font = '13px monospace';
      ctx.fillText('Move Size: ' + touchLayout.moveR, W/2, sizeY + 4);

      ctx.fillStyle = '#ff8844';
      ctx.font = 'bold 18px monospace';
      ctx.fillText('[-]', W/2 - 60, sizeY + 5);
      ctx.fillText('[+]', W/2 + 60, sizeY + 5);

      const sizeY2 = sizeY + 28;
      ctx.fillStyle = '#aaa';
      ctx.font = '13px monospace';
      ctx.fillText('Aim Size: ' + touchLayout.aimR, W/2, sizeY2 + 4);
      ctx.fillStyle = '#ff8844';
      ctx.font = 'bold 18px monospace';
      ctx.fillText('[-]', W/2 - 60, sizeY2 + 5);
      ctx.fillText('[+]', W/2 + 60, sizeY2 + 5);

      const resetY = sizeY2 + 32;
      ctx.fillStyle = '#ffaa44';
      ctx.font = '14px monospace';
      ctx.fillText('Reset to Default', W/2, resetY + 4);
      const backY = resetY + 32;
      ctx.fillStyle = '#ff8844';
      ctx.font = 'bold 14px monospace';
      ctx.fillText('<- BACK', W/2, backY + 4);

      const pvTop = H * 0.7;
      const pvH = H - pvTop - 10;
      ctx.fillStyle = '#111';
      ctx.fillRect(20, pvTop, W - 40, pvH);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.strokeRect(20, pvTop, W - 40, pvH);
      ctx.fillStyle = '#444';
      ctx.font = '11px monospace';
      ctx.fillText('Preview  --  Drag joysticks to reposition', W/2, pvTop + 14);

      const pvCenterY = pvTop + pvH / 2 + 8;
      const pvScaleX = (W - 80) / W;
      const pvScaleR = 0.5;
      const pvMCX = 40 + touchLayout.moveX * pvScaleX;
      const pvMCY = pvCenterY;
      const pvACX = 40 + touchLayout.aimX * pvScaleX;
      const pvACY = pvCenterY;

      ctx.globalAlpha = 0.5;
      ctx.strokeStyle = '#88bbff';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(pvMCX, pvMCY, touchLayout.moveR * pvScaleR, 0, Math.PI * 2); ctx.stroke();
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#88bbff';
      ctx.beginPath(); ctx.arc(pvMCX, pvMCY, 14, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#000'; ctx.font = 'bold 9px monospace';
      ctx.fillText('MOVE', pvMCX, pvMCY + 3);

      ctx.globalAlpha = 0.5;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(pvACX, pvACY, touchLayout.aimR * pvScaleR, 0, Math.PI * 2); ctx.stroke();
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.arc(pvACX, pvACY, 14, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#000'; ctx.font = 'bold 9px monospace';
      ctx.fillText('AIM', pvACX, pvACY + 3);
      ctx.globalAlpha = 1.0;

      ctx.fillStyle = '#444';
      ctx.font = '11px monospace';
      ctx.fillText(_isTouchDev ? 'Tap preset or drag joysticks' : 'Click preset or drag joysticks -- ESC Back', W/2, H * 0.97);

    } else if (menuState === 'controls') {

      ctx.fillStyle = '#f0c040';
      ctx.font = 'bold 28px monospace';
      drawMenuIcon('controls', W/2 - 110, H * 0.28 - 4, 22, '#f0c040');
      ctx.fillText('CONTROLS', W/2, H * 0.28);

      const controls = [
        ['< > / A D', 'Move left/right'],
        ['UP / W / SPACE', 'Jump (double jump in air!)'],
        ['F / E / Click', 'Throw projectile'],
        ['ESC', 'Skip cutscenes'],
        ['CLIMB', 'Touch the big wall to climb it'],
      ];
      const ctrlY = H * 0.38;
      for (let i = 0; i < controls.length; i++) {
        const y = ctrlY + i * 38;

        ctx.fillStyle = '#f0c04033';
        ctx.fillRect(W/2 - 170, y - 12, 130, 24);
        ctx.strokeStyle = '#f0c04088';
        ctx.lineWidth = 1;
        ctx.strokeRect(W/2 - 170, y - 12, 130, 24);
        ctx.fillStyle = '#f0c040';
        ctx.font = 'bold 13px monospace';
        ctx.fillText(controls[i][0], W/2 - 105, y + 4);
        ctx.fillStyle = '#ccc';
        ctx.font = '13px monospace';
        ctx.textAlign = 'left';
        ctx.fillText(controls[i][1], W/2 - 20, y + 4);
        ctx.textAlign = 'center';
      }

      ctx.fillStyle = '#ff8844';
      ctx.font = 'bold 14px monospace';
      ctx.fillText('-- TOUCH / MOBILE --', W/2, H * 0.70);
      ctx.fillStyle = '#ccc';
      ctx.font = '12px monospace';
      ctx.fillText('Left side: Move (flick up to jump) | Right side: Throw', W/2, H * 0.75);

      ctx.fillStyle = '#666';
      ctx.font = '12px monospace';
      ctx.fillText(_isTouchDev ? 'Tap anywhere to go back' : 'Click anywhere / ESC / ENTER to go back', W/2, H * 0.88);

    } else if (menuState === 'credits') {

      ctx.fillStyle = '#f0c040';
      ctx.font = 'bold 28px monospace';
      drawMenuIcon('credits', W/2 - 100, H * 0.22 - 4, 22, '#f0c040');
      ctx.fillText('CREDITS', W/2, H * 0.22);

      ctx.strokeStyle = '#f0c04066';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(W/2 - 120, H * 0.27);
      ctx.lineTo(W/2 + 120, H * 0.27);
      ctx.stroke();

      ctx.fillStyle = '#f0c040';
      ctx.font = 'bold 20px monospace';
      ctx.fillText('CRUZA LA FRONTERA', W/2, H * 0.35);

      ctx.fillStyle = '#cc8844';
      ctx.font = '14px monospace';
      ctx.fillText('v2.0', W/2, H * 0.40);

      ctx.fillStyle = '#ccc';
      ctx.font = '15px monospace';
      ctx.fillText('A game about perseverance', W/2, H * 0.48);
      ctx.fillText('and the will to be free.', W/2, H * 0.53);

      ctx.fillStyle = '#ff8844';
      ctx.font = 'bold 14px monospace';
      ctx.fillText('-- BUILT WITH --', W/2, H * 0.63);
      ctx.fillStyle = '#aaa';
      ctx.font = '13px monospace';
      ctx.fillText('HTML5 Canvas + JavaScript', W/2, H * 0.68);
      ctx.fillText('No frameworks, no engines, just code', W/2, H * 0.73);

      ctx.fillStyle = '#666';
      ctx.font = '12px monospace';
      ctx.fillText(_isTouchDev ? 'Tap anywhere to go back' : 'Click anywhere / ESC / ENTER to go back', W/2, H * 0.88);
    } else if (menuState === 'cheats') {

      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 28px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('\u26a0 CHEATS', W/2, H * 0.18);

      ctx.fillStyle = '#ff884488';
      ctx.font = '11px monospace';
      ctx.fillText('Cheats are active during gameplay. Have fun!', W/2, H * 0.23);

      ctx.strokeStyle = '#ff444466';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(W/2 - 200, H * 0.26);
      ctx.lineTo(W/2 + 200, H * 0.26);
      ctx.stroke();

      const cheatKeys = Object.keys(cheats);
      const cheatLabels = ['GOD MODE', 'ONE HIT KILL', 'INFINITE JUMPS', 'SPEED BOOST (2X)', 'BIG PROJECTILES', 'NO COOLDOWN'];
      const cheatDescs = ['Take no damage', 'All attacks kill instantly', 'Unlimited mid-air jumps', 'Double movement speed', 'Larger & faster throws', 'No throw cooldown'];
      const cheatY = H * 0.28;
      const totalItems = cheatKeys.length + 4;

      for (let i = 0; i < totalItems; i++) {
        const y = cheatY + i * 38;
        const selected = cheatSelection === i;

        if (i < cheatKeys.length) {

          const isOn = cheats[cheatKeys[i]];

          if (selected) {
            ctx.fillStyle = '#ff444422';
            ctx.fillRect(W/2 - 220, y - 14, 440, 32);
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 1;
            ctx.strokeRect(W/2 - 220, y - 14, 440, 32);
          }

          const toggleX = W/2 - 200;
          ctx.fillStyle = isOn ? '#44ff44' : '#333';
          ctx.fillRect(toggleX, y - 6, 32, 16);
          ctx.strokeStyle = '#888';
          ctx.lineWidth = 1;
          ctx.strokeRect(toggleX, y - 6, 32, 16);

          ctx.fillStyle = '#fff';
          ctx.fillRect(isOn ? toggleX + 18 : toggleX + 2, y - 4, 12, 12);

          ctx.fillStyle = selected ? '#ff4444' : (isOn ? '#44ff44' : '#aaa');
          ctx.font = `${selected ? 'bold ' : ''}14px monospace`;
          ctx.textAlign = 'left';
          ctx.fillText(cheatLabels[i], W/2 - 150, y + 6);

          ctx.fillStyle = '#666';
          ctx.font = '10px monospace';
          ctx.textAlign = 'right';
          ctx.fillText(cheatDescs[i], W/2 + 210, y + 6);

          ctx.fillStyle = isOn ? '#44ff44' : '#444';
          ctx.font = 'bold 10px monospace';
          ctx.textAlign = 'center';
          ctx.fillText(isOn ? 'ON' : 'OFF', W/2 + 170, y + 6);

        } else if (i === cheatKeys.length) {

          if (selected) {
            ctx.fillStyle = '#44ff4422';
            ctx.fillRect(W/2 - 220, y - 14, 440, 32);
            ctx.strokeStyle = '#44ff44';
            ctx.lineWidth = 1;
            ctx.strokeRect(W/2 - 220, y - 14, 440, 32);
          }
          ctx.fillStyle = selected ? '#44ff44' : '#88cc88';
          ctx.font = `${selected ? 'bold ' : ''}14px monospace`;
          ctx.textAlign = 'left';
          ctx.fillText('ENDLESS START ROUND', W/2 - 150, y + 6);

          ctx.fillStyle = selected ? '#44ff44' : '#aaa';
          ctx.font = 'bold 16px monospace';
          ctx.textAlign = 'center';
          ctx.fillText(`\u25c0  ${endlessStartRound}  \u25b6`, W/2 + 140, y + 6);

          ctx.fillStyle = '#666';
          ctx.font = '10px monospace';
          ctx.textAlign = 'right';
          ctx.fillText(_isTouchDev ? 'Tap left/right to adjust' : '\u2190\u2192 adjust | Shift +10 | Enter reset', W/2 + 210, y + 20);

        } else if (i === cheatKeys.length + 1) {

          if (selected) {
            ctx.fillStyle = '#ff880044';
            ctx.fillRect(W/2 - 180, y - 14, 360, 32);
            ctx.strokeStyle = '#ff8800';
            ctx.lineWidth = 2;
            ctx.strokeRect(W/2 - 180, y - 14, 360, 32);
          }
          ctx.fillStyle = selected ? '#ffaa00' : '#ff8844';
          ctx.font = `bold 16px monospace`;
          ctx.textAlign = 'center';
          ctx.shadowColor = '#ff4400';
          ctx.shadowBlur = selected ? 15 : 0;
          ctx.fillText('\u26a1 SKIP TO FINAL BOSS FIGHT \u26a1', W/2, y + 6);
          ctx.shadowBlur = 0;

        } else if (i === cheatKeys.length + 2) {

          if (selected) {
            ctx.fillStyle = '#4488ff44';
            ctx.fillRect(W/2 - 180, y - 14, 360, 32);
            ctx.strokeStyle = '#4488ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(W/2 - 180, y - 14, 360, 32);
          }
          ctx.fillStyle = selected ? '#66aaff' : '#4488ff';
          ctx.font = `bold 16px monospace`;
          ctx.textAlign = 'center';
          ctx.shadowColor = '#4488ff';
          ctx.shadowBlur = selected ? 15 : 0;
          ctx.fillText('\ud83c\udfac WATCH BOSS CUTSCENE \ud83c\udfac', W/2, y + 6);
          ctx.shadowBlur = 0;

        } else {

          ctx.fillStyle = selected ? '#f0c040' : '#888';
          ctx.font = `${selected ? 'bold ' : ''}14px monospace`;
          ctx.textAlign = 'center';
          ctx.fillText('\u25c0 BACK', W/2, y + 6);
        }
        ctx.textAlign = 'center';
      }

      const activeCount = Object.values(cheats).filter(v => v).length;
      if (activeCount > 0) {
        ctx.fillStyle = '#ff4444';
        ctx.font = 'bold 12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`${activeCount} CHEAT${activeCount > 1 ? 'S' : ''} ACTIVE`, W/2, H * 0.93);
      }

      ctx.fillStyle = '#555';
      ctx.font = '11px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(_isTouchDev ? '< Tap to go back' : 'ESC to go back', W/2, H * 0.97);
    }
  }

  if (state === 'tutorial') {

    ctx.fillStyle = '#0a0515';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);

    ctx.textAlign = 'center';
    ctx.fillStyle = '#f0c040';
    ctx.font = 'bold 30px monospace';
    ctx.fillText('HOW TO PLAY', W/2, H * 0.12);

    for (let i = 0; i < 5; i++) {
      ctx.fillStyle = i === tutorialPage ? '#f0c040' : '#444';
      ctx.beginPath();
      ctx.arc(W/2 - 40 + i * 20, H * 0.17, 5, 0, Math.PI * 2);
      ctx.fill();
    }

    const tutPages = [
      {
        title: 'MOVEMENT',
        lines: [
          'Use < > Arrow Keys or A/D to move',
          'You are trying to reach the border wall!',
          'Dodge guards and their bullets along the way.',
          '',
          'Run fast and stay alive!',
        ],
        icon: 'move',
      },
      {
        title: 'JUMPING',
        lines: [
          _isTouchDev ? 'Flick the move joystick UP to jump' : 'Press UP, W, or SPACE to jump',
          'Jump over walls and onto platforms.',
          '',
          '>> YOU CAN DOUBLE JUMP! <<',
          _isTouchDev ? 'Flick down then up again in mid-air!' : 'Press jump again in mid-air for a second jump!',
          'A blue ring appears when you double jump.',
        ],
        icon: 'jump',
      },
      {
        title: 'COMBAT',
        lines: [
          'Press F or E to throw projectiles at enemies.',
          'Click the mouse to throw too!',
          'Hit guards to take them out.',
          '',
          'You will face powerful BOSSES later!',
          'Bosses have multiple attack phases.',
        ],
        icon: 'combat',
      },
      {
        title: 'THE WALL',
        lines: [
          'At the end of the level is THE BIG WALL.',
          'Touch it and hold UP to climb it!',
          '',
          'Reach the top to trigger the boss fight.',
          'The wall is your gateway to freedom!',
        ],
        icon: 'wall',
      },
      {
        title: 'TIPS',
        lines: [
          `Difficulty: ${settings.difficulty.toUpperCase()}`,
          `You have ${getDiffMult().playerHp} HP`,
          settings.doubleJump ? 'Double Jump: ENABLED' : 'Double Jump: DISABLED',
          '',
          'Your HP resets at each new boss!',
          'Press ESC to skip any cutscene.',
          'Good luck, amigo! Buena suerte!',
        ],
        icon: 'tip',
      },
    ];

    const page = tutPages[tutorialPage];

    if (typeof drawMenuIcon === 'function') {
      drawMenuIcon(page.icon, W/2 - 100, H * 0.3 - 4, 22, '#ff8844');
    }
    ctx.fillStyle = '#ff8844';
    ctx.font = 'bold 26px monospace';
    ctx.fillText(page.title, W/2 + 10, H * 0.3);

    ctx.font = '15px monospace';
    for (let i = 0; i < page.lines.length; i++) {
      const line = page.lines[i];
      if (line.startsWith('>>')) {
        ctx.fillStyle = '#88ccff';
        ctx.font = 'bold 17px monospace';
      } else if (line === '') {
        continue;
      } else {
        ctx.fillStyle = '#ccc';
        ctx.font = '15px monospace';
      }
      ctx.fillText(line, W/2, H * 0.4 + i * 30);
    }

    ctx.fillStyle = '#88ff88';
    ctx.font = 'bold 16px monospace';
    const blink3 = Math.sin(Date.now() / 300) > 0;
    if (blink3) {
      if (tutorialPage < 4) {
        ctx.fillText(_isTouchDev ? '[ TAP → Next ]' : '[ SPACE / ENTER → Next ]', W/2, H * 0.82);
      } else {
        ctx.fillText(_isTouchDev ? '[ TAP → START GAME! ]' : '[ SPACE / ENTER → START GAME! ]', W/2, H * 0.82);
      }
    }
    if (tutorialPage > 0) {
      ctx.fillStyle = '#888';
      ctx.font = '13px monospace';
      ctx.fillText(_isTouchDev ? '← Tap left side' : '← Previous', W/2 - 160, H * 0.82);
    }
    ctx.fillStyle = '#555';
    ctx.font = '11px monospace';
    ctx.fillText('Complete all pages to start playing', W/2, H * 0.9);
  }

  if (state === 'won') {
    ctx.fillStyle = '#000000bb';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#44ff88';
    ctx.font = 'bold 40px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('¡LO LOGRASTE!', W / 2, H / 2 - 60);

    ctx.fillStyle = '#ffdd44';
    ctx.font = '18px monospace';
    ctx.fillText('You made it across the border! ¡Bienvenido!', W / 2, H / 2 - 25);

    if (settings.showTimer) {
      ctx.fillStyle = '#aaa';
      ctx.font = '14px monospace';
      const mins = Math.floor(gameTimer / 3600);
      const secs = Math.floor((gameTimer % 3600) / 60);
      ctx.fillText(`Time: ${mins}:${secs.toString().padStart(2, '0')}`, W / 2, H / 2 + 5);
    }

    if (restartCooldown <= 0) {
      const btnY = H / 2 + 30;
      const btnW = 160, btnH = 48;

      const retryHover = mpRetrySelection === 0;
      ctx.fillStyle = retryHover ? '#44ff8844' : '#ffffff11';
      ctx.fillRect(W/2 - btnW - 10, btnY, btnW, btnH);
      ctx.strokeStyle = retryHover ? '#44ff88' : '#888';
      ctx.lineWidth = 2;
      ctx.strokeRect(W/2 - btnW - 10, btnY, btnW, btnH);
      ctx.fillStyle = retryHover ? '#44ff88' : '#ccc';
      ctx.font = 'bold 18px monospace';
      ctx.fillText('RETRY', W/2 - btnW/2 - 10, btnY + 31);

      const leaveHover = mpRetrySelection === 1;
      ctx.fillStyle = leaveHover ? '#ff444444' : '#ffffff11';
      ctx.fillRect(W/2 + 10, btnY, btnW, btnH);
      ctx.strokeStyle = leaveHover ? '#ff4444' : '#888';
      ctx.strokeRect(W/2 + 10, btnY, btnW, btnH);
      ctx.fillStyle = leaveHover ? '#ff4444' : '#ccc';
      ctx.fillText('LEAVE', W/2 + btnW/2 + 10, btnY + 31);

      if (mpEnabled) {
        const totalPlayers = Object.keys(roomPlayers).length;
        const retryCount = Object.keys(mpRetryVotes).length;
        ctx.fillStyle = '#88ccff';
        ctx.font = '12px monospace';
        ctx.fillText(`Retry votes: ${retryCount}/${totalPlayers}`, W/2, btnY + 68);
        if (mpRetryVotes[myUid()]) {
          ctx.fillStyle = '#88ff88';
          ctx.fillText('✓ You voted to retry', W/2, btnY + 86);
        }
      }
    }
  }

  if (state === 'deathAnim') {

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);

    if (deathAnimVideoPlaying && _deathVid.readyState >= 2) {
      const vw = _deathVid.videoWidth || 1280;
      const vh = _deathVid.videoHeight || 720;

      const scale = Math.min(W / vw, H / vh);
      const dw = vw * scale;
      const dh = vh * scale;
      const dx = (W - dw) / 2;
      const dy = (H - dh) / 2;
      ctx.drawImage(_deathVid, dx, dy, dw, dh);
    }
  }

  if (state === 'dead') {
    ctx.fillStyle = '#000000bb';
    ctx.fillRect(0, 0, W, H);

    ctx.textAlign = 'center';

    if (endless.round > 0) {

      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 36px monospace';
      ctx.fillText('ELIMINATED', W / 2, H / 2 - 80);

      ctx.fillStyle = '#ffcc44';
      ctx.font = 'bold 24px monospace';
      ctx.fillText(`Round ${endless.round}`, W / 2, H / 2 - 45);

      ctx.fillStyle = '#ccc';
      ctx.font = '16px monospace';
      ctx.fillText(`Kills: ${endless.totalKills}`, W / 2, H / 2 - 18);

      if (endless.round >= endless.highScore) {

        drawEndlessIcon(ctx, 'star', W / 2 - 100, H / 2 - 3, 14, '#ffdd44');
        drawEndlessIcon(ctx, 'star', W / 2 + 100, H / 2 - 3, 14, '#ffdd44');
        ctx.fillStyle = '#ffdd44';
        ctx.font = 'bold 14px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('NEW HIGH SCORE!', W / 2, H / 2 + 2);
      } else {
        ctx.fillStyle = '#888';
        ctx.font = '12px monospace';
        ctx.fillText(`Best: Round ${endless.highScore}`, W / 2, H / 2 + 2);
      }
    } else {

      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 36px monospace';
      ctx.fillText('¡ATRAPADO!', W / 2, H / 2 - 60);

      ctx.fillStyle = '#ccc';
      ctx.font = '16px monospace';
      if (mpEnabled) {
        ctx.fillText('All players have been caught!', W / 2, H / 2 - 25);
      } else {
        ctx.fillText('La migra te atrapó! Border patrol got you!', W / 2, H / 2 - 25);
      }

      ctx.fillStyle = '#888';
      ctx.font = '12px monospace';
      ctx.fillText(`Difficulty: ${settings.difficulty.toUpperCase()}`, W / 2, H / 2 + 0);
    }

    if (restartCooldown <= 0) {
      const btnY = H / 2 + 20;
      const btnW = 160, btnH = 48;

      const retryHover = mpRetrySelection === 0;
      ctx.fillStyle = retryHover ? '#44ff8844' : '#ffffff11';
      ctx.fillRect(W/2 - btnW - 10, btnY, btnW, btnH);
      ctx.strokeStyle = retryHover ? '#44ff88' : '#888';
      ctx.lineWidth = 2;
      ctx.strokeRect(W/2 - btnW - 10, btnY, btnW, btnH);
      ctx.fillStyle = retryHover ? '#44ff88' : '#ccc';
      ctx.font = 'bold 18px monospace';
      ctx.fillText('RETRY', W/2 - btnW/2 - 10, btnY + 31);

      const leaveHover = mpRetrySelection === 1;
      ctx.fillStyle = leaveHover ? '#ff444444' : '#ffffff11';
      ctx.fillRect(W/2 + 10, btnY, btnW, btnH);
      ctx.strokeStyle = leaveHover ? '#ff4444' : '#888';
      ctx.strokeRect(W/2 + 10, btnY, btnW, btnH);
      ctx.fillStyle = leaveHover ? '#ff4444' : '#ccc';
      ctx.fillText('LEAVE', W/2 + btnW/2 + 10, btnY + 31);

      if (mpEnabled) {
        const totalPlayers = Object.keys(roomPlayers).length;
        const retryCount = Object.keys(mpRetryVotes).length;
        ctx.fillStyle = '#88ccff';
        ctx.font = '12px monospace';
        ctx.fillText(`Retry votes: ${retryCount}/${totalPlayers}`, W/2, btnY + 68);
        if (mpRetryVotes[myUid()]) {
          ctx.fillStyle = '#88ff88';
          ctx.fillText('✓ You voted to retry', W/2, btnY + 86);
        }
      }
    }
  }

  if (mpSpectating) {
    ctx.fillStyle = '#00000066';
    ctx.fillRect(0, 0, W, 50);
    ctx.fillRect(0, H - 48, W, 48);

    ctx.textAlign = 'center';
    ctx.fillStyle = '#ff6666';
    ctx.font = 'bold 14px monospace';
    ctx.fillText('☠ YOU DIED — SPECTATING ☠', W / 2, 18);

    const aliveList = getAlivePlayerList();
    let targetName = '???';
    if (mpSpectateTarget && roomPlayers[mpSpectateTarget]) {
      targetName = roomPlayers[mpSpectateTarget].username || mpSpectateTarget.substring(0, 6);
    }
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 16px monospace';
    ctx.fillText(targetName, W / 2, 40);

    if (_isTouchDev && aliveList.length > 1) {

      ctx.fillStyle = '#ffffff22';
      ctx.fillRect(0, H - 48, 90, 48);
      ctx.fillRect(W - 90, H - 48, 90, 48);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 28px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('◀', 45, H - 16);
      ctx.fillText('▶', W - 45, H - 16);
    }
    ctx.textAlign = 'center';
    ctx.fillStyle = '#aaaaaa';
    ctx.font = '12px monospace';
    ctx.fillText(_isTouchDev ? 'TAP ARROWS TO SWITCH' : '← A / D → to switch players', W / 2, H - 30);
    ctx.fillStyle = '#88ff88';
    ctx.font = '11px monospace';
    ctx.fillText(`${aliveList.length} player${aliveList.length !== 1 ? 's' : ''} alive`, W / 2, H - 12);
  }

  ctx.restore();

  if (settings.showFPS) {
    if (!window._fpsData) window._fpsData = { frames: 0, last: Date.now(), fps: 60 };
    window._fpsData.frames++;
    const now = Date.now();
    if (now - window._fpsData.last >= 1000) {
      window._fpsData.fps = window._fpsData.frames;
      window._fpsData.frames = 0;
      window._fpsData.last = now;
    }
    const fpsY = (state === 'playing' || state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight') ? 52 : 16;
    ctx.fillStyle = '#88ff88';
    ctx.font = '11px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`FPS: ${window._fpsData.fps}`, 10, fpsY);
  }

  if (settings.showTimer && (state === 'playing' || state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight')) {
    const mins = Math.floor(gameTimer / 3600);
    const secs = Math.floor((gameTimer % 3600) / 60);
    const ms = Math.floor((gameTimer % 60) / 60 * 100);
    ctx.fillStyle = '#ffffff88';
    ctx.font = '12px monospace';
    ctx.textAlign = 'right';
    ctx.fillText(`${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`, W - 50, 52);
  }

  if ((state === 'playing' || state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight') && settings.doubleJump) {
    const jumpColor = player.jumpsLeft > 0 ? '#88ccff' : '#444';
    ctx.fillStyle = jumpColor;
    ctx.font = '11px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`Jumps: ${'●'.repeat(player.jumpsLeft)}${'◁'.repeat(player.maxJumps - player.jumpsLeft)}`, _isTouchDev ? getMoveCenterX() - 30 : 10, _isTouchDev ? getMoveCenterY() - getMoveRadius() - 35 : H - 15);
  }

  const activeCheats = Object.entries(cheats).filter(([k,v]) => v);
  if (activeCheats.length > 0 && state !== 'menu') {
    ctx.save();
    ctx.globalAlpha = 0.7;
    const cheatsY = (state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight') ? 88 : 46;
    ctx.fillStyle = '#ff000088';
    ctx.fillRect(W - 160, cheatsY, 116, 14 + activeCheats.length * 13);
    ctx.strokeStyle = '#ff4444';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 160, cheatsY, 116, 14 + activeCheats.length * 13);
    ctx.fillStyle = '#ff4444';
    ctx.font = 'bold 10px monospace';
    ctx.textAlign = 'right';
    ctx.fillText('CHEATS ON', W - 48, cheatsY + 11);
    ctx.font = '9px monospace';
    ctx.fillStyle = '#ffaa44';
    const cheatShort = {godMode:'GOD',oneHitKill:'1HIT',infiniteJumps:'INF-J',speedBoost:'SPD',bigProjectiles:'BIG-P',noCooldown:'NO-CD'};
    activeCheats.forEach(([k], i) => {
      ctx.fillText(cheatShort[k] || k, W - 48, cheatsY + 23 + i * 13);
    });
    ctx.restore();
  }

  const isFS = !!(document.fullscreenElement || document.webkitFullscreenElement);
  ctx.save();
  ctx.globalAlpha = 0.5;
  ctx.fillStyle = '#000';
  ctx.fillRect(W - 46, 2, 44, 44);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.strokeRect(W - 46, 2, 44, 44);

  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  if (!isFS) {
    const cx = W - 24, cy = 24;

    ctx.beginPath(); ctx.moveTo(cx-7, cy-4); ctx.lineTo(cx-7, cy-7); ctx.lineTo(cx-4, cy-7); ctx.stroke();

    ctx.beginPath(); ctx.moveTo(cx+4, cy-7); ctx.lineTo(cx+7, cy-7); ctx.lineTo(cx+7, cy-4); ctx.stroke();

    ctx.beginPath(); ctx.moveTo(cx-7, cy+4); ctx.lineTo(cx-7, cy+7); ctx.lineTo(cx-4, cy+7); ctx.stroke();

    ctx.beginPath(); ctx.moveTo(cx+4, cy+7); ctx.lineTo(cx+7, cy+7); ctx.lineTo(cx+7, cy+4); ctx.stroke();
  } else {
    const cx = W - 24, cy = 24;
    ctx.beginPath(); ctx.moveTo(cx-3, cy-8); ctx.lineTo(cx-3, cy-3); ctx.lineTo(cx-8, cy-3); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx+3, cy-8); ctx.lineTo(cx+3, cy-3); ctx.lineTo(cx+8, cy-3); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx-3, cy+8); ctx.lineTo(cx-3, cy+3); ctx.lineTo(cx-8, cy+3); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx+3, cy+8); ctx.lineTo(cx+3, cy+3); ctx.lineTo(cx+8, cy+3); ctx.stroke();
  }
  ctx.restore();

  if (mpToasts.length > 0) {
    ctx.save();
    for (let i = 0; i < mpToasts.length; i++) {
      const t = mpToasts[i];
      const alpha = Math.min(1, t.life / 30);
      ctx.globalAlpha = alpha;
      ctx.font = 'bold 16px Arial';
      const tw = ctx.measureText(t.text).width;
      const tx = W / 2 - tw / 2 - 12;
      const ty = 50 + i * 32;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.beginPath();
      ctx.roundRect(tx, ty - 16, tw + 24, 28, 8);
      ctx.fill();
      ctx.fillStyle = t.color;
      ctx.fillText(t.text, W / 2 - tw / 2, ty + 2);
    }
    ctx.restore();
  }

  if (_showPerfPrompt) {
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
    const boxW = Math.min(420, W - 40);
    const boxH = 220;
    const bx = W/2 - boxW/2, by = H/2 - boxH/2;
    ctx.fillStyle = '#1a1a2e';
    ctx.beginPath(); ctx.roundRect(bx, by, boxW, boxH, 16); ctx.fill();
    ctx.strokeStyle = '#f0c040';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(bx, by, boxW, boxH, 16); ctx.stroke();
    ctx.fillStyle = '#f0c040';
    ctx.font = 'bold 20px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('📱 Performance Mode', W/2, by + 40);
    ctx.fillStyle = '#ccc';
    ctx.font = '14px monospace';
    ctx.fillText('We detected you\'re on a', W/2, by + 75);
    ctx.fillText('mobile/tablet device.', W/2, by + 95);
    ctx.fillText('Turn on Performance Mode?', W/2, by + 120);
    ctx.fillStyle = '#888';
    ctx.font = '11px monospace';
    ctx.fillText('(Disables particles & screen shake)', W/2, by + 142);

    const yBtnX = W/2 - 110, yBtnY = by + 160, btnW = 100, btnH = 36;
    ctx.fillStyle = '#22aa44';
    ctx.beginPath(); ctx.roundRect(yBtnX, yBtnY, btnW, btnH, 8); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 15px monospace';
    ctx.fillText('YES', yBtnX + btnW/2, yBtnY + 24);

    const nBtnX = W/2 + 10;
    ctx.fillStyle = '#aa2222';
    ctx.beginPath(); ctx.roundRect(nBtnX, yBtnY, btnW, btnH, 8); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.fillText('NO', nBtnX + btnW/2, yBtnY + 24);

    window._perfYesBtn = { x: yBtnX, y: yBtnY, w: btnW, h: btnH };
    window._perfNoBtn = { x: nBtnX, y: yBtnY, w: btnW, h: btnH };
    ctx.restore();
  }

  if (_showBetaPopup) {
    ctx.save();
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
    const boxW = Math.min(460, W - 40);
    const boxH = 200;
    const bx = W/2 - boxW/2, by = H/2 - boxH/2;

    ctx.fillStyle = '#1a1a2e';
    ctx.beginPath(); ctx.roundRect(bx, by, boxW, boxH, 16); ctx.fill();
    ctx.strokeStyle = '#ff8800';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(bx, by, boxW, boxH, 16); ctx.stroke();

    ctx.fillStyle = '#ff8800';
    ctx.beginPath();
    ctx.moveTo(W/2, by + 22); ctx.lineTo(W/2 - 14, by + 48); ctx.lineTo(W/2 + 14, by + 48);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = '#1a1a2e';
    ctx.font = 'bold 16px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('!', W/2, by + 44);

    ctx.fillStyle = '#ff8800';
    ctx.font = 'bold 22px monospace';
    ctx.fillText('BETA VERSION', W/2, by + 75);

    ctx.fillStyle = '#ccc';
    ctx.font = '14px monospace';
    ctx.fillText('This is the beta version.', W/2, by + 102);
    ctx.fillText('Some stuff might be broken!', W/2, by + 122);

    const okBtnW = 120, okBtnH = 38;
    const okBtnX = W/2 - okBtnW/2, okBtnY = by + boxH - 55;
    ctx.fillStyle = '#ff8800';
    ctx.beginPath(); ctx.roundRect(okBtnX, okBtnY, okBtnW, okBtnH, 8); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.font = 'bold 16px monospace';
    ctx.fillText('GOT IT', W/2, okBtnY + 25);
    window._betaOkBtn = { x: okBtnX, y: okBtnY, w: okBtnW, h: okBtnH };
    ctx.restore();
  }
}
let _lastFrameTime = 0;
let _lastSyncTime = 0;
let _lastEnemySyncTime = 0;
let _tickAccum = 0;
function loop(timestamp) {
  if (!_lastFrameTime) { _lastFrameTime = timestamp; }
  const elapsed = timestamp - _lastFrameTime;
  _lastFrameTime = timestamp;

  _tickAccum += elapsed;
  const ticks = Math.min(Math.floor(_tickAccum / 16.67), 3);
  _tickAccum -= ticks * 16.67;

  if (_tickAccum > 50) _tickAccum = 0;
  try {
    for (let i = 0; i < ticks; i++) update();
    if (ticks > 0) draw();
  } catch (e) { console.error('Game loop error:', e); }
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
