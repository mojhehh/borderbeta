
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="mobile-web-app-capable" content="yes">
<title>Cruza La Frontera - Cross the Border!</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  background: #000;
  width: 100%;
  height: 100%;
  font-family: 'Segoe UI', Arial, sans-serif;
  overflow: hidden;
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  position: fixed;
  overscroll-behavior: none;
}
canvas {
  display: block;
  position: fixed;
  background: #000;
  touch-action: none;
}
#ui { display: none; }
</style>
</head>
<body>
<div id="ui">
  <h1>CRUZA LA FRONTERA</h1>
  <p>Arrow Keys / WASD to move &amp; jump · Dodge la migra · Climb the border wall!</p>
</div>
<canvas id="game"></canvas>
<!-- Hidden input for iOS/iPad virtual keyboard -->
<input id="hiddenInput" type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="position:fixed;left:0;bottom:0;width:100%;height:40px;opacity:0.01;font-size:16px;z-index:9999;pointer-events:none;" />

<!-- Firebase SDK (compat for non-module script) -->
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database-compat.js"></script>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// ── Load Images ──
const playerImg = new Image();
playerImg.src = 'player_new.png';
const PLAYER_IMG_SCALE = 1.4; // draw image wider than hitbox to center cutout
const guardImg = new Image();
guardImg.src = 'guard_new.png';
const projectileImg = new Image();
projectileImg.src = 'projectile.png';
const bossImg = new Image();
bossImg.src = 'trump5.png';
const bossIntroImg = new Image();
bossIntroImg.src = 'trump_intro.png';
const epsteinImg = new Image();
epsteinImg.src = 'TheBigE.png';
const epsteinFilesImg = new Image();
epsteinFilesImg.src = 'classifed folder.png';
const hawkingImg = new Image();
hawkingImg.src = 'mrstephen.png';
const hawkingGoldImg = new Image();
hawkingGoldImg.src = 'goldenstephen.png';
const clintonImg = new Image();
clintonImg.src = 'guard3_new.png';
const muskImg = new Image();
muskImg.src = 'guard4_new.png';
const girlImg = new Image();
girlImg.src = 'girl.png';
const epProjectileImgs = []; // filled after load
function setupEpImgs() { epProjectileImgs.push(epsteinFilesImg, hawkingImg, clintonImg, muskImg, girlImg); }
setTimeout(setupEpImgs, 500);

// Helper: get image height for a given width, preserving aspect ratio (fallback 1.3x)
function imgH(img, w) {
  if (img.naturalWidth && img.naturalHeight) return w * (img.naturalHeight / img.naturalWidth);
  return w * 1.3;
}
// ── Dynamic Sizing ──
// Fixed internal resolution — JS resizes canvas with proper aspect ratio (letterboxing)
const W = 1280;
const H = 720;
let GROUND_Y = H - 80;
canvas.width = W;
canvas.height = H;

// Canvas letterbox scaling — maintains 16:9 on any screen
let canvasScale = 1, canvasOffsetX = 0, canvasOffsetY = 0;
function resizeCanvas() {
  // Use visualViewport when available (iOS Safari address bar changes)
  const vv = window.visualViewport;
  const winW = vv ? vv.width : window.innerWidth;
  const winH = vv ? vv.height : window.innerHeight;
  const aspect = W / H;
  let cw, ch;
  if (winW / winH > aspect) {
    ch = winH;
    cw = ch * aspect;
  } else {
    cw = winW;
    ch = cw / aspect;
  }
  canvasScale = cw / W;
  canvasOffsetX = (winW - cw) / 2;
  canvasOffsetY = (winH - ch) / 2;
  canvas.style.left = canvasOffsetX + 'px';
  canvas.style.top = canvasOffsetY + 'px';
  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => {
  setTimeout(resizeCanvas, 150);
  setTimeout(resizeCanvas, 350);
});
// iOS Safari visual viewport changes (address bar show/hide)
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', resizeCanvas);
}
// Prevent iOS overscroll / bounce
document.addEventListener('touchmove', e => {
  if (e.target === canvas || e.target === document.body || e.target === document.documentElement) {
    e.preventDefault();
  }
}, { passive: false });

// Convert a touch/client coordinate to canvas coordinate
function clientToCanvas(clientX, clientY) {
  return {
    x: (clientX - canvasOffsetX) / canvasScale,
    y: (clientY - canvasOffsetY) / canvasScale
  };
}

const GRAVITY = 0.55;
const PLAYER_SPEED = 5.0;
const JUMP_FORCE = -12.5;
const WALL_CLIMB_SPEED = 3.8;

// ── Game State ──
let state = 'menu'; // menu | tutorial | intro | playing | cutscene | bossfight | bossdialogue | phonecall | epsteinfight | fusioncutscene | fusionfight | splitfight | hawkingRefusal | hawkingDeath | winCutscene | won | dead | arena | lobby
let cameraX = 0;
let cameraY = 0;
let levelWidth = 4000;
let particles = [];
let projectiles = [];
let bullets = [];
let boss = null;
let bossMinions = [];
let arenaPlats = []; // platforms in the boss arena
let bossVfx = []; // special visual effects: {type, x, y, radius, life, maxLife, ...}
let bossDeathTimer = 0; // big death explosion sequence
let screenFlash = 0; // white/red screen flash
let screenFlashColor = '#fff';

// ── In-game toast notifications ──
let mpToasts = []; // [{text, life, color}]
function showToast(text, color = '#ffffff') {
  mpToasts.push({ text, life: 180, color }); // ~3 seconds at 60fps
  if (mpToasts.length > 5) mpToasts.shift();
}
let bossIntroTimer = 0; // boss entrance animation
let mouseX = 0;
let mouseY = 0;
let mouseActive = false;
let shakeTimer = 0;
let epstein = null; // second boss
let phonecallTimer = 0; // phone call cutscene timer
let epsteinProjectiles = []; // files thrown by epstein
let fusionBoss = null; // fused Trump+Epstein boss
let fusionCutsceneTimer = 0; // timer for fusion animation
let miniBosses = []; // split mini-bosses array
let restartCooldown = 0;
// Hawking Undertale-style refusal cutscene
let hawkingRefusalTimer = 0;
let hawkingRefusalPhase = 0; // 0=black, 1=heart appears, 2=heart cracks, 3=heart splits, 4=pieces float, 5=BUT IT REFUSED, 6=heart reforms, 7=white flash, 8=return
let hawkingPhase2 = false; // true after refusal — Hawking is MASSIVE
let hawkingDeathTimer = 0; // epic death scene timer
let hawkingDeathPhase = 0; // phase of the death scene
let winCutsceneTimer = 0; // final win cutscene timer
let winCutsceneOfficeX = 0; // world X position of the citizenship office
// Cinematic intro
let introTimer = 0;
let introPhase = 0; // 0=black, 1=title drop, 2=subtitle, 3=camera sweep, 4=zoom to player, 5=GO!
let introParticles = [];

// Title screen / settings
let menuState = 'main'; // main | settings | difficulty | controls | cheats | credits | account | multiplayer | lobby | friends
let menuSelection = 0;

// Cheats
let cheats = {
  godMode: false,       // invincible
  oneHitKill: false,    // kill bosses in one hit
  infiniteJumps: false, // unlimited jumps
  speedBoost: false,    // 2x player speed
  bigProjectiles: false,// larger, faster projectiles
  noCooldown: false,    // no throw cooldown
};
let cheatSelection = 0;
let menuBgRunners = []; // animated background runners
let menuBgBullets = []; // background bullets to dodge
let menuBgTimer = 0;
let menuBgFloorY = 0;

// Settings
let settings = {
  difficulty: 'normal', // easy | normal | hard | insane
  screenShake: true,
  particles: true,
  showFPS: false,
  musicVolume: 80,
  sfxVolume: 100,
  touchButtons: true,
  doubleJump: true,
  showTimer: false,
  colorblind: false,
};

// ── iPad/Touch Performance Mode Prompt ──
let _perfPromptShown = localStorage.getItem('perfPromptDismissed') === 'true';
let _showPerfPrompt = false;
// Detect iPad/mobile and offer performance mode on first visit
(function checkPerfPrompt() {
  if (_perfPromptShown) return;
  const isTouch = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
  const isIpad = /iPad|Macintosh/i.test(navigator.userAgent) && navigator.maxTouchPoints > 1;
  const isMobile = /iPhone|Android|webOS|iPod/i.test(navigator.userAgent);
  if (isTouch || isIpad || isMobile) {
    _showPerfPrompt = true;
  }
})();
function _acceptPerfMode() {
  settings.particles = false;
  settings.screenShake = false;
  _showPerfPrompt = false;
  _perfPromptShown = true;
  localStorage.setItem('perfPromptDismissed', 'true');
}
function _declinePerfMode() {
  _showPerfPrompt = false;
  _perfPromptShown = true;
  localStorage.setItem('perfPromptDismissed', 'true');
}

// ── TOUCH CONTROL LAYOUT SYSTEM ──
const TOUCH_PRESETS = {
  default: { name: 'Default', moveX: 140, moveY: 600, moveR: 70, aimX: 1140, aimY: 600, aimR: 70 },
  lefty:   { name: 'Lefty',   moveX: 1140, moveY: 600, moveR: 70, aimX: 140, aimY: 600, aimR: 70 },
  compact: { name: 'Compact', moveX: 100, moveY: 640, moveR: 50, aimX: 1180, aimY: 640, aimR: 50 },
  spread:  { name: 'Spread',  moveX: 160, moveY: 540, moveR: 80, aimX: 1120, aimY: 540, aimR: 80 },
  high:    { name: 'High',    moveX: 140, moveY: 480, moveR: 65, aimX: 1140, aimY: 480, aimR: 65 },
};
let touchLayout = Object.assign({}, TOUCH_PRESETS.default);
let touchPresetName = 'default';
// Load from localStorage
(function loadTouchLayout() {
  try {
    const saved = localStorage.getItem('touchLayout');
    if (saved) {
      const parsed = JSON.parse(saved);
      touchLayout = Object.assign({}, TOUCH_PRESETS.default, parsed);
    }
    const savedPreset = localStorage.getItem('touchPreset');
    if (savedPreset) touchPresetName = savedPreset;
  } catch(e) {}
})();
function saveTouchLayout() {
  localStorage.setItem('touchLayout', JSON.stringify(touchLayout));
  localStorage.setItem('touchPreset', touchPresetName);
}
// Touch controls editor state
let tcDragging = null; // 'move' | 'aim' | null
let tcResizing = null; // 'move' | 'aim' | null
let tcDragOffX = 0, tcDragOffY = 0;
let tutorialPage = 0;
let tutorialDone = localStorage.getItem('tutorialDone') === 'true'; // check local first
function completeTutorial() {
  tutorialDone = true;
  localStorage.setItem('tutorialDone', 'true');
  if (currentUser) {
    db.ref('users/' + currentUser.uid + '/tutorialDone').set(true);
  }
  startGame();
}
let gameTimer = 0; // track play time

// Difficulty multipliers
function getPlayerCountMult() {
  if (!mpEnabled) return 1;
  const count = Math.max(1, Object.keys(roomPlayers).length);
  // 1 player = 1x, 2 players = 1.8x, 3 = 2.4x, 4 = 3x
  if (count === 1) return 1;
  if (count === 2) return 1.8;
  if (count === 3) return 2.4;
  return 3;
}
function getDiffMult() {
  const pm = getPlayerCountMult();
  switch(settings.difficulty) {
    case 'easy': return { dmg: 0.5 * pm, enemyHp: 0.7 * pm, enemySpeed: 0.85, playerHp: 20, projSpeed: 0.75 };
    case 'normal': return { dmg: 1.0 * pm, enemyHp: 1.0 * pm, enemySpeed: 1.0, playerHp: 15, projSpeed: 1.0 };
    case 'hard': return { dmg: 1.5 * pm, enemyHp: 1.4 * pm, enemySpeed: 1.2, playerHp: 12, projSpeed: 1.2 };
    case 'insane': return { dmg: 2.2 * pm, enemyHp: 1.8 * pm, enemySpeed: 1.45, playerHp: 8, projSpeed: 1.45 };
    default: return { dmg: 1.0 * pm, enemyHp: 1.0 * pm, enemySpeed: 1.0, playerHp: 15, projSpeed: 1.0 };
  }
}

// Init menu background
function initMenuBg() {
  menuBgFloorY = H - 100;
  menuBgRunners = [];
  menuBgBullets = [];
  menuBgTimer = 0;
  // Spawn 3 runners at different positions
  for (let i = 0; i < 3; i++) {
    menuBgRunners.push({
      x: 100 + i * 250, y: menuBgFloorY - 60,
      w: 40, h: 60, vy: 0,
      onGround: true, frame: 0, frameTimer: 0,
      jumpTimer: 60 + Math.floor(Math.random() * 80),
    });
  }
}
initMenuBg();

// ══════════════════════════════════════════════════════
// ── FIREBASE + MULTIPLAYER SYSTEM ──
// ══════════════════════════════════════════════════════

// Firebase init
const firebaseConfig = {
  apiKey: "AIzaSyDRKmh2UiXCV8qXw7Ugq-H5I5Phz5Bu720",
  authDomain: "border-f1340.firebaseapp.com",
  projectId: "border-f1340",
  storageBucket: "border-f1340.firebasestorage.app",
  messagingSenderId: "755794545025",
  appId: "1:755794545025:web:ca32b027df866d6a900080",
  databaseURL: "https://border-f1340-default-rtdb.firebaseio.com",
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();

// ── Auth State ──
let currentUser = null;       // firebase auth user
let playerUsername = '';       // display name only
let authError = '';            // error message to show
let authScreen = 'login';     // login | register | main
let authInputField = 0;       // 0=username, 1=password, 2=confirm(register)
let authInputs = { username: '', password: '', confirm: '' };
let authLoading = false;

// ── Multiplayer State ──
let mpEnabled = false;        // is multiplayer active?
let isHost = false;           // am I the room host?
let currentRoom = null;       // room code string
let roomRef = null;           // firebase ref to current room
let roomPlayers = {};         // {uid: {x, y, username, hp, maxHp, facing, alive, ...}}
let roomChat = [];            // [{username, text, time}]
let chatInput = '';           // current chat message being typed
let chatOpen = false;         // is chat input open?
let mpSyncTimer = 0;          // throttle sync writes
let lastSyncData = '';        // dedup
let mpEnemyData = {};         // synced enemy data from host
let joinRoomInput = '';       // room code input when joining
let mpMenuSelection = 0;      // selection in multiplayer menu
let mpGameStarted = false;    // has game actually started in MP?

// ── Friend System State ──
let friendsList = [];         // [{uid, username, online}]
let friendRequests = [];      // [{uid, username}]
let blockedUsers = [];        // [{uid, username}]
let friendInput = '';         // username to add
let friendMenuSelection = 0;
let friendTab = 0;            // 0=friends, 1=requests, 2=blocked, 3=add
let authSuccessMsg = '';      // green success messages
let friendsBackTo = 'main';  // where to go when leaving friends screen
let mpDeathSynced = false;    // prevent spamming death sync every frame
let mpDamageQueueRef = null;  // Firebase ref for guest damage events
let mpSpectating = false;     // true when local player is dead but spectating others
let mpSpectateTarget = null;  // uid of the player being spectated
let mpSpectateIndex = 0;      // index into alive player list for cycling
let mpRetryVotes = {};        // { uid: true } — players who want to retry
let mpRetrySelection = 0;     // 0 = retry, 1 = leave (for win/lose screen)
let mpMatchSettings = null;   // { difficulty, cheats } from host lobby
let mpSettingsSelection = 0;  // lobby settings cursor

// Check if other MP players are still alive
function getAlivePlayerList() {
  const alive = [];
  const uid = myUid();
  for (const pid in roomPlayers) {
    if (pid === uid) continue;
    const rp = roomPlayers[pid];
    if (rp && rp.alive && rp.hp > 0) alive.push({ uid: pid, ...rp });
  }
  return alive;
}

// Handle player death — spectate in MP, game over in solo
function handlePlayerDeath() {
  const p = player;
  p.alive = false;
  p.hp = 0;
  p.iFrames = 99999; // prevent all further damage checks
  shakeTimer = 15;
  spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4444', 25);
  restartCooldown = 40;
  if (mpEnabled) {
    syncMyPositionImmediate();
    mpDeathSynced = true;
    const alive = getAlivePlayerList();
    if (alive.length > 0) {
      // Enter spectator mode
      mpSpectating = true;
      mpSpectateIndex = 0;
      mpSpectateTarget = alive[0].uid;
    } else {
      // All players dead
      state = 'dead';
      mpSpectating = false;
    }
  } else {
    state = 'dead';
  }
}

// ── Text Input System ──  
let activeTextInput = null;   // which input is active: 'username'|'password'|'confirm'|'chat'|'roomcode'|'friendadd'|null
let textCursorBlink = 0;

// Hidden input for iOS/iPad virtual keyboard
const _hiddenInput = document.getElementById('hiddenInput');
function _focusHiddenInput(inputType) {
  if (!_hiddenInput) return;
  const cur = _getTextInputValue(inputType);
  _hiddenInput.value = cur || '';
  _hiddenInput.setAttribute('maxlength', inputType === 'chat' ? '100' : inputType === 'roomcode' ? '6' : '20');
  _hiddenInput.type = (inputType === 'password' || inputType === 'confirm') ? 'password' : 'text';
  _hiddenInput.style.pointerEvents = 'auto';
  // iOS requires focus in same call stack as user gesture — no setTimeout
  _hiddenInput.focus();
  // Fallback for older iOS
  setTimeout(() => { if (document.activeElement !== _hiddenInput) _hiddenInput.focus(); }, 100);
}
function _blurHiddenInput() {
  if (!_hiddenInput) return;
  _hiddenInput.blur();
  _hiddenInput.style.pointerEvents = 'none';
}
function _getTextInputValue(type) {
  if (type === 'username') return authInputs.username;
  if (type === 'password') return authInputs.password;
  if (type === 'confirm') return authInputs.confirm;
  if (type === 'chat') return chatInput;
  if (type === 'roomcode') return joinRoomInput;
  if (type === 'friendadd') return friendInput;
  return '';
}
function _setTextInputValue(type, v) {
  if (type === 'username') authInputs.username = v;
  else if (type === 'password') authInputs.password = v;
  else if (type === 'confirm') authInputs.confirm = v;
  else if (type === 'chat') chatInput = v;
  else if (type === 'roomcode') joinRoomInput = v;
  else if (type === 'friendadd') friendInput = v;
}
function activateTextInput(type) {
  activeTextInput = type;
  _focusHiddenInput(type);
}
function deactivateTextInput() {
  activeTextInput = null;
  _blurHiddenInput();
}
// Sync hidden input → game state on every input event (iOS keyboard)
if (_hiddenInput) {
  _hiddenInput.addEventListener('input', () => {
    if (!activeTextInput) return;
    let val = _hiddenInput.value;
    // Apply filters
    if (activeTextInput === 'username') val = val.replace(/[^a-zA-Z0-9_\-]/g, '');
    if (activeTextInput === 'roomcode') val = val.toUpperCase();
    const maxLen = activeTextInput === 'chat' ? 100 : activeTextInput === 'roomcode' ? 6 : 20;
    val = val.slice(0, maxLen);
    _hiddenInput.value = val;
    _setTextInputValue(activeTextInput, val);
  });
  _hiddenInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      if (activeTextInput === 'chat') { sendChatMessage(); chatOpen = false; deactivateTextInput(); }
      else if (activeTextInput === 'roomcode') { joinRoom(joinRoomInput); deactivateTextInput(); }
      else if (activeTextInput === 'friendadd') { addFriend(friendInput); deactivateTextInput(); }
      else if (activeTextInput === 'username' || activeTextInput === 'password' || activeTextInput === 'confirm') {
        if (authScreen === 'register') registerAccount(authInputs.username, authInputs.password);
        else loginAccount(authInputs.username, authInputs.password);
        deactivateTextInput();
      }
      else { deactivateTextInput(); }
    }
  });
}
// Capture typed text for input fields (PC keyboard — also works alongside hidden input)
window.addEventListener('keydown', e => {
  if (!activeTextInput) return;
  e.preventDefault();
  e.stopPropagation();
  if (e.key === 'Escape') {
    if (activeTextInput === 'chat') chatOpen = false;
    deactivateTextInput();
    return;
  }
  let cur = _getTextInputValue(activeTextInput);
  const maxLen = activeTextInput === 'chat' ? 100 : activeTextInput === 'roomcode' ? 6 : 20;
  if (e.key === 'Backspace') { _setTextInputValue(activeTextInput, cur.slice(0, -1)); if (_hiddenInput) _hiddenInput.value = _getTextInputValue(activeTextInput); }
  else if (e.key === 'Tab') {
    if (activeTextInput === 'username') activateTextInput('password');
    else if (activeTextInput === 'password') activateTextInput(authScreen === 'register' ? 'confirm' : 'username');
    else if (activeTextInput === 'confirm') activateTextInput('username');
  }
  else if (e.key === 'Enter') {
    if (activeTextInput === 'chat') { sendChatMessage(); chatOpen = false; deactivateTextInput(); }
    else if (activeTextInput === 'roomcode') { joinRoom(joinRoomInput); deactivateTextInput(); }
    else if (activeTextInput === 'friendadd') { addFriend(friendInput); deactivateTextInput(); }
    else if (activeTextInput === 'username' || activeTextInput === 'password' || activeTextInput === 'confirm') {
      if (authScreen === 'register') registerAccount(authInputs.username, authInputs.password);
      else loginAccount(authInputs.username, authInputs.password);
      deactivateTextInput();
    }
    else { deactivateTextInput(); }
  }
  else if (e.key.length === 1 && cur.length < maxLen) {
    if (activeTextInput === 'username') {
      if (/^[a-zA-Z0-9_\-]$/.test(e.key)) _setTextInputValue(activeTextInput, cur + e.key);
    }
    else if (activeTextInput === 'roomcode') _setTextInputValue(activeTextInput, cur + e.key.toUpperCase());
    else _setTextInputValue(activeTextInput, cur + e.key);
    if (_hiddenInput) _hiddenInput.value = _getTextInputValue(activeTextInput);
  }
}, true); // capture phase so it runs before game keydown

// ── Auth Functions ──
async function registerAccount(username, password) {
  if (authLoading) return;
  if (!username || username.length < 2) { authError = 'Username must be at least 2 characters!'; return; }
  if (!password || password.length < 6) { authError = 'Password must be at least 6 characters!'; return; }
  if (authInputs.confirm !== password) { authError = 'Passwords do not match!'; return; }
  authLoading = true;
  authError = '';
  try {
    const email = username.toLowerCase() + '@gmail.com';
    const cred = await auth.createUserWithEmailAndPassword(email, password);
    await cred.user.updateProfile({ displayName: username });
    currentUser = cred.user;
    playerUsername = username;
    // Save user profile to DB
    await db.ref('users/' + cred.user.uid).set({
      username: username,
      online: true,
      lastSeen: firebase.database.ServerValue.TIMESTAMP,
      friends: {},
      blocked: {},
    });
    authScreen = 'main';
    menuState = 'multiplayer';
    mpMenuSelection = 0;
    authLoading = false;
  } catch (err) {
    authError = err.message.replace('Firebase: ', '').replace(/\(auth\/.*\)/, '').trim();
    if (authError.includes('email-already-in-use')) authError = 'Username already taken!';
    authLoading = false;
  }
}

async function loginAccount(username, password) {
  if (authLoading) return;
  if (!username || !password) { authError = 'Enter username and password!'; return; }
  authLoading = true;
  authError = '';
  try {
    const email = username.toLowerCase() + '@gmail.com';
    const cred = await auth.signInWithEmailAndPassword(email, password);
    currentUser = cred.user;
    playerUsername = cred.user.displayName || username;
    await db.ref('users/' + cred.user.uid + '/online').set(true);
    await db.ref('users/' + cred.user.uid + '/lastSeen').set(firebase.database.ServerValue.TIMESTAMP);
    authScreen = 'main';
    menuState = 'multiplayer';
    mpMenuSelection = 0;
    authLoading = false;
    loadFriendsList();
  } catch (err) {
    authError = err.message.replace('Firebase: ', '').replace(/\(auth\/.*\)/, '').trim();
    if (authError.includes('user-not-found') || authError.includes('invalid-credential')) authError = 'Wrong username or password!';
    authLoading = false;
  }
}

function logoutAccount() {
  if (currentUser) {
    db.ref('users/' + currentUser.uid + '/online').set(false);
    if (currentRoom) leaveRoom();
  }
  auth.signOut();
  currentUser = null;
  playerUsername = '';
  _myUid = null; // reset guest ID so next guest gets a new one
  friendsList = [];
  friendRequests = [];
  blockedUsers = [];
  authInputs = { username: '', password: '', confirm: '' };
  authError = '';
  authSuccessMsg = '';
  menuState = 'multiplayer';
  mpMenuSelection = 0;
}

function playAsGuest() {
  playerUsername = 'Guest_' + Math.floor(Math.random() * 9999);
  currentUser = null;
  authInputs = { username: '', password: '', confirm: '' };
  authScreen = 'main';
  menuState = 'multiplayer';
  mpMenuSelection = 0;
}

// Auto-login if session exists
auth.onAuthStateChanged(user => {
  if (user) {
    currentUser = user;
    playerUsername = user.displayName || 'Player';
    db.ref('users/' + user.uid + '/online').set(true);
    db.ref('users/' + user.uid + '/online').onDisconnect().set(false);
    db.ref('users/' + user.uid + '/lastSeen').onDisconnect().set(firebase.database.ServerValue.TIMESTAMP);
    // Load tutorial completion from Firebase (sync across devices)
    db.ref('users/' + user.uid + '/tutorialDone').once('value', snap => {
      if (snap.val() === true) {
        tutorialDone = true;
        localStorage.setItem('tutorialDone', 'true');
      }
    });
    loadFriendsList();
  }
});

// ── Room Functions ──
function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

async function createRoom() {
  if (!playerUsername) return;
  const code = generateRoomCode();
  currentRoom = code;
  isHost = true;
  mpEnabled = true;
  mpGameStarted = false;
  roomChat = [];
  roomPlayers = {};
  
  const uid = myUid();
  roomRef = db.ref('rooms/' + code);
  await roomRef.set({
    host: uid,
    hostName: playerUsername,
    state: 'lobby', // lobby | playing | ended
    created: firebase.database.ServerValue.TIMESTAMP,
    players: {
      [uid]: {
        username: playerUsername,
        ready: false,
        alive: true,
        x: 80, y: 560, hp: 15, maxHp: 15, facing: 1,
      }
    },
    chat: {},
    enemies: {},
  });
  
  // Listen for player changes
  setupRoomListeners(code, uid);
  menuState = 'lobby';
}

async function joinRoom(code) {
  if (!playerUsername || !code || code.length !== 6) { authError = 'Enter a valid 6-letter code!'; return; }
  code = code.toUpperCase();
  try {
    const snap = await db.ref('rooms/' + code).once('value');
    if (!snap.exists()) { authError = 'Room not found!'; return; }
    const roomData = snap.val();
    if (roomData.state !== 'lobby') { authError = 'Game already started!'; return; }
    const playerCount = roomData.players ? Object.keys(roomData.players).length : 0;
    if (playerCount >= 4) { authError = 'Room is full! (max 4 players)'; return; }
    
    currentRoom = code;
    isHost = false;
    mpEnabled = true;
    mpGameStarted = false;
    roomChat = [];
    roomPlayers = {};
    
    const uid = myUid();
    roomRef = db.ref('rooms/' + code);
    await roomRef.child('players/' + uid).set({
      username: playerUsername,
      ready: false,
      alive: true,
      x: 80, y: 560, hp: 15, maxHp: 15, facing: 1,
    });
    
    setupRoomListeners(code, uid);
    menuState = 'lobby';
  } catch (err) {
    authError = 'Failed to join room!';
  }
}

// Keep a stable guest ID
let _myUid = null;
function myUid() {
  if (currentUser) return currentUser.uid;
  if (!_myUid) _myUid = 'guest_' + Math.floor(Math.random() * 99999);
  return _myUid;
}

function setupRoomListeners(code, uid) {
  const roomR = db.ref('rooms/' + code);

  // Monitor Firebase connection state
  let _wasConnected = true;
  const connRef = db.ref('.info/connected');
  const _connHandler = connRef.on('value', snap => {
    const connected = snap.val() === true;
    if (_wasConnected && !connected) {
      showToast('Connection lost — reconnecting...', '#ffaa00');
    } else if (!_wasConnected && connected) {
      showToast('Reconnected!', '#44ff88');
    }
    _wasConnected = connected;
  });
  window._mpConnRef = connRef;
  window._mpConnHandler = _connHandler;
  
  // Listen to players
  let _prevPlayerIds = new Set();
  roomR.child('players').on('value', snap => {
    const data = snap.val() || {};
    const newIds = new Set(Object.keys(data));
    const myId = myUid();
    // Detect joins
    for (const pid of newIds) {
      if (!_prevPlayerIds.has(pid) && _prevPlayerIds.size > 0 && pid !== myId) {
        const name = data[pid]?.username || 'Player';
        showToast(name + ' joined', '#44ff88');
      }
    }
    // Detect leaves
    for (const pid of _prevPlayerIds) {
      if (!newIds.has(pid) && pid !== myId) {
        const name = roomPlayers[pid]?.username || 'Player';
        showToast(name + ' disconnected', '#ff6644');
      }
    }
    _prevPlayerIds = newIds;
    roomPlayers = data;
  });
  
  // Listen to chat
  roomR.child('chat').orderByChild('time').limitToLast(50).on('child_added', snap => {
    const msg = snap.val();
    if (msg) roomChat.push(msg);
    if (roomChat.length > 50) roomChat.shift();
  });
  
  // Listen to game state
  roomR.child('state').on('value', snap => {
    const st = snap.val();
    if (st === 'playing' && !mpGameStarted) {
      mpGameStarted = true;
      startGame();
    }
    if (st === 'playing' && mpGameStarted && (state === 'won' || state === 'dead')) {
      // Retry triggered — restart game
      mpRetryVotes = {};
      startGame();
    }
    if (st === 'restarting') {
      // Pre-restart signal — clear votes
      mpRetryVotes = {};
    }
  });
  
  // Listen to retry votes
  roomR.child('retry').on('value', snap => {
    mpRetryVotes = snap.val() || {};
  });
  
  // Listen to enemy data (non-host)
  if (!isHost) {
    roomR.child('enemies').on('value', snap => {
      mpEnemyData = snap.val() || {};
    });
    // Listen to match settings from host
    roomR.child('matchSettings').on('value', snap => {
      const ms = snap.val();
      if (ms) {
        mpMatchSettings = ms;
        // Apply host's settings
        if (ms.difficulty) settings.difficulty = ms.difficulty;
        if (ms.cheats) {
          for (const k in ms.cheats) {
            if (k in cheats) cheats[k] = ms.cheats[k];
          }
        }
        if (typeof ms.doubleJump === 'boolean') settings.doubleJump = ms.doubleJump;
      }
    });
  }
  
  // Detect room deletion (host left) — non-host gets kicked with grace period
  // Allow 5 seconds for host to reconnect (Safari tab switch)
  if (!isHost) {
    let _hostGraceTimeout = null;
    roomR.child('host').on('value', snap => {
      if (!snap.exists() && currentRoom === code) {
        // Start grace period — host might come back
        if (!_hostGraceTimeout) {
          _hostGraceTimeout = setTimeout(() => {
            // Check one more time before leaving
            roomR.child('host').once('value', snap2 => {
              if (!snap2.exists() && currentRoom === code) {
                authError = 'Host left the room!';
                leaveRoom();
              }
              _hostGraceTimeout = null;
            });
          }, 5000);
        }
      } else {
        // Host is back — cancel grace period
        if (_hostGraceTimeout) {
          clearTimeout(_hostGraceTimeout);
          _hostGraceTimeout = null;
        }
      }
    });
  }
  
  // Host listens for guest damage events
  if (isHost) {
    mpDamageQueueRef = roomR.child('damageQueue');
    mpDamageQueueRef.on('child_added', snap => {
      const dmg = snap.val();
      if (dmg) mpHandleDamageEvent(dmg);
      snap.ref.remove();
    });
    // Host listens for cutscene advance events from other players
    roomR.child('cutsceneAdvance').on('child_added', snap => {
      const evt = snap.val();
      if (evt) {
        if (evt.type === 'advance') {
          advanceCutscene();
        } else if (evt.type === 'skip') {
          // Skip entire cutscene
          if (state === 'cutscene') { cutscene.phase = 3; cutscene.fadeAlpha = 1; cutscene.timer = 0; }
          else if (state === 'fusioncutscene') { fusionCutsceneTimer = 1; }
          else if (state === 'phonecall') { phonecallTimer = 1; }
          else if (state === 'hawkingRefusal') { hawkingRefusalTimer = 1129; }
          else if (state === 'hawkingDeath') { hawkingDeathTimer = 899; }
          else if (state === 'winCutscene') { winCutsceneTimer = 699; }
          else if (state === 'bossdialogue') { bossDialogue.index = bossDialogue.texts.length; advanceCutscene(); }
        }
      }
      snap.ref.remove();
    });
  }

  // Cleanup on disconnect
  roomR.child('players/' + uid).onDisconnect().remove();
  // Host field cleanup on disconnect so guest detects it
  if (isHost) {
    roomR.child('host').onDisconnect().remove();
  }

  // ── Connection resilience (Safari tab switching, brief disconnects) ──
  // Re-establish onDisconnect when returning from background
  const _visHandler = () => {
    if (document.visibilityState === 'visible' && currentRoom) {
      const uid2 = myUid();
      if (!uid2) return;
      const rr = db.ref('rooms/' + currentRoom);
      // Re-establish presence — write player back and reset onDisconnect
      rr.child('players/' + uid2).update({ alive: player ? player.alive : true });
      rr.child('players/' + uid2).onDisconnect().remove();
      if (isHost) {
        rr.child('host').set(uid2);
        rr.child('host').onDisconnect().remove();
      }
    }
  };
  document.addEventListener('visibilitychange', _visHandler);
  // Store handler so leaveRoom can clean it up
  window._mpVisHandler = _visHandler;
}

async function leaveRoom() {
  if (!currentRoom) return;
  const uid = myUid();
  // Remove visibilitychange handler
  if (window._mpVisHandler) {
    document.removeEventListener('visibilitychange', window._mpVisHandler);
    window._mpVisHandler = null;
  }
  // Remove connection state listener
  if (window._mpConnRef && window._mpConnHandler) {
    window._mpConnRef.off('value', window._mpConnHandler);
    window._mpConnRef = null;
    window._mpConnHandler = null;
  }
  try {
    await db.ref('rooms/' + currentRoom + '/players/' + uid).remove();
    // If host, delete room
    if (isHost) {
      await db.ref('rooms/' + currentRoom).remove();
    }
  } catch(e) {}
  if (roomRef) {
    roomRef.child('players').off();
    roomRef.child('chat').off();
    roomRef.child('state').off();
    roomRef.child('enemies').off();
    roomRef.child('host').off(); // room deletion listener
    roomRef.child('damageQueue').off();
    roomRef.child('cutsceneAdvance').off();
    roomRef.child('retry').off();
    roomRef.child('matchSettings').off();
    roomRef.off(); // remove room-level listeners too
  }
  currentRoom = null;
  roomRef = null;
  mpEnabled = false;
  isHost = false;
  roomPlayers = {};
  roomChat = [];
  mpGameStarted = false;
  chatOpen = false;
  chatInput = '';
  deactivateTextInput();
  lastSyncData = '';
  mpSyncTimer = 0;
  mpEnemySyncTimer = 0;
  mpEnemyData = {};
  mpDeathSynced = false;
  mpSpectating = false;
  mpSpectateTarget = null;
  mpSpectateIndex = 0;
  mpRetryVotes = {};
  mpRetrySelection = 0;
  mpMatchSettings = null;
  menuState = 'multiplayer';
  mpMenuSelection = 0;
}

async function startMultiplayerGame() {
  if (!isHost || !currentRoom) return;
  chatOpen = false;
  chatInput = '';
  deactivateTextInput();
  // Sync match settings to all players
  await db.ref('rooms/' + currentRoom + '/matchSettings').set({
    difficulty: settings.difficulty,
    cheats: cheats,
    doubleJump: settings.doubleJump,
  });
  await db.ref('rooms/' + currentRoom + '/state').set('playing');
  mpGameStarted = true;
  startGame();
}

function sendChatMessage() {
  if (!currentRoom || !chatInput.trim()) return;
  db.ref('rooms/' + currentRoom + '/chat').push({
    username: playerUsername,
    text: chatInput.trim(),
    time: firebase.database.ServerValue.TIMESTAMP,
  });
  chatInput = '';
}

// ── Multiplayer Sync ──
function syncMyPositionImmediate() {
  // Force-sync player state now (used on death, critical events)
  if (!mpEnabled || !currentRoom || !player) return;
  const uid = myUid();
  db.ref('rooms/' + currentRoom + '/players/' + uid).update({
    alive: player.alive,
    hp: player.hp,
    x: Math.round(player.x),
    y: Math.round(player.y),
    facing: player.facing,
  });
}

function syncMyPosition() {
  if (!mpEnabled || !currentRoom || !player) return;
  const now = Date.now();
  if (now - _lastSyncTime < 50) return; // sync every 50ms (~20Hz wall-clock)
  _lastSyncTime = now;
  
  const uid = myUid();
  const data = {
    username: playerUsername,
    x: Math.round(player.x),
    y: Math.round(player.y),
    hp: player.hp,
    maxHp: player.maxHp,
    facing: player.facing,
    alive: player.alive,
    runFrame: player.runFrame,
    climbingBigWall: player.climbingBigWall,
    iFrames: player.iFrames,
    throwCooldown: player.throwCooldown,
  };
  // Include projectile positions for other players to render
  if (projectiles.length > 0) {
    data.projectiles = projectiles.map(pj => ({
      x: Math.round(pj.x), y: Math.round(pj.y),
      vx: Math.round(pj.vx * 10) / 10, vy: Math.round(pj.vy * 10) / 10,
      w: pj.w, h: pj.h
    }));
  } else {
    data.projectiles = null;
  }
  const dataStr = JSON.stringify(data);
  if (dataStr === lastSyncData) return; // no change
  lastSyncData = dataStr;
  
  db.ref('rooms/' + currentRoom + '/players/' + uid).update(data);
}

let mpEnemySyncTimer = 0;
function syncEnemyData() {
  if (!mpEnabled || !isHost || !currentRoom) return;
  const now = Date.now();
  if (now - _lastEnemySyncTime < 100) return; // sync every 100ms (~10Hz wall-clock)
  _lastEnemySyncTime = now;

  const enemies = {};
  // Sync ALL guards (including dead) to maintain index alignment
  enemies.guards = guards.map(g => ({
    x: Math.round(g.x), y: Math.round(g.y), dir: g.dir,
    hp: g.hp, maxHp: g.maxHp, dead: g.dead,
    alert: g.alert, frame: g.frame, climbing: g.climbing,
    w: g.w, h: g.h
  }));
  // Boss (full state for rendering + contact damage)
  if (boss) {
    enemies.boss = {
      x: Math.round(boss.x), y: Math.round(boss.y), w: boss.w, h: boss.h,
      hp: boss.hp, maxHp: boss.maxHp, dir: boss.dir, dead: boss.dead,
      phase: boss.phase, frame: boss.frame, alert: boss.alert,
      charging: boss.charging, slamming: boss.slamming,
      chargeVx: boss.chargeVx, speed: boss.speed, vy: boss.vy,
      _slamShock: boss._slamShock || 0
    };
  }
  // Epstein (full state)
  if (epstein) {
    enemies.epstein = {
      x: Math.round(epstein.x), y: Math.round(epstein.y), w: epstein.w, h: epstein.h,
      hp: epstein.hp, maxHp: epstein.maxHp, dir: epstein.dir, dead: epstein.dead,
      phase: epstein.phase, frame: epstein.frame,
      charging: epstein.charging, chargeVx: epstein.chargeVx
    };
  }
  // Fusion Boss (full state)
  if (fusionBoss) {
    enemies.fusion = {
      x: Math.round(fusionBoss.x), y: Math.round(fusionBoss.y), w: fusionBoss.w, h: fusionBoss.h,
      hp: fusionBoss.hp, maxHp: fusionBoss.maxHp, dir: fusionBoss.dir, dead: fusionBoss.dead,
      phase: fusionBoss.phase, frame: fusionBoss.frame,
      charging: fusionBoss.charging, chargeVx: fusionBoss.chargeVx, mergeGlow: fusionBoss.mergeGlow,
      _slamShock: fusionBoss._slamShock || 0
    };
  }
  // Mini-Bosses (full state)
  if (miniBosses.length > 0) {
    enemies.minis = miniBosses.map(mb => ({
      x: Math.round(mb.x), y: Math.round(mb.y), w: mb.w, h: mb.h,
      hp: mb.hp, maxHp: mb.maxHp, dead: mb.dead, dir: mb.dir,
      name: mb.name, color: mb.color, frame: mb.frame, speed: mb.speed, vy: mb.vy,
      imgKey: mb.imgKey,
      _slamShock: mb._slamShock || 0,
      _gravPull: mb._gravPull || null
    }));
  }
  // Boss Minions (dynamically spawned)
  if (bossMinions.length > 0) {
    enemies.bossMinions = bossMinions.map(m => ({
      x: Math.round(m.x), y: Math.round(m.y), w: m.w, h: m.h,
      hp: m.hp, maxHp: m.maxHp, dead: m.dead, dir: m.dir, speed: m.speed, frame: m.frame
    }));
  }
  // Boss bullets
  if (bullets.length > 0) {
    enemies.bullets = bullets.map(b => ({
      x: Math.round(b.x), y: Math.round(b.y), vx: b.vx, vy: b.vy, life: b.life
    }));
  }
  // Epstein/boss projectiles
  if (epsteinProjectiles.length > 0) {
    enemies.epProj = epsteinProjectiles.map(ep => ({
      x: Math.round(ep.x), y: Math.round(ep.y), vx: ep.vx, vy: ep.vy,
      size: ep.size, rotation: ep.rotation, life: ep.life, imgIdx: ep.imgIdx
    }));
  }

  // Sync game state, cutscene, dialogue, and timers for all players
  enemies.gameState = state;
  enemies.cutscenePhase = cutscene.phase;
  enemies.cutsceneDI = cutscene.dialogueIndex;
  enemies.cutsceneFA = Math.round(cutscene.fadeAlpha * 100) / 100;
  enemies.bdActive = bossDialogue.active;
  enemies.bdIndex = bossDialogue.index;
  if (bossDialogue.active && bossDialogue.texts) enemies.bdTexts = bossDialogue.texts;
  enemies.phonecallT = phonecallTimer;
  enemies.fusionCT = fusionCutsceneTimer;
  enemies.bossIntroT = bossIntroTimer;
  enemies.bossDeathT = bossDeathTimer;
  enemies.shakeT = shakeTimer;
  enemies.hawkP2 = hawkingPhase2;
  enemies.hawkRefT = hawkingRefusalTimer;
  enemies.hawkDeathT = hawkingDeathTimer;
  enemies.winCutT = winCutsceneTimer;

  db.ref('rooms/' + currentRoom + '/enemies').set(enemies);
}

// Apply synced enemy data from host (guest only, called every frame)
function applyEnemyData() {
  if (!mpEnabled || isHost || !mpEnemyData) return;
  const d = mpEnemyData;
  // Apply guards
  if (d.guards && guards.length > 0) {
    for (let i = 0; i < d.guards.length && i < guards.length; i++) {
      const sg = d.guards[i];
      guards[i].x = sg.x; guards[i].y = sg.y; guards[i].dir = sg.dir;
      guards[i].hp = sg.hp; guards[i].dead = sg.dead;
      guards[i].alert = sg.alert; guards[i].frame = sg.frame;
      guards[i].climbing = sg.climbing;
    }
  }
  // Apply boss
  if (d.boss) {
    if (!boss) {
      boss = { frameTimer: 0, phaseTriggered2: false, phaseTriggered3: false,
        attackTimer: 0, currentAttack: 'shoot', summonCooldown: 300, shootCooldown: 50 };
    }
    boss.x = d.boss.x; boss.y = d.boss.y; boss.w = d.boss.w; boss.h = d.boss.h;
    boss.hp = d.boss.hp; boss.maxHp = d.boss.maxHp; boss.dir = d.boss.dir;
    boss.dead = d.boss.dead; boss.phase = d.boss.phase; boss.frame = d.boss.frame;
    boss.charging = d.boss.charging; boss.slamming = d.boss.slamming;
    boss.chargeVx = d.boss.chargeVx || 0; boss.alert = d.boss.alert;
    boss.speed = d.boss.speed; boss.vy = d.boss.vy;
    boss._slamShock = d.boss._slamShock || 0;
  }
  // Apply epstein
  if (d.epstein) {
    if (!epstein) {
      epstein = { frameTimer: 0, phaseTriggered2: false, attackTimer: 0, shootCooldown: 40,
        teleportCooldown: 200, speed: 2.5, vy: 0 };
    }
    epstein.x = d.epstein.x; epstein.y = d.epstein.y; epstein.w = d.epstein.w; epstein.h = d.epstein.h;
    epstein.hp = d.epstein.hp; epstein.maxHp = d.epstein.maxHp; epstein.dir = d.epstein.dir;
    epstein.dead = d.epstein.dead; epstein.phase = d.epstein.phase; epstein.frame = d.epstein.frame;
    epstein.charging = d.epstein.charging; epstein.chargeVx = d.epstein.chargeVx || 0;
  }
  // Apply fusion boss
  if (d.fusion) {
    if (!fusionBoss) {
      fusionBoss = { frameTimer: 0, phaseTriggered2: false, attackTimer: 0, shootCooldown: 30,
        slamCooldown: 200, dashCooldown: 150, speed: 3, vy: 0 };
    }
    fusionBoss.x = d.fusion.x; fusionBoss.y = d.fusion.y; fusionBoss.w = d.fusion.w; fusionBoss.h = d.fusion.h;
    fusionBoss.hp = d.fusion.hp; fusionBoss.maxHp = d.fusion.maxHp; fusionBoss.dir = d.fusion.dir;
    fusionBoss.dead = d.fusion.dead; fusionBoss.phase = d.fusion.phase; fusionBoss.frame = d.fusion.frame;
    fusionBoss.charging = d.fusion.charging; fusionBoss.chargeVx = d.fusion.chargeVx || 0;
    fusionBoss.mergeGlow = d.fusion.mergeGlow || 0;
    fusionBoss._slamShock = d.fusion._slamShock || 0;
  }
  // Apply mini-bosses
  if (d.minis) {
    while (miniBosses.length < d.minis.length) {
      miniBosses.push({ frameTimer: 0, attackTimer: 0, shootCooldown: 60, vx: 0, vy: 0 });
    }
    for (let i = 0; i < d.minis.length; i++) {
      const sm = d.minis[i];
      miniBosses[i].x = sm.x; miniBosses[i].y = sm.y; miniBosses[i].w = sm.w; miniBosses[i].h = sm.h;
      miniBosses[i].hp = sm.hp; miniBosses[i].maxHp = sm.maxHp; miniBosses[i].dead = sm.dead;
      miniBosses[i].dir = sm.dir; miniBosses[i].name = sm.name; miniBosses[i].color = sm.color;
      miniBosses[i].frame = sm.frame; miniBosses[i].speed = sm.speed;
      if (sm.imgKey) miniBosses[i].imgKey = sm.imgKey;
      miniBosses[i]._slamShock = sm._slamShock || 0;
      miniBosses[i]._gravPull = sm._gravPull || null;
    }
  }
  // Apply boss minions
  if (d.bossMinions) {
    while (bossMinions.length < d.bossMinions.length) bossMinions.push({ vy: 0, frameTimer: 0 });
    while (bossMinions.length > d.bossMinions.length) bossMinions.pop();
    for (let i = 0; i < d.bossMinions.length; i++) {
      const sm = d.bossMinions[i];
      bossMinions[i].x = sm.x; bossMinions[i].y = sm.y; bossMinions[i].w = sm.w; bossMinions[i].h = sm.h;
      bossMinions[i].hp = sm.hp; bossMinions[i].maxHp = sm.maxHp; bossMinions[i].dead = sm.dead;
      bossMinions[i].dir = sm.dir; bossMinions[i].frame = sm.frame;
    }
  } else {
    bossMinions = [];
  }
  // Apply bullets (full replacement — guest moves them locally between syncs)
  if (d.bullets) {
    bullets = d.bullets.map(b => ({ x: b.x, y: b.y, vx: b.vx, vy: b.vy, life: b.life }));
  } else {
    bullets = [];
  }
  // Apply epstein projectiles
  if (d.epProj) {
    epsteinProjectiles = d.epProj.map(ep => ({
      x: ep.x, y: ep.y, vx: ep.vx, vy: ep.vy,
      size: ep.size, rotation: ep.rotation || 0, life: ep.life, imgIdx: ep.imgIdx
    }));
  } else {
    epsteinProjectiles = [];
  }
  // Apply game state + cutscene/dialogue sync from host
  if (d.gameState) {
    const syncStates = ['cutscene','bossfight','bossdialogue','phonecall','epsteinfight','fusioncutscene','fusionfight','splitfight','hawkingRefusal','hawkingDeath','winCutscene','won','dead'];
    if (syncStates.includes(d.gameState) && state !== d.gameState) {
      const oldState = state;
      // First time entering cutscene — set up cutscene.active so rendering works
      if (d.gameState === 'cutscene' && state !== 'cutscene') {
        cutscene.active = true;
      }
      // Teleport player into arena when entering any fight state for first time
      const fightStates = ['bossfight','epsteinfight','fusionfight','splitfight'];
      const wasInFight = fightStates.includes(oldState);
      if (fightStates.includes(d.gameState) && !wasInFight && bigWall) {
        const arenaW2 = 2400;
        const arenaLeft2 = bigWall.x + bigWall.w/2 - arenaW2/2;
        const arenaBottom2 = bigWall.y + 40 + 800;
        player.x = arenaLeft2 + 100 + Math.random() * 200;
        player.y = arenaBottom2 - player.h - 10;
        player.vy = 0; player.vx = 0;
        player.onGround = true;
        player.climbingBigWall = false;
        player.onWall = false;
        screenFlash = 30;
        screenFlashColor = '#ffffff';
        shakeTimer = 15;
      }
      // HP restore on boss transitions (same as host)
      if (d.gameState === 'epsteinfight' && oldState !== 'epsteinfight') {
        player.maxHp += 5; player.hp = player.maxHp;
      }
      if (d.gameState === 'fusionfight' && oldState !== 'fusionfight') {
        player.maxHp = 40; player.hp = player.maxHp;
      }
      if (d.gameState === 'splitfight' && oldState !== 'splitfight') {
        player.maxHp = 50; player.hp = player.maxHp;
      }
      // Stop spectating on win/lose
      if (d.gameState === 'won' || d.gameState === 'dead' || d.gameState === 'winCutscene') {
        mpSpectating = false;
        restartCooldown = 60;
      }
      // Guest winCutscene setup — revive player, teleport past wall, set office position
      if (d.gameState === 'winCutscene' && oldState !== 'winCutscene') {
        player.alive = true;
        player.hp = player.maxHp;
        player.won = true;
        player.iFrames = 99999;
        winCutsceneTimer = 0;
        if (bigWall) {
          player.x = bigWall.x + bigWall.w + 30;
          player.y = bigWall.y - player.h;
        }
        player.vy = 0; player.vx = 0;
        winCutsceneOfficeX = player.x + 750;
        guards = []; bullets = []; projectiles = []; epsteinProjectiles = []; bossMinions = [];
      }
      state = d.gameState;
    }
  }
  if (typeof d.cutscenePhase === 'number') cutscene.phase = d.cutscenePhase;
  if (typeof d.cutsceneDI === 'number') cutscene.dialogueIndex = d.cutsceneDI;
  if (typeof d.cutsceneFA === 'number') cutscene.fadeAlpha = d.cutsceneFA;
  if (d.bdActive) {
    bossDialogue.active = true;
    bossDialogue.index = d.bdIndex || 0;
    if (d.bdTexts) bossDialogue.texts = d.bdTexts;
  } else {
    bossDialogue.active = false;
  }
  if (typeof d.phonecallT === 'number') phonecallTimer = d.phonecallT;
  if (typeof d.fusionCT === 'number') fusionCutsceneTimer = d.fusionCT;
  if (typeof d.bossIntroT === 'number') bossIntroTimer = d.bossIntroT;
  if (typeof d.bossDeathT === 'number') bossDeathTimer = d.bossDeathT;
  if (typeof d.shakeT === 'number') shakeTimer = Math.max(shakeTimer, d.shakeT);
  // Continuously sync hawking state (timers tick every frame, host sends every 6)
  if (d.hawkP2 !== undefined) hawkingPhase2 = d.hawkP2;
  if (typeof d.hawkRefT === 'number') hawkingRefusalTimer = d.hawkRefT;
  if (typeof d.hawkDeathT === 'number') hawkingDeathTimer = d.hawkDeathT;
  if (typeof d.winCutT === 'number') winCutsceneTimer = d.winCutT;
}

// Handle guest damage event on host
function mpHandleDamageEvent(dmg) {
  if (!dmg || !dmg.target) return;
  const amt = cheats.oneHitKill ? 999 : (dmg.amount || 1);
  if (dmg.target === 'guard' && typeof dmg.index === 'number' && dmg.index < guards.length && !guards[dmg.index].dead) {
    const g = guards[dmg.index];
    g.hp -= amt;
    spawnParticles(g.x + g.w/2, g.y + g.h/2, '#ff4444', 8);
    if (g.hp <= 0) { g.dead = true; spawnParticles(g.x + g.w/2, g.y + g.h/2, '#ffffff', 10); }
  } else if (dmg.target === 'boss' && boss && !boss.dead) {
    boss.hp -= amt;
    spawnParticles(boss.x + boss.w/2, boss.y + boss.h/3, '#ff8800', 10);
    shakeTimer = 6;
    if (boss.hp <= 0) {
      boss.dead = true; bossDeathTimer = 200; bullets = [];
      shakeTimer = 60; screenFlash = 50; screenFlashColor = '#ffffff';
      for (let w2 = 0; w2 < 5; w2++) {
        const ox = (Math.random()-0.5)*boss.w*2; const oy = (Math.random()-0.5)*boss.h*2;
        spawnParticles(boss.x+boss.w/2+ox, boss.y+boss.h/2+oy, '#ff4444', 20);
      }
      bossVfx.push({ type: 'ring', x: boss.x+boss.w/2, y: boss.y+boss.h/2, radius: 10, maxRadius: 500, life: 60, maxLife: 60, color: '#ff4444' });
      bossVfx.push({ type: 'text', x: boss.x+boss.w/2, y: boss.y-20, text: 'DEFEATED!', life: 150, maxLife: 150, color: '#ffdd44' });
    }
  } else if (dmg.target === 'epstein' && epstein && !epstein.dead) {
    epstein.hp -= amt;
    spawnParticles(epstein.x + epstein.w/2, epstein.y + epstein.h/3, '#8844ff', 10);
    shakeTimer = 6;
    if (epstein.hp <= 0) {
      epstein.dead = true; bossDeathTimer = 200; bullets = []; epsteinProjectiles = [];
      shakeTimer = 60; screenFlash = 50; screenFlashColor = '#ffffff';
      bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 500, life: 60, maxLife: 60, color: '#8844ff' });
    }
  } else if (dmg.target === 'fusion' && fusionBoss && !fusionBoss.dead) {
    fusionBoss.hp -= amt;
    spawnParticles(fusionBoss.x + fusionBoss.w/2, fusionBoss.y + fusionBoss.h/3, '#ff8844', 10);
    shakeTimer = 6;
    if (fusionBoss.hp <= 0) {
      fusionBoss.dead = true; bossDeathTimer = 200; bullets = []; epsteinProjectiles = [];
      shakeTimer = 60; screenFlash = 60; screenFlashColor = '#ffffff';
      bossVfx.push({ type: 'ring', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y+fusionBoss.h/2, radius: 10, maxRadius: 600, life: 60, maxLife: 60, color: '#ff4400' });
    }
  } else if (dmg.target === 'mini' && typeof dmg.index === 'number' && dmg.index < miniBosses.length && !miniBosses[dmg.index].dead) {
    const mb = miniBosses[dmg.index];
    mb.hp -= amt;
    spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, mb.color || '#ffffff', 10);
    shakeTimer = 6;
    if (mb.hp <= 0) {
      // Hawking first death — trigger refusal cutscene
      if (mb.name === 'HAWKING' && !hawkingPhase2) {
        mb.hp = 1;
        hawkingRefusalTimer = 0; hawkingRefusalPhase = 0;
        mb._savedX = mb.x; mb._savedY = mb.y;
        state = 'hawkingRefusal';
        epsteinProjectiles = []; bossMinions = []; bossVfx = [];
        screenFlash = 40; screenFlashColor = '#44ff88'; shakeTimer = 30;
        spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#44ff88', 40);
      } else if (mb.name === 'HAWKING' && hawkingPhase2) {
        // Hawking FINAL death — epic death scene
        mb.hp = 1;
        hawkingDeathTimer = 0; hawkingDeathPhase = 0;
        mb._deathX = mb.x + mb.w/2; mb._deathY = mb.y + mb.h/2;
        state = 'hawkingDeath';
        projectiles = []; epsteinProjectiles = []; bossMinions = []; bossVfx = [];
        screenFlash = 60; screenFlashColor = '#ffd700'; shakeTimer = 40;
        spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffd700', 60);
        spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffffff', 40);
      } else {
        mb.dead = true;
        spawnParticles(mb.x+mb.w/2, mb.y+mb.h/2, mb.color||'#ffffff', 25);
        bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 250, life: 30, maxLife: 30, color: mb.color||'#ffffff' });
        bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y-20, text: mb.name+' DOWN!', life: 120, maxLife: 120, color: mb.color||'#fff' });
      }
    }
  } else if (dmg.target === 'bossMinion' && typeof dmg.index === 'number' && dmg.index < bossMinions.length && !bossMinions[dmg.index].dead) {
    const bm = bossMinions[dmg.index];
    bm.hp -= amt;
    spawnParticles(bm.x + bm.w/2, bm.y + bm.h/2, '#ff4444', 6);
    if (bm.hp <= 0) { bm.dead = true; spawnParticles(bm.x+bm.w/2, bm.y+bm.h/2, '#ffffff', 8); }
  }
}

// Guest sends damage event to host via Firebase
function mpSendDamage(target, index, amount) {
  if (!mpEnabled || isHost || !currentRoom) return;
  db.ref('rooms/' + currentRoom + '/damageQueue').push({
    target: target, index: index || 0, amount: amount || 1
  });
}

// Send cutscene advance/skip event to host (non-host only)
function mpSendCutsceneEvent(type) {
  if (!mpEnabled || isHost || !currentRoom) return;
  db.ref('rooms/' + currentRoom + '/cutsceneAdvance').push({ type: type });
}

// MP Retry — vote to retry after win/lose
function mpVoteRetry() {
  if (!mpEnabled || !currentRoom) return;
  const uid = myUid();
  db.ref('rooms/' + currentRoom + '/retry/' + uid).set(true);
  mpRetryVotes[uid] = true;
}

// Host triggers retry — resets game for all players
function mpTriggerRetry() {
  if (!mpEnabled || !isHost || !currentRoom) return;
  // Clear retry votes
  db.ref('rooms/' + currentRoom + '/retry').remove();
  mpRetryVotes = {};
  // Signal all players to restart
  db.ref('rooms/' + currentRoom + '/state').set('restarting');
  // Brief delay then set playing
  setTimeout(() => {
    if (currentRoom) {
      // Re-sync match settings on retry
      db.ref('rooms/' + currentRoom + '/matchSettings').set({
        difficulty: settings.difficulty,
        cheats: cheats,
        doubleJump: settings.doubleJump,
      });
      db.ref('rooms/' + currentRoom + '/state').set('playing');
      db.ref('rooms/' + currentRoom + '/enemies').set({});
    }
  }, 300);
}

// Host syncs settings live to lobby
function mpSyncLobbySettings() {
  if (!mpEnabled || !isHost || !currentRoom) return;
  db.ref('rooms/' + currentRoom + '/matchSettings').set({
    difficulty: settings.difficulty,
    cheats: cheats,
    doubleJump: settings.doubleJump,
  });
}

// Get nearest player target for bosses (multiplayer-aware)
function getNearestPlayerTarget(bossX, bossY) {
  let nearest = player.alive ? player : null;
  let nearDist = player.alive ? Math.sqrt((player.x - bossX) ** 2 + (player.y - bossY) ** 2) : Infinity;
  
  if (mpEnabled) {
    const uid = myUid();
    for (const pid in roomPlayers) {
      if (pid === uid) continue;
      const rp = roomPlayers[pid];
      if (!rp || !rp.alive) continue;
      const d = Math.sqrt((rp.x - bossX) ** 2 + (rp.y - bossY) ** 2);
      if (d < nearDist) {
        nearDist = d;
        nearest = { x: rp.x, y: rp.y, w: 52, h: 80 };
      }
    }
  }
  return nearest || player; // fallback to player if everyone dead
}

// Draw other players
function drawOtherPlayers() {
  if (!mpEnabled) return;
  const uid = myUid();
  
  for (const pid in roomPlayers) {
    if (pid === uid) continue;
    const rp = roomPlayers[pid];
    if (!rp || !rp.alive) continue;
    
    const px = rp.x;
    const py = rp.y;
    const runBounce = rp.runFrame ? Math.sin(rp.runFrame * Math.PI / 2) * 2 : 0;
    
    // Semi-transparent other player
    ctx.save();
    ctx.globalAlpha = rp.iFrames > 0 ? 0.4 : 0.85;
    const rpDrawW = 52 * PLAYER_IMG_SCALE;
    const rpDrawH = 80 * PLAYER_IMG_SCALE;
    const rpOffX = (52 - rpDrawW) / 2;
    const rpOffY = 80 - rpDrawH;
    if (rp.facing < 0) {
      ctx.translate(px + 52, py - runBounce);
      ctx.scale(-1, 1);
      ctx.drawImage(playerImg, -rpOffX, rpOffY, rpDrawW, rpDrawH);
    } else {
      ctx.drawImage(playerImg, px + rpOffX, py + rpOffY - runBounce, rpDrawW, rpDrawH);
    }
    ctx.restore();
    
    // Username above head
    ctx.save();
    ctx.fillStyle = '#88ccff';
    ctx.font = 'bold 11px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(rp.username || 'Player', px + 26, py - 18);
    
    // HP bar
    if (rp.hp !== undefined && rp.maxHp) {
      const hpPct = rp.hp / rp.maxHp;
      const barW = 40;
      const barH = 4;
      const barX = px + 6;
      const barY = py - 10;
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = hpPct > 0.5 ? '#44ff44' : hpPct > 0.25 ? '#ffcc22' : '#ff4444';
      ctx.fillRect(barX, barY, barW * hpPct, barH);
    }
    ctx.restore();
    
    // Draw other player's projectiles
    if (rp.projectiles) {
      ctx.save();
      ctx.globalAlpha = 0.7;
      for (const pj of rp.projectiles) {
        // Move projectiles locally using velocity for smooth interpolation
        pj.x += pj.vx;
        pj.y += pj.vy;
        pj.vy += 0.12;
        const sz = pj.w || 28;
        ctx.fillStyle = '#ffcc44';
        ctx.beginPath();
        ctx.arc(pj.x + sz/2, pj.y + sz/2, sz/2 * 0.7, 0, Math.PI * 2);
        ctx.fill();
        // Glow
        ctx.fillStyle = 'rgba(255, 200, 50, 0.3)';
        ctx.beginPath();
        ctx.arc(pj.x + sz/2, pj.y + sz/2, sz/2, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }
  }
}

// ── Friend System Functions ──
async function loadFriendsList() {
  if (!currentUser) return;
  authSuccessMsg = '';
  const uid = currentUser.uid;
  
  try {
    // Load friends (batched reads)
    const friendSnap = await db.ref('users/' + uid + '/friends').once('value');
    const friendData = friendSnap.val() || {};
    const friendIds = Object.keys(friendData);
    const friendProms = friendIds.map(fid => 
      Promise.all([
        db.ref('users/' + fid + '/username').once('value'),
        db.ref('users/' + fid + '/online').once('value'),
      ]).then(([usnap, oline]) => ({ uid: fid, username: usnap.val() || '???', online: oline.val() || false }))
    );
    friendsList = await Promise.all(friendProms);
    
    // Load friend requests
    const reqSnap = await db.ref('users/' + uid + '/friendRequests').once('value');
    const reqData = reqSnap.val() || {};
    friendRequests = [];
    for (const rid in reqData) {
      friendRequests.push({ uid: rid, username: reqData[rid].username || '???' });
    }
    
    // Load blocked
    const blockSnap = await db.ref('users/' + uid + '/blocked').once('value');
    const blockData = blockSnap.val() || {};
    blockedUsers = [];
    for (const bid in blockData) {
      blockedUsers.push({ uid: bid, username: blockData[bid].username || '???' });
    }
  } catch (err) {
    authError = 'Failed to load friends list';
  }
}

async function addFriend(username) {
  if (!currentUser || !username.trim()) return;
  friendInput = '';
  authSuccessMsg = '';
  try {
    // Find user by username
    const snap = await db.ref('users').orderByChild('username').equalTo(username.trim()).once('value');
    const data = snap.val();
    if (!data) { authError = 'User not found!'; return; }
    const targetUid = Object.keys(data)[0];
    if (targetUid === currentUser.uid) { authError = "You can't add yourself!"; return; }
    
    // Check if already friends
    const friendCheck = await db.ref('users/' + currentUser.uid + '/friends/' + targetUid).once('value');
    if (friendCheck.exists()) { authError = 'Already friends!'; return; }
    
    // Check if blocked
    const blockCheck = await db.ref('users/' + targetUid + '/blocked/' + currentUser.uid).once('value');
    if (blockCheck.exists()) { authError = 'Cannot add this user.'; return; }
    
    // Check if request already sent
    const reqCheck = await db.ref('users/' + targetUid + '/friendRequests/' + currentUser.uid).once('value');
    if (reqCheck.exists()) { authError = 'Request already sent!'; return; }
    
    // Send friend request
    await db.ref('users/' + targetUid + '/friendRequests/' + currentUser.uid).set({
      username: playerUsername,
      time: firebase.database.ServerValue.TIMESTAMP,
    });
    authError = '';
    authSuccessMsg = 'Friend request sent!';
  } catch(e) { authError = 'Failed to send friend request'; }
}

async function acceptFriendRequest(friendUid) {
  if (!currentUser) return;
  try {
    const uid = currentUser.uid;
    await db.ref('users/' + uid + '/friends/' + friendUid).set(true);
    await db.ref('users/' + friendUid + '/friends/' + uid).set(true);
    await db.ref('users/' + uid + '/friendRequests/' + friendUid).remove();
    loadFriendsList();
  } catch(e) { authError = 'Failed to accept request'; }
}

async function declineFriendRequest(friendUid) {
  if (!currentUser) return;
  try {
    await db.ref('users/' + currentUser.uid + '/friendRequests/' + friendUid).remove();
    loadFriendsList();
  } catch(e) { authError = 'Failed to decline request'; }
}

async function removeFriend(friendUid) {
  if (!currentUser) return;
  try {
    const uid = currentUser.uid;
    await db.ref('users/' + uid + '/friends/' + friendUid).remove();
    await db.ref('users/' + friendUid + '/friends/' + uid).remove();
    loadFriendsList();
  } catch(e) { authError = 'Failed to remove friend'; }
}

async function blockUser(targetUid, username) {
  if (!currentUser) return;
  try {
    const uid = currentUser.uid;
    await db.ref('users/' + uid + '/blocked/' + targetUid).set({ username: username });
    await db.ref('users/' + uid + '/friends/' + targetUid).remove();
    await db.ref('users/' + targetUid + '/friends/' + uid).remove();
    await db.ref('users/' + uid + '/friendRequests/' + targetUid).remove();
    loadFriendsList();
  } catch(e) { authError = 'Failed to block user'; }
}

async function unblockUser(targetUid) {
  if (!currentUser) return;
  try {
    await db.ref('users/' + currentUser.uid + '/blocked/' + targetUid).remove();
    loadFriendsList();
  } catch(e) { authError = 'Failed to unblock user'; }
}

// ══════════════════════════════════════════════════════
// ── END FIREBASE / MULTIPLAYER SYSTEM ──
// ══════════════════════════════════════════════════════

let touchControls = { left: false, right: false, up: false };

// Touch aim joystick state (right side) — positions from touchLayout
let touchAim = { active: false, cx: 0, cy: 0, dx: 0, dy: 0, angle: 0 };
function getAimCenterX() { return touchLayout.aimX; }
function getAimCenterY() { return touchLayout.aimY; }
function getAimRadius() { return touchLayout.aimR; }
const AIM_DEAD_ZONE = 8;

// Touch movement joystick state (left side) — positions from touchLayout
function getMoveCenterX() { return touchLayout.moveX; }
function getMoveCenterY() { return touchLayout.moveY; }
function getMoveRadius() { return touchLayout.moveR; }
const MOVE_DEAD_ZONE = 10;
let moveJoystick = { active: false, dx: 0, dy: 0, touchId: null, inJumpUp: false };
const MOVE_JUMP_THRESHOLD = -25; // dy must be less than this (upward) to trigger jump
let jumpFlashTimer = 0; // visual flash timer when jump triggers (frames)

// Shared touch button renderer — called from each game state's HUD
let _isTouchDev = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
// Auto-detect touch on first touch event (for iPad with keyboard attached)
window.addEventListener('touchstart', () => { _isTouchDev = true; }, { once: true, passive: true });
function drawTouchButtons() {
  if (!_isTouchDev || !settings.touchButtons) return;
  ctx.save();
  const MCX = getMoveCenterX(), MCY = getMoveCenterY(), MR = getMoveRadius();
  const ACX = getAimCenterX(), ACY = getAimCenterY(), AR = getAimRadius();

  // ── LEFT SIDE: Movement joystick ──
  ctx.globalAlpha = 0.25;
  ctx.strokeStyle = '#88bbff';
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.arc(MCX, MCY, MR, 0, Math.PI * 2); ctx.stroke();
  // Crosshair
  ctx.globalAlpha = 0.12;
  ctx.beginPath(); ctx.moveTo(MCX - MR, MCY); ctx.lineTo(MCX + MR, MCY); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(MCX, MCY - MR); ctx.lineTo(MCX, MCY + MR); ctx.stroke();
  // Directional arrows around ring
  ctx.globalAlpha = 0.2;
  ctx.fillStyle = '#88bbff';
  ctx.font = 'bold 22px monospace'; ctx.textAlign = 'center';
  ctx.fillText('\u25c4', MCX - MR - 14, MCY + 7);
  ctx.fillText('\u25ba', MCX + MR + 14, MCY + 7);

  if (moveJoystick.active) {
    const len = Math.min(Math.sqrt(moveJoystick.dx * moveJoystick.dx + moveJoystick.dy * moveJoystick.dy), MR);
    const dist = Math.sqrt(moveJoystick.dx * moveJoystick.dx + moveJoystick.dy * moveJoystick.dy) || 1;
    const nx = moveJoystick.dx / dist;
    const ny = moveJoystick.dy / dist;
    const _jFlash = moveJoystick.inJumpUp || jumpFlashTimer > 0;
    ctx.globalAlpha = 0.5;
    ctx.strokeStyle = _jFlash ? '#88ff88' : '#88bbff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(MCX, MCY);
    ctx.lineTo(MCX + nx * len, MCY + ny * len);
    ctx.stroke();
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = _jFlash ? '#aaffaa' : '#aaddff';
    ctx.beginPath(); ctx.arc(MCX + nx * len, MCY + ny * len, 22, 0, Math.PI * 2); ctx.fill();
  } else {
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#88bbff';
    ctx.beginPath(); ctx.arc(MCX, MCY, 22, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.font = 'bold 12px monospace';
    ctx.fillText('MOVE', MCX, MCY + 4);
  }

  // Up arrow above move joystick to hint jump
  const _jFlash2 = moveJoystick.inJumpUp || jumpFlashTimer > 0;
  ctx.globalAlpha = _jFlash2 ? 0.55 : 0.18;
  ctx.fillStyle = _jFlash2 ? '#88ff88' : '#88bbff';
  ctx.font = 'bold 22px monospace'; ctx.textAlign = 'center';
  ctx.fillText('\u25b2', MCX, MCY - MR - 14);

  // ── RIGHT SIDE: Aim joystick ──
  ctx.globalAlpha = 0.25;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.arc(ACX, ACY, AR, 0, Math.PI * 2); ctx.stroke();
  ctx.globalAlpha = 0.12;
  ctx.beginPath(); ctx.moveTo(ACX - AR, ACY); ctx.lineTo(ACX + AR, ACY); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(ACX, ACY - AR); ctx.lineTo(ACX, ACY + AR); ctx.stroke();

  if (touchAim.active) {
    const len = Math.min(Math.sqrt(touchAim.dx * touchAim.dx + touchAim.dy * touchAim.dy), AR);
    const nx = Math.cos(touchAim.angle);
    const ny = Math.sin(touchAim.angle);
    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = '#ffaa44';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(ACX, ACY);
    ctx.lineTo(ACX + nx * len, ACY + ny * len);
    ctx.stroke();
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = '#ffcc66';
    ctx.beginPath(); ctx.arc(ACX + nx * len, ACY + ny * len, 18, 0, Math.PI * 2); ctx.fill();
  } else {
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath(); ctx.arc(ACX, ACY, 18, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.font = 'bold 14px monospace';
    ctx.fillText('AIM', ACX, ACY + 5);
  }

  ctx.restore();
}

// Cutscene state
let cutscene = {
  active: false,
  timer: 0,
  phase: 0, // 0=fade to black, 1=show boss image, 2=dialogue, 3=fade out to fight
  dialogueIndex: 0,
  dialogues: [
    '...',
    'Well, well, well... Look who made it to the WALL.',
    'Welcome to MY border. The BEST wall. TREMENDOUS.',
    'Nobody gets through. NOBODY.',
    'I\'m gonna Make America Great Again!',
    'You think you can cross MY wall? NOT HAPPENING!',
    'Now get ready to be DEPORTED! BIGLY!',
  ],
  fadeAlpha: 0,
};

// Boss mid-fight dialogues
const bossPhaseDialogues = {
  2: [
    'That tickled. I\'ve survived TWO impeachments!',
    'You think you can beat ME? I have the best genes!',
    'This isn\'t even my final form... BELIEVE ME!',
  ],
  3: [
    'OK that\'s IT. You asked for this.',
    'I know people... VERY powerful people...',
    'Time to make a phone call!',
  ],
};
// Epstein boss dialogue
const epsteinDialogues = [
  '*ring ring* ... Jeff? I need a favor...',
  'Send the files. ALL of them.',
  '...he didn\'t unalive himself btw',
];
const epsteinPhaseDialogues = {
  2: [
    'You know too much already...',
    'These files will BURY you!',
    'The island sends its regards!',
  ],
};
let bossDialogue = { active: false, texts: [], index: 0, timer: 0 };

// ── Input ──
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  
  // Menu navigation
  if (state === 'menu') {
    if (activeTextInput) return; // block menu nav while typing
    if (menuState === 'main') {
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { menuSelection--; if (menuSelection < 0) menuSelection = 7; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { menuSelection++; if (menuSelection > 7) menuSelection = 0; }
      if (e.code === 'Space' || e.code === 'Enter') {
        if (menuSelection === 0) {
          if (tutorialDone) { startGame(); }
          else { state = 'tutorial'; tutorialPage = 0; }
        }
        else if (menuSelection === 1) { menuState = 'multiplayer'; mpMenuSelection = 0; authError = ''; }
        else if (menuSelection === 2) { menuState = 'difficulty'; menuSelection = 0; }
        else if (menuSelection === 3) { menuState = 'settings'; menuSelection = 0; }
        else if (menuSelection === 4) { menuState = 'controls'; menuSelection = 0; }
        else if (menuSelection === 5) { friendsBackTo = 'main'; menuState = 'friends'; friendMenuSelection = 0; authError = ''; loadFriendsList(); }
        else if (menuSelection === 6) { menuState = 'credits'; menuSelection = 0; }
        else if (menuSelection === 7) { menuState = 'cheats'; cheatSelection = 0; }
      }
    } else if (menuState === 'cheats') {
      const cheatKeys = Object.keys(cheats);
      const totalItems = cheatKeys.length + 3; // cheats + skip + watch + back
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { cheatSelection--; if (cheatSelection < 0) cheatSelection = totalItems - 1; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { cheatSelection++; if (cheatSelection >= totalItems) cheatSelection = 0; }
      if (e.code === 'Space' || e.code === 'Enter' || e.code === 'ArrowRight' || e.code === 'ArrowLeft') {
        if (cheatSelection < cheatKeys.length) {
          cheats[cheatKeys[cheatSelection]] = !cheats[cheatKeys[cheatSelection]];
        } else if (cheatSelection === cheatKeys.length) {
          skipToFinalBoss();
        } else if (cheatSelection === cheatKeys.length + 1) {
          watchCutscene();
        } else {
          menuState = 'main'; menuSelection = 7;
        }
      }
      if (e.code === 'Escape' || e.code === 'Backspace') { menuState = 'main'; menuSelection = 7; }
    } else if (menuState === 'difficulty') {
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { menuSelection--; if (menuSelection < 0) menuSelection = 3; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { menuSelection++; if (menuSelection > 3) menuSelection = 0; }
      if (e.code === 'Space' || e.code === 'Enter') {
        const diffs = ['easy','normal','hard','insane'];
        settings.difficulty = diffs[menuSelection];
        menuState = 'main'; menuSelection = 2;
      }
      if (e.code === 'Escape' || e.code === 'Backspace') { menuState = 'main'; menuSelection = 2; }
    } else if (menuState === 'settings') {
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { menuSelection--; if (menuSelection < 0) menuSelection = 7; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { menuSelection++; if (menuSelection > 7) menuSelection = 0; }
      if (e.code === 'Space' || e.code === 'Enter' || e.code === 'ArrowRight' || e.code === 'ArrowLeft') {
        if (menuSelection === 0) settings.screenShake = !settings.screenShake;
        else if (menuSelection === 1) settings.particles = !settings.particles;
        else if (menuSelection === 2) settings.showFPS = !settings.showFPS;
        else if (menuSelection === 3) settings.doubleJump = !settings.doubleJump;
        else if (menuSelection === 4) settings.showTimer = !settings.showTimer;
        else if (menuSelection === 5) settings.colorblind = !settings.colorblind;
        else if (menuSelection === 6) { menuState = 'touchcontrols'; menuSelection = 0; }
        else if (menuSelection === 7) { menuState = 'main'; menuSelection = 3; }
      }
      if (e.code === 'Escape' || e.code === 'Backspace') { menuState = 'main'; menuSelection = 3; }
    } else if (menuState === 'touchcontrols') {
      const presetKeys = Object.keys(TOUCH_PRESETS);
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { menuSelection--; if (menuSelection < 0) menuSelection = presetKeys.length + 1; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { menuSelection++; if (menuSelection > presetKeys.length + 1) menuSelection = 0; }
      if (e.code === 'Space' || e.code === 'Enter') {
        if (menuSelection < presetKeys.length) {
          touchPresetName = presetKeys[menuSelection];
          touchLayout = Object.assign({}, TOUCH_PRESETS[touchPresetName]);
          saveTouchLayout();
        } else if (menuSelection === presetKeys.length) {
          // Reset to default
          touchPresetName = 'default';
          touchLayout = Object.assign({}, TOUCH_PRESETS.default);
          saveTouchLayout();
        } else {
          menuState = 'settings'; menuSelection = 6;
        }
      }
      if (e.code === 'Escape' || e.code === 'Backspace') { menuState = 'settings'; menuSelection = 6; }
    } else if (menuState === 'controls') {
      if (e.code === 'Escape' || e.code === 'Backspace' || e.code === 'Space' || e.code === 'Enter') { menuState = 'main'; menuSelection = 4; }
    } else if (menuState === 'credits') {
      if (e.code === 'Escape' || e.code === 'Backspace' || e.code === 'Space' || e.code === 'Enter') { menuState = 'main'; menuSelection = 6; }
    } else if (menuState === 'account') {
      if (e.code === 'Escape' || e.code === 'Backspace') { authError = ''; menuState = 'multiplayer'; mpMenuSelection = 0; }
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { authInputField--; if (authInputField < 0) authInputField = (authScreen === 'register' ? 3 : 2); }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { authInputField++; if (authInputField > (authScreen === 'register' ? 3 : 2)) authInputField = 0; }
      if (e.code === 'Space' || e.code === 'Enter') {
        // 0=username, 1=password, 2=confirm(register) or submit(login), 3=submit(register)
        const submitIdx = authScreen === 'register' ? 3 : 2;
        if (authInputField < submitIdx) {
          const fields = ['username', 'password', 'confirm'];
          activateTextInput(fields[authInputField]);
        } else {
          if (authScreen === 'register') registerAccount(authInputs.username, authInputs.password);
          else loginAccount(authInputs.username, authInputs.password);
        }
      }
    } else if (menuState === 'multiplayer') {
      if (e.code === 'Escape' || e.code === 'Backspace') { menuState = 'main'; menuSelection = 1; }
      const mpMax = playerUsername ? 4 : 3;
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { mpMenuSelection--; if (mpMenuSelection < 0) mpMenuSelection = mpMax; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { mpMenuSelection++; if (mpMenuSelection > mpMax) mpMenuSelection = 0; }
      if (e.code === 'Space' || e.code === 'Enter') {
        if (mpMenuSelection === 0) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else createRoom(); }
        else if (mpMenuSelection === 1) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else { activateTextInput('roomcode'); joinRoomInput = ''; } }
        else if (mpMenuSelection === 2) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else { friendsBackTo = 'multiplayer'; menuState = 'friends'; friendMenuSelection = 0; authError = ''; loadFriendsList(); } }
        else if (mpMenuSelection === 3) { menuState = 'main'; menuSelection = 1; }
        else if (mpMenuSelection === 4) { logoutAccount(); }
      }
    } else if (menuState === 'lobby') {
      if (e.code === 'Escape') { leaveRoom(); }
      if (e.code === 'Enter' && !chatOpen) { chatOpen = true; activateTextInput('chat'); chatInput = ''; }
      if (e.code === 'Space' && !chatOpen && isHost) { startMultiplayerGame(); }
      // Host settings navigation
      if (isHost && !chatOpen) {
        const settCount = 8;
        if (e.code === 'ArrowUp' || e.code === 'KeyW') { mpSettingsSelection = (mpSettingsSelection - 1 + settCount) % settCount; }
        if (e.code === 'ArrowDown' || e.code === 'KeyS') { mpSettingsSelection = (mpSettingsSelection + 1) % settCount; }
        if (e.code === 'ArrowLeft' || e.code === 'ArrowRight' || e.code === 'KeyA' || e.code === 'KeyD') {
          const dir = (e.code === 'ArrowRight' || e.code === 'KeyD') ? 1 : -1;
          if (mpSettingsSelection === 0) {
            const diffs = ['easy','normal','hard','insane'];
            let idx = diffs.indexOf(settings.difficulty);
            idx = (idx + dir + diffs.length) % diffs.length;
            settings.difficulty = diffs[idx];
          } else if (mpSettingsSelection === 1) { settings.doubleJump = !settings.doubleJump; }
          else if (mpSettingsSelection === 2) { cheats.godMode = !cheats.godMode; }
          else if (mpSettingsSelection === 3) { cheats.oneHitKill = !cheats.oneHitKill; }
          else if (mpSettingsSelection === 4) { cheats.infiniteJumps = !cheats.infiniteJumps; }
          else if (mpSettingsSelection === 5) { cheats.speedBoost = !cheats.speedBoost; }
          else if (mpSettingsSelection === 6) { cheats.bigProjectiles = !cheats.bigProjectiles; }
          else if (mpSettingsSelection === 7) { cheats.noCooldown = !cheats.noCooldown; }
          mpSyncLobbySettings();
        }
      }
    } else if (menuState === 'friends') {
      if (e.code === 'Escape' || e.code === 'Backspace') {
        if (friendsBackTo === 'multiplayer') { menuState = 'multiplayer'; mpMenuSelection = 0; }
        else { menuState = 'main'; menuSelection = 5; }
      }
      if (e.code === 'ArrowLeft') { friendTab--; if (friendTab < 0) friendTab = 3; friendMenuSelection = 0; }
      if (e.code === 'ArrowRight') { friendTab++; if (friendTab > 3) friendTab = 0; friendMenuSelection = 0; }
      if (e.code === 'ArrowUp' || e.code === 'KeyW') { friendMenuSelection--; if (friendMenuSelection < 0) friendMenuSelection = 0; }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') { friendMenuSelection++; }
      if (e.code === 'Space' || e.code === 'Enter') {
        if (friendTab === 1 && friendRequests[friendMenuSelection]) acceptFriendRequest(friendRequests[friendMenuSelection].uid);
        if (friendTab === 3) { activateTextInput('friendadd'); friendInput = ''; }
      }
      if (e.code === 'KeyX') {
        if (friendTab === 0 && friendsList[friendMenuSelection]) removeFriend(friendsList[friendMenuSelection].uid);
        if (friendTab === 1 && friendRequests[friendMenuSelection]) declineFriendRequest(friendRequests[friendMenuSelection].uid);
        if (friendTab === 2 && blockedUsers[friendMenuSelection]) unblockUser(blockedUsers[friendMenuSelection].uid);
      }
    }
    return;
  }
  
  // Tutorial navigation
  if (state === 'tutorial') {
    if (e.code === 'Space' || e.code === 'Enter' || e.code === 'ArrowRight') {
      tutorialPage++;
      if (tutorialPage >= 5) { completeTutorial(); }
    }
    if (e.code === 'ArrowLeft' && tutorialPage > 0) tutorialPage--;
    return;
  }
  
  // Skip cutscenes with Escape (host directly, non-host sends to host)
  if (e.code === 'Escape' && state === 'cutscene') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { cutscene.phase = 3; cutscene.fadeAlpha = 1; cutscene.timer = 0; }
    return;
  }
  if (e.code === 'Escape' && state === 'phonecall') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { phonecallTimer = 1; }
    return;
  }
  if (e.code === 'Escape' && state === 'fusioncutscene') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { fusionCutsceneTimer = 1; }
    return;
  }
  if (e.code === 'Escape' && state === 'hawkingRefusal') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { hawkingRefusalTimer = 1129; }
    return;
  }
  if (e.code === 'Escape' && state === 'hawkingDeath') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { hawkingDeathTimer = 899; }
    return;
  }
  if (e.code === 'Escape' && state === 'winCutscene') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { winCutsceneTimer = 699; }
    return;
  }
  if (e.code === 'Escape' && state === 'bossdialogue') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); }
    else { bossDialogue.index = bossDialogue.texts.length; advanceCutscene(); }
    return;
  }
  
  // Spectator controls — cycle through alive players
  if (mpSpectating) {
    const alive = getAlivePlayerList();
    if (alive.length > 0) {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
        mpSpectateIndex = (mpSpectateIndex - 1 + alive.length) % alive.length;
        mpSpectateTarget = alive[mpSpectateIndex].uid;
      }
      if (e.code === 'ArrowRight' || e.code === 'KeyD') {
        mpSpectateIndex = (mpSpectateIndex + 1) % alive.length;
        mpSpectateTarget = alive[mpSpectateIndex].uid;
      }
    }
    return; // block all other input while spectating
  }

  if ((e.code === 'Space' || e.code === 'Enter') && (state === 'cutscene' || state === 'bossdialogue')) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('advance'); }
    else { advanceCutscene(); }
  } else if ((state === 'won' || state === 'dead') && restartCooldown <= 0) {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') { mpRetrySelection = 0; }
    if (e.code === 'ArrowRight' || e.code === 'KeyD') { mpRetrySelection = 1; }
    if (e.code === 'Space' || e.code === 'Enter') {
      if (mpRetrySelection === 0) {
        // Retry
        if (mpEnabled) {
          mpVoteRetry();
          // Host with all votes → trigger retry
          if (isHost) {
            const totalPlayers = Object.keys(roomPlayers).length;
            const retryCount = Object.keys(mpRetryVotes).length;
            if (retryCount >= totalPlayers) {
              mpTriggerRetry();
            }
          }
        } else {
          // Solo retry
          startGame();
        }
      } else {
        // Leave
        if (mpEnabled) { leaveRoom(); }
        state = 'menu'; menuState = 'main'; menuSelection = 0;
      }
    }
  }
  if ((e.code === 'Space' || e.code === 'Enter') && state === 'intro' && introPhase >= 3) {
    introPhase = 6;
  }
  if ((e.code === 'KeyF' || e.code === 'KeyE') && (state === 'playing' || state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight') && player.alive) {
    throwProjectile();
  }
});
window.addEventListener('keyup', e => keys[e.code] = false);

// Mouse tracking
canvas.addEventListener('mousemove', e => {
  const { x, y } = clientToCanvas(e.clientX, e.clientY);
  mouseX = x;
  mouseY = y;
  mouseActive = true;
  // Touch controls editor drag (mouse)
  if (tcDragging && state === 'menu' && menuState === 'touchcontrols') {
    const cx = x, cy = y;
    const pvScaleX = (W - 80) / W;
    const newX = Math.max(60, Math.min(W - 60, (cx - tcDragOffX - 40) / pvScaleX));
    const newY = touchLayout[tcDragging === 'move' ? 'moveY' : 'aimY']; // Y stays fixed in preview
    if (tcDragging === 'move') { touchLayout.moveX = Math.round(newX); }
    else if (tcDragging === 'aim') { touchLayout.aimX = Math.round(newX); }
    touchPresetName = 'custom';
    saveTouchLayout();
  }
});
canvas.addEventListener('mouseup', e => {
  if (tcDragging) { tcDragging = null; }
});

// Fullscreen toggle
function toggleFullscreen() {
  const el = document.documentElement;
  const fsEl = document.fullscreenElement || document.webkitFullscreenElement;
  if (!fsEl) {
    if (el.requestFullscreen) el.requestFullscreen().catch(() => {});
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  } else {
    if (document.exitFullscreen) document.exitFullscreen().catch(() => {});
    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
  }
}
// Force a repaint after fullscreen transition
document.addEventListener('fullscreenchange', () => { setTimeout(resizeCanvas, 100); });
document.addEventListener('webkitfullscreenchange', () => { setTimeout(resizeCanvas, 100); });

canvas.addEventListener('click', e => {
  const { x: cx, y: cy } = clientToCanvas(e.clientX, e.clientY);
  
  // Performance mode prompt buttons (highest priority when visible)
  if (_showPerfPrompt && window._perfYesBtn && window._perfNoBtn) {
    const yb = window._perfYesBtn, nb = window._perfNoBtn;
    if (cx >= yb.x && cx <= yb.x + yb.w && cy >= yb.y && cy <= yb.y + yb.h) { _acceptPerfMode(); return; }
    if (cx >= nb.x && cx <= nb.x + nb.w && cy >= nb.y && cy <= nb.y + nb.h) { _declinePerfMode(); return; }
    return; // block all clicks while prompt is up
  }

  // Fullscreen button (top-right corner, always available — 46px for touch)
  if (cx > W - 48 && cy < 48) {
    toggleFullscreen();
    return;
  }
  
  // Menu clicks
  if (state === 'menu') {
    if (menuState === 'main') {
      const menuY = H * 0.35;
      for (let i = 0; i < 8; i++) {
        const y = menuY + i * 40;
        if (cx > W/2 - 160 && cx < W/2 + 160 && cy > y - 18 && cy < y + 18) {
          menuSelection = i;
          if (i === 0) {
            if (tutorialDone) { startGame(); }
            else { state = 'tutorial'; tutorialPage = 0; }
          }
          else if (i === 1) { menuState = 'multiplayer'; mpMenuSelection = 0; authError = ''; }
          else if (i === 2) { menuState = 'difficulty'; menuSelection = 0; }
          else if (i === 3) { menuState = 'settings'; menuSelection = 0; }
          else if (i === 4) { menuState = 'controls'; menuSelection = 0; }
          else if (i === 5) { friendsBackTo = 'main'; menuState = 'friends'; friendMenuSelection = 0; authError = ''; loadFriendsList(); }
          else if (i === 6) { menuState = 'credits'; menuSelection = 0; }
          else if (i === 7) { menuState = 'cheats'; cheatSelection = 0; }
          return;
        }
      }
    } else if (menuState === 'difficulty') {
      const diffY = H * 0.42;
      for (let i = 0; i < 4; i++) {
        const y = diffY + i * 55;
        if (cx > W/2 - 200 && cx < W/2 + 200 && cy > y - 20 && cy < y + 25) {
          const diffs = ['easy','normal','hard','insane'];
          settings.difficulty = diffs[i];
          menuState = 'main'; menuSelection = 2;
          return;
        }
      }
      // Back area
      if (cy > H * 0.85) { menuState = 'main'; menuSelection = 2; return; }
    } else if (menuState === 'settings') {
      const setY = H * 0.36;
      for (let i = 0; i < 8; i++) {
        const y = setY + i * 40;
        if (cx > W/2 - 200 && cx < W/2 + 200 && cy > y - 14 && cy < y + 18) {
          if (i === 0) settings.screenShake = !settings.screenShake;
          else if (i === 1) settings.particles = !settings.particles;
          else if (i === 2) settings.showFPS = !settings.showFPS;
          else if (i === 3) settings.doubleJump = !settings.doubleJump;
          else if (i === 4) settings.showTimer = !settings.showTimer;
          else if (i === 5) settings.colorblind = !settings.colorblind;
          else if (i === 6) { menuState = 'touchcontrols'; menuSelection = 0; }
          else if (i === 7) { menuState = 'main'; menuSelection = 3; }
          return;
        }
      }
    } else if (menuState === 'touchcontrols') {
      // Preset list
      const presetKeys = Object.keys(TOUCH_PRESETS);
      const tcY = H * 0.36;
      for (let i = 0; i < presetKeys.length; i++) {
        const y = tcY + i * 36;
        if (cx > W/2 - 200 && cx < W/2 + 200 && cy > y - 14 && cy < y + 18) {
          touchPresetName = presetKeys[i];
          touchLayout = Object.assign({}, TOUCH_PRESETS[touchPresetName]);
          saveTouchLayout();
          return;
        }
      }
      // Size controls for move joystick
      const sizeY = tcY + presetKeys.length * 36 + 10;
      if (cx > W/2 - 80 && cx < W/2 - 40 && cy > sizeY - 10 && cy < sizeY + 20) {
        touchLayout.moveR = Math.max(35, touchLayout.moveR - 5); touchPresetName = 'custom'; saveTouchLayout(); return;
      }
      if (cx > W/2 + 40 && cx < W/2 + 80 && cy > sizeY - 10 && cy < sizeY + 20) {
        touchLayout.moveR = Math.min(100, touchLayout.moveR + 5); touchPresetName = 'custom'; saveTouchLayout(); return;
      }
      // Size controls for aim joystick
      const sizeY2 = sizeY + 32;
      if (cx > W/2 - 80 && cx < W/2 - 40 && cy > sizeY2 - 10 && cy < sizeY2 + 20) {
        touchLayout.aimR = Math.max(35, touchLayout.aimR - 5); touchPresetName = 'custom'; saveTouchLayout(); return;
      }
      if (cx > W/2 + 40 && cx < W/2 + 80 && cy > sizeY2 - 10 && cy < sizeY2 + 20) {
        touchLayout.aimR = Math.min(100, touchLayout.aimR + 5); touchPresetName = 'custom'; saveTouchLayout(); return;
      }
      // Reset button
      const resetY = sizeY2 + 36;
      if (cx > W/2 - 60 && cx < W/2 + 60 && cy > resetY - 12 && cy < resetY + 18) {
        touchPresetName = 'default'; touchLayout = Object.assign({}, TOUCH_PRESETS.default); saveTouchLayout(); return;
      }
      // Back button
      const backY = resetY + 36;
      if (cx > W/2 - 60 && cx < W/2 + 60 && cy > backY - 12 && cy < backY + 18) {
        menuState = 'settings'; menuSelection = 6; return;
      }
      // Drag joystick on preview
      if (cy > H * 0.7) {
        const pvTop = H * 0.7;
        const pvH = H - pvTop - 10;
        const pvCenterY = pvTop + pvH / 2 + 8;
        const pvScaleX = (W - 80) / W;
        const pvScaleR = 0.5;
        const pvMCX = 40 + touchLayout.moveX * pvScaleX;
        const pvMCY = pvCenterY;
        const pvACX = 40 + touchLayout.aimX * pvScaleX;
        const pvACY = pvCenterY;
        const mdx = cx - pvMCX, mdy = cy - pvMCY;
        const adx = cx - pvACX, ady = cy - pvACY;
        if (Math.sqrt(mdx*mdx + mdy*mdy) < touchLayout.moveR * pvScaleR + 20) {
          tcDragging = 'move'; tcDragOffX = mdx; tcDragOffY = mdy; return;
        }
        if (Math.sqrt(adx*adx + ady*ady) < touchLayout.aimR * pvScaleR + 20) {
          tcDragging = 'aim'; tcDragOffX = adx; tcDragOffY = ady; return;
        }
      }
    } else if (menuState === 'cheats') {
      const cheatKeys = Object.keys(cheats);
      const cheatY = H * 0.28;
      const totalItems = cheatKeys.length + 3;
      for (let i = 0; i < totalItems; i++) {
        const y = cheatY + i * 38;
        if (cx > W/2 - 220 && cx < W/2 + 220 && cy > y - 14 && cy < y + 18) {
          if (i < cheatKeys.length) {
            cheats[cheatKeys[i]] = !cheats[cheatKeys[i]];
          } else if (i === cheatKeys.length) {
            skipToFinalBoss();
          } else if (i === cheatKeys.length + 1) {
            watchCutscene();
          } else {
            menuState = 'main'; menuSelection = 7;
          }
          return;
        }
      }
      return;
    } else if (menuState === 'controls' || menuState === 'credits') {
      // Click anywhere to go back
      const wasCredits = menuState === 'credits';
      menuState = 'main'; menuSelection = wasCredits ? 6 : 4;
      return;
    } else if (menuState === 'multiplayer') {
      // Multiplayer menu touch
      const mpItems = ['CREATE ROOM', 'JOIN ROOM', 'FRIENDS', 'BACK'];
      const mpY = H * 0.40;
      for (let i = 0; i < mpItems.length; i++) {
        const y = mpY + i * 50;
        if (cx > W/2 - 180 && cx < W/2 + 180 && cy > y - 24 && cy < y + 24) {
          if (i === 0) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else createRoom(); }
          else if (i === 1) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else { activateTextInput('roomcode'); joinRoomInput = ''; } }
          else if (i === 2) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else { friendsBackTo = 'multiplayer'; menuState = 'friends'; friendMenuSelection = 0; authError = ''; loadFriendsList(); } }
          else if (i === 3) { menuState = 'main'; menuSelection = 1; }
          return;
        }
      }
      // Login/Register or Logout buttons at bottom
      if (!playerUsername) {
        if (cy > H * 0.76 && cy < H * 0.87) { menuState = 'account'; authInputField = 0; authScreen = 'login'; authError = ''; return; }
      } else {
        // Logout button click
        if (cy > H * 0.72 && cy < H * 0.82) { logoutAccount(); return; }
      }
      return;
    } else if (menuState === 'account') {
      // Account screen touch — generous touch targets
      const accY = H * 0.38;
      // Username field
      if (cy > accY - 14 && cy < accY + 32) { activateTextInput('username'); return; }
      // Password field
      if (cy > accY + 34 && cy < accY + 78) { activateTextInput('password'); return; }
      if (authScreen === 'register' && cy > accY + 82 && cy < accY + 130) { activateTextInput('confirm'); return; }
      // Submit button
      const btnY = authScreen === 'register' ? accY + 150 : accY + 100;
      if (cy > btnY - 14 && cy < btnY + 32) {
        if (authScreen === 'register') registerAccount(authInputs.username, authInputs.password);
        else loginAccount(authInputs.username, authInputs.password);
        return;
      }
      // Toggle login/register
      if (cy > btnY + 25 && cy < btnY + 60) {
        authScreen = authScreen === 'login' ? 'register' : 'login';
        return;
      }
      // Guest button
      if (cy > btnY + 55 && cy < btnY + 90) { playAsGuest(); return; }
      // Back
      if (cy > H * 0.88) { authError = ''; menuState = 'multiplayer'; return; }
      return;
    } else if (menuState === 'lobby') {
      // Chat area tap → open chat
      if (cy > H * 0.58 && cy < H * 0.87) { chatOpen = true; activateTextInput('chat'); chatInput = ''; return; }
      // Start button (host only)
      if (isHost && cy > H * 0.87) { startMultiplayerGame(); return; }
      // Leave button (bigger touch target)
      if (cx < 140 && cy < 50) { leaveRoom(); return; }
      return;
    } else if (menuState === 'friends') {
      // Tab buttons at top
      const tabW = W / 4;
      if (cy > H * 0.25 && cy < H * 0.33) {
        friendTab = Math.floor(cx / tabW);
        if (friendTab > 3) friendTab = 3;
        friendMenuSelection = 0;
        return;
      }
      // Add friend input tap
      if (friendTab === 3 && cy > H * 0.38 && cy < H * 0.52) { activateTextInput('friendadd'); friendInput = ''; return; }
      // List item taps
      const listY = H * 0.42;
      const items = friendTab === 0 ? friendsList : friendTab === 1 ? friendRequests : friendTab === 2 ? blockedUsers : [];
      for (let i = 0; i < items.length; i++) {
        const y = listY + i * 36;
        if (cy > y - 14 && cy < y + 24) {
          friendMenuSelection = i;
          // Action buttons on right side
          if (cx > W - 120) {
            if (friendTab === 0) removeFriend(items[i].uid);
            else if (friendTab === 1) { if (cx > W - 60) declineFriendRequest(items[i].uid); else acceptFriendRequest(items[i].uid); }
            else if (friendTab === 2) unblockUser(items[i].uid);
          }
          return;
        }
      }
      // Back
      if (cy > H * 0.88) {
        if (friendsBackTo === 'multiplayer') { menuState = 'multiplayer'; mpMenuSelection = 0; }
        else { menuState = 'main'; menuSelection = 5; }
        return;
      }
      return;
    }
    return;
  }
  
  // Skip cutscene click (top-right SKIP button)
  if (state === 'cutscene' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { cutscene.phase = 3; cutscene.fadeAlpha = 1; cutscene.timer = 0; } return;
  }
  if (state === 'phonecall' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { phonecallTimer = 1; } return;
  }
  if (state === 'fusioncutscene' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { fusionCutsceneTimer = 1; } return;
  }
  if (state === 'hawkingRefusal' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { hawkingRefusalTimer = 1129; } return;
  }
  if (state === 'hawkingDeath' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { hawkingDeathTimer = 899; } return;
  }
  if (state === 'winCutscene' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { winCutsceneTimer = 699; } return;
  }
  if (state === 'bossdialogue' && cx > W - 120 && cy < 50) {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { bossDialogue.index = bossDialogue.texts.length; advanceCutscene(); } return;
  }
  // Skip split fight cinematic
  if (state === 'splitfight' && bossIntroTimer > 1) {
    bossIntroTimer = 1; return;
  }
  
  if (state === 'tutorial') { tutorialPage++; if (tutorialPage >= 5) completeTutorial(); return; }
  if (state === 'cutscene' || state === 'bossdialogue') {
    if (mpEnabled && !isHost) { mpSendCutsceneEvent('advance'); } else { advanceCutscene(); } return;
  }
  if ((state === 'playing' || state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight') && player.alive) throwProjectile();
  // Win/lose retry buttons via mouse click
  if ((state === 'won' || state === 'dead') && restartCooldown <= 0) {
    const btnY = state === 'won' ? H/2 + 30 : H/2 + 20;
    const btnW2 = 160, btnH2 = 48;
    if (cy > btnY && cy < btnY + btnH2) {
      if (cx > W/2 - btnW2 - 10 && cx < W/2 - 10) {
        // Retry
        if (mpEnabled) { mpVoteRetry(); if (isHost) { const tc = Object.keys(roomPlayers).length; const rc = Object.keys(mpRetryVotes).length; if (rc >= tc) mpTriggerRetry(); } } else { startGame(); }
      } else if (cx > W/2 + 10 && cx < W/2 + btnW2 + 10) {
        // Leave
        if (mpEnabled) { leaveRoom(); } state = 'menu'; menuState = 'main'; menuSelection = 0;
      }
    }
  }
});

// Keyboard fullscreen toggle (F11)
window.addEventListener('keydown', e => {
  if (e.key === 'F11') { e.preventDefault(); toggleFullscreen(); }
});

// Touch controls — track active touches by ID
let aimTouchId = null; // separate tracking for aim joystick

// Touch button hit zones — dynamically split based on joystick positions
function isInMoveZone(cx, cy) {
  // Touch is in move zone if closer to move joystick center
  const mdx = cx - getMoveCenterX(), mdy = cy - getMoveCenterY();
  const adx = cx - getAimCenterX(), ady = cy - getAimCenterY();
  return (mdx*mdx + mdy*mdy) < (adx*adx + ady*ady);
}

function isInAimZone(cx, cy) {
  return !isInMoveZone(cx, cy);
}

function updateAimFromTouch(cx, cy) {
  const acx = getAimCenterX(), acy = getAimCenterY();
  touchAim.dx = cx - acx;
  touchAim.dy = cy - acy;
  const dist = Math.sqrt(touchAim.dx * touchAim.dx + touchAim.dy * touchAim.dy);
  if (dist > AIM_DEAD_ZONE) {
    touchAim.angle = Math.atan2(touchAim.dy, touchAim.dx);
    touchAim.active = true;
  }
}

let touchJumpQueued = false; // survives between frames so quick taps aren't lost
function updateTouchControlsFromActive() {
  // Movement from joystick
  if (moveJoystick.active) {
    const dist = Math.sqrt(moveJoystick.dx * moveJoystick.dx + moveJoystick.dy * moveJoystick.dy);
    touchControls.left = dist > MOVE_DEAD_ZONE && moveJoystick.dx < -MOVE_DEAD_ZONE;
    touchControls.right = dist > MOVE_DEAD_ZONE && moveJoystick.dx > MOVE_DEAD_ZONE;
  } else {
    touchControls.left = false;
    touchControls.right = false;
  }
  // Jump from joystick-up — queue a jump for rising edge
  touchControls.up = moveJoystick.inJumpUp || touchJumpQueued;
}

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  mouseActive = false;
  for (const t of e.changedTouches) {
    const { x: cx, y: cy } = clientToCanvas(t.clientX, t.clientY);

    // Performance mode prompt buttons (highest priority when visible)
    if (_showPerfPrompt && window._perfYesBtn && window._perfNoBtn) {
      const yb = window._perfYesBtn, nb = window._perfNoBtn;
      if (cx >= yb.x && cx <= yb.x + yb.w && cy >= yb.y && cy <= yb.y + yb.h) { _acceptPerfMode(); return; }
      if (cx >= nb.x && cx <= nb.x + nb.w && cy >= nb.y && cy <= nb.y + nb.h) { _declinePerfMode(); return; }
      return; // block all touches while prompt is up
    }

    // Fullscreen button (top-right, always available)
    if (cx > W - 48 && cy < 48) {
      toggleFullscreen();
      return;
    }

    // Menu touch support
    if (state === 'menu') {
      if (menuState === 'main') {
        const menuY = H * 0.35;
        for (let i = 0; i < 8; i++) {
          const y = menuY + i * 40;
          if (cx > W/2 - 160 && cx < W/2 + 160 && cy > y - 18 && cy < y + 18) {
            menuSelection = i;
            if (i === 0) {
              if (tutorialDone) { startGame(); }
              else { state = 'tutorial'; tutorialPage = 0; }
            }
            else if (i === 1) { menuState = 'multiplayer'; mpMenuSelection = 0; authError = ''; }
            else if (i === 2) { menuState = 'difficulty'; menuSelection = 0; }
            else if (i === 3) { menuState = 'settings'; menuSelection = 0; }
            else if (i === 4) { menuState = 'controls'; menuSelection = 0; }
            else if (i === 5) { friendsBackTo = 'main'; menuState = 'friends'; friendMenuSelection = 0; authError = ''; loadFriendsList(); }
            else if (i === 6) { menuState = 'credits'; menuSelection = 0; }
            else if (i === 7) { menuState = 'cheats'; cheatSelection = 0; }
            return;
          }
        }
      } else if (menuState === 'difficulty') {
        const diffY = H * 0.42;
        for (let i = 0; i < 4; i++) {
          const y = diffY + i * 55;
          if (cx > W/2 - 200 && cx < W/2 + 200 && cy > y - 22 && cy < y + 28) {
            const diffs = ['easy','normal','hard','insane'];
            settings.difficulty = diffs[i];
            menuState = 'main'; menuSelection = 2;
            return;
          }
        }
        if (cy > H * 0.85) { menuState = 'main'; menuSelection = 2; return; }
      } else if (menuState === 'settings') {
        const setY = H * 0.36;
        for (let i = 0; i < 8; i++) {
          const y = setY + i * 40;
          if (cx > W/2 - 200 && cx < W/2 + 200 && cy > y - 16 && cy < y + 20) {
            if (i === 0) settings.screenShake = !settings.screenShake;
            else if (i === 1) settings.particles = !settings.particles;
            else if (i === 2) settings.showFPS = !settings.showFPS;
            else if (i === 3) settings.doubleJump = !settings.doubleJump;
            else if (i === 4) settings.showTimer = !settings.showTimer;
            else if (i === 5) settings.colorblind = !settings.colorblind;
            else if (i === 6) { menuState = 'touchcontrols'; menuSelection = 0; }
            else if (i === 7) { menuState = 'main'; menuSelection = 3; }
            return;
          }
        }
      } else if (menuState === 'touchcontrols') {
        // Preset list
        const presetKeys = Object.keys(TOUCH_PRESETS);
        const tcY = H * 0.36;
        for (let i = 0; i < presetKeys.length; i++) {
          const y = tcY + i * 36;
          if (cx > W/2 - 200 && cx < W/2 + 200 && cy > y - 14 && cy < y + 18) {
            touchPresetName = presetKeys[i];
            touchLayout = Object.assign({}, TOUCH_PRESETS[touchPresetName]);
            saveTouchLayout();
            return;
          }
        }
        // Size controls
        const sizeY = tcY + presetKeys.length * 36 + 10;
        if (cx > W/2 - 80 && cx < W/2 - 40 && cy > sizeY - 10 && cy < sizeY + 20) {
          touchLayout.moveR = Math.max(35, touchLayout.moveR - 5); touchPresetName = 'custom'; saveTouchLayout(); return;
        }
        if (cx > W/2 + 40 && cx < W/2 + 80 && cy > sizeY - 10 && cy < sizeY + 20) {
          touchLayout.moveR = Math.min(100, touchLayout.moveR + 5); touchPresetName = 'custom'; saveTouchLayout(); return;
        }
        const sizeY2 = sizeY + 32;
        if (cx > W/2 - 80 && cx < W/2 - 40 && cy > sizeY2 - 10 && cy < sizeY2 + 20) {
          touchLayout.aimR = Math.max(35, touchLayout.aimR - 5); touchPresetName = 'custom'; saveTouchLayout(); return;
        }
        if (cx > W/2 + 40 && cx < W/2 + 80 && cy > sizeY2 - 10 && cy < sizeY2 + 20) {
          touchLayout.aimR = Math.min(100, touchLayout.aimR + 5); touchPresetName = 'custom'; saveTouchLayout(); return;
        }
        // Reset
        const resetY = sizeY2 + 36;
        if (cx > W/2 - 60 && cx < W/2 + 60 && cy > resetY - 12 && cy < resetY + 18) {
          touchPresetName = 'default'; touchLayout = Object.assign({}, TOUCH_PRESETS.default); saveTouchLayout(); return;
        }
        // Back
        const backY = resetY + 36;
        if (cx > W/2 - 60 && cx < W/2 + 60 && cy > backY - 12 && cy < backY + 18) {
          menuState = 'settings'; menuSelection = 6; return;
        }
        // Drag joystick on preview area (bottom of screen)
        if (cy > H * 0.7) {
          const pvTop = H * 0.7;
          const pvH = H - pvTop - 10;
          const pvCenterY = pvTop + pvH / 2 + 8;
          const pvScaleX = (W - 80) / W;
          const pvScaleR = 0.5;
          const pvMCX = 40 + touchLayout.moveX * pvScaleX;
          const pvMCY = pvCenterY;
          const pvACX = 40 + touchLayout.aimX * pvScaleX;
          const pvACY = pvCenterY;
          const mdx = cx - pvMCX, mdy = cy - pvMCY;
          const adx = cx - pvACX, ady = cy - pvACY;
          if (Math.sqrt(mdx*mdx + mdy*mdy) < touchLayout.moveR * pvScaleR + 30) {
            tcDragging = 'move'; tcDragOffX = mdx; tcDragOffY = mdy; return;
          }
          if (Math.sqrt(adx*adx + ady*ady) < touchLayout.aimR * pvScaleR + 30) {
            tcDragging = 'aim'; tcDragOffX = adx; tcDragOffY = ady; return;
          }
        }
      } else if (menuState === 'cheats') {
        const cheatKeys = Object.keys(cheats);
        const cheatY = H * 0.28;
        const totalItems = cheatKeys.length + 3;
        for (let i = 0; i < totalItems; i++) {
          const y = cheatY + i * 38;
          if (cx > W/2 - 220 && cx < W/2 + 220 && cy > y - 14 && cy < y + 18) {
            if (i < cheatKeys.length) cheats[cheatKeys[i]] = !cheats[cheatKeys[i]];
            else if (i === cheatKeys.length) skipToFinalBoss();
            else if (i === cheatKeys.length + 1) watchCutscene();
            else { menuState = 'main'; menuSelection = 7; }
            return;
          }
        }
      } else if (menuState === 'multiplayer') {
        const mpItems = ['CREATE ROOM', 'JOIN ROOM', 'FRIENDS', 'BACK'];
        const mpY = H * 0.40;
        for (let i = 0; i < mpItems.length; i++) {
          const y = mpY + i * 50;
          if (cx > W/2 - 180 && cx < W/2 + 180 && cy > y - 24 && cy < y + 24) {
            if (i === 0) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else createRoom(); }
            else if (i === 1) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else { activateTextInput('roomcode'); joinRoomInput = ''; } }
            else if (i === 2) { if (!playerUsername) { menuState = 'account'; authInputField = 0; authError = ''; } else { friendsBackTo = 'multiplayer'; menuState = 'friends'; friendMenuSelection = 0; authError = ''; loadFriendsList(); } }
            else if (i === 3) { menuState = 'main'; menuSelection = 1; }
            return;
          }
        }
        if (!playerUsername) {
          if (cy > H * 0.76 && cy < H * 0.87) { menuState = 'account'; authInputField = 0; authScreen = 'login'; authError = ''; return; }
        } else {
          if (cy > H * 0.72 && cy < H * 0.82) { logoutAccount(); return; }
        }
      } else if (menuState === 'account') {
        const accY = H * 0.38;
        if (cy > accY - 14 && cy < accY + 32) { activateTextInput('username'); return; }
        if (cy > accY + 34 && cy < accY + 78) { activateTextInput('password'); return; }
        if (authScreen === 'register' && cy > accY + 82 && cy < accY + 130) { activateTextInput('confirm'); return; }
        const btnY = authScreen === 'register' ? accY + 150 : accY + 100;
        if (cy > btnY - 14 && cy < btnY + 32) {
          if (authScreen === 'register') registerAccount(authInputs.username, authInputs.password);
          else loginAccount(authInputs.username, authInputs.password);
          return;
        }
        if (cy > btnY + 25 && cy < btnY + 60) { authScreen = authScreen === 'login' ? 'register' : 'login'; return; }
        if (cy > btnY + 55 && cy < btnY + 90) { playAsGuest(); return; }
        if (cy > H * 0.88) { authError = ''; menuState = 'multiplayer'; return; }
      } else if (menuState === 'lobby') {
        // Chat area touch (left column)
        const colL = W/2 - 250;
        const colR = W/2 + 10;
        const colW = 230;
        const chatBoxY = H * 0.42;
        const chatBoxH = H * 0.40;
        if (cx > colL && cx < colL + colW && cy > chatBoxY && cy < chatBoxY + chatBoxH) {
          chatOpen = true; activateTextInput('chat'); chatInput = ''; return;
        }
        // Host match settings touch (right column)
        if (isHost && cx > colR && cx < colR + colW) {
          const settY = H * 0.26;
          for (let i = 0; i < 8; i++) {
            const SETT_SP = 34;
            const y = settY + i * SETT_SP;
            if (cy > y - 16 && cy < y + SETT_SP - 18) {
              mpSettingsSelection = i;
              if (i === 0) {
                const diffs = ['easy','normal','hard','insane'];
                let idx = diffs.indexOf(settings.difficulty);
                settings.difficulty = diffs[(idx + 1) % diffs.length];
              } else if (i === 1) { settings.doubleJump = !settings.doubleJump; }
              else if (i === 2) { cheats.godMode = !cheats.godMode; }
              else if (i === 3) { cheats.oneHitKill = !cheats.oneHitKill; }
              else if (i === 4) { cheats.infiniteJumps = !cheats.infiniteJumps; }
              else if (i === 5) { cheats.speedBoost = !cheats.speedBoost; }
              else if (i === 6) { cheats.bigProjectiles = !cheats.bigProjectiles; }
              else if (i === 7) { cheats.noCooldown = !cheats.noCooldown; }
              mpSyncLobbySettings();
              return;
            }
          }
        }
        if (isHost && cy > H * 0.84) { startMultiplayerGame(); return; }
        if (cx < 160 && cy < 60) { leaveRoom(); return; }
      } else if (menuState === 'friends') {
        const tabW = W / 4;
        if (cy > H * 0.25 && cy < H * 0.33) { friendTab = Math.min(3, Math.floor(cx / tabW)); friendMenuSelection = 0; return; }
        if (friendTab === 3 && cy > H * 0.38 && cy < H * 0.52) { activateTextInput('friendadd'); friendInput = ''; return; }
        const items = friendTab === 0 ? friendsList : friendTab === 1 ? friendRequests : friendTab === 2 ? blockedUsers : [];
        const listY = H * 0.42;
        for (let i = 0; i < items.length; i++) {
          const y = listY + i * 36;
          if (cy > y - 14 && cy < y + 24) {
            friendMenuSelection = i;
            if (cx > W - 120) {
              if (friendTab === 0) removeFriend(items[i].uid);
              else if (friendTab === 1) { if (cx > W - 60) declineFriendRequest(items[i].uid); else acceptFriendRequest(items[i].uid); }
              else if (friendTab === 2) unblockUser(items[i].uid);
            }
            return;
          }
        }
        if (cy > H * 0.88) {
          if (friendsBackTo === 'multiplayer') { menuState = 'multiplayer'; mpMenuSelection = 0; }
          else { menuState = 'main'; menuSelection = 5; }
          return;
        }
      } else if (menuState === 'controls' || menuState === 'credits') {
        const wasCredits = menuState === 'credits';
        menuState = 'main'; menuSelection = wasCredits ? 6 : 4;
        return;
      }
      return;
    }

    // Tutorial touch
    if (state === 'tutorial') {
      if (cx < W * 0.3 && tutorialPage > 0) { tutorialPage--; }
      else { tutorialPage++; if (tutorialPage >= 5) completeTutorial(); }
      return;
    }

    // Skip button touch (top-right area)
    if ((state === 'cutscene' || state === 'phonecall' || state === 'fusioncutscene' || state === 'bossdialogue' || state === 'hawkingRefusal' || state === 'hawkingDeath' || state === 'winCutscene') && cx > W - 140 && cy < 60) {
      if (state === 'cutscene') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { cutscene.phase = 3; cutscene.fadeAlpha = 1; cutscene.timer = 0; } }
      else if (state === 'phonecall') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { phonecallTimer = 1; } }
      else if (state === 'fusioncutscene') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { fusionCutsceneTimer = 1; } }
      else if (state === 'hawkingRefusal') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { hawkingRefusalTimer = 1129; } }
      else if (state === 'hawkingDeath') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { hawkingDeathTimer = 899; } }
      else if (state === 'winCutscene') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { winCutsceneTimer = 699; } }
      else if (state === 'bossdialogue') { if (mpEnabled && !isHost) { mpSendCutsceneEvent('skip'); } else { bossDialogue.index = bossDialogue.texts.length; advanceCutscene(); } }
      return;
    }

    // Advance cutscene/dialogue on touch
    if (state === 'cutscene' || state === 'bossdialogue') {
      if (mpEnabled && !isHost) { mpSendCutsceneEvent('advance'); } else { advanceCutscene(); } return;
    }
    if ((state === 'won' || state === 'dead') && restartCooldown <= 0) {
      // Touch retry/leave buttons — detect which button was tapped
      const btnY = state === 'won' ? H/2 + 30 : H/2 + 20;
      const btnW = 160, btnH = 48;
      if (cy > btnY && cy < btnY + btnH) {
        if (cx > W/2 - btnW - 10 && cx < W/2 - 10) {
          // Retry button
          if (mpEnabled) { mpVoteRetry(); if (isHost) { const tc = Object.keys(roomPlayers).length; const rc = Object.keys(mpRetryVotes).length; if (rc >= tc) mpTriggerRetry(); } } else { startGame(); }
        } else if (cx > W/2 + 10 && cx < W/2 + btnW + 10) {
          // Leave button
          if (mpEnabled) { leaveRoom(); } state = 'menu'; menuState = 'main'; menuSelection = 0;
        }
      }
      return;
    }

    // Gameplay touch controls — joystick up to jump
    if (state === 'playing' || state === 'intro' || state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight') {
      // Spectator touch — tap left/right half to cycle players
      if (mpSpectating) {
        const alive = getAlivePlayerList();
        if (alive.length > 0) {
          if (cx < W / 2) {
            mpSpectateIndex = (mpSpectateIndex - 1 + alive.length) % alive.length;
          } else {
            mpSpectateIndex = (mpSpectateIndex + 1) % alive.length;
          }
          mpSpectateTarget = alive[mpSpectateIndex].uid;
        }
        return;
      }

      // Aim joystick (right side)
      if (isInAimZone(cx, cy)) {
        aimTouchId = t.identifier;
        updateAimFromTouch(cx, cy);
        updateTouchControlsFromActive();
        throwProjectile();
      }
      // Movement joystick (left side)
      else if (isInMoveZone(cx, cy)) {
        moveJoystick.touchId = t.identifier;
        moveJoystick.active = true;
        moveJoystick.dx = cx - getMoveCenterX();
        moveJoystick.dy = cy - getMoveCenterY();
        // Check if initial touch is already in jump-up zone
        if (moveJoystick.dy < MOVE_JUMP_THRESHOLD) {
          moveJoystick.inJumpUp = true;
          touchJumpQueued = true;
          touchControls.up = true;
        }
        updateTouchControlsFromActive();
      }
    }
  }
}, { passive: false });

function clearTouch(id) {
  if (id === aimTouchId) { aimTouchId = null; touchAim.active = false; touchAim.dx = 0; touchAim.dy = 0; }
  if (id === moveJoystick.touchId) { moveJoystick.touchId = null; moveJoystick.active = false; moveJoystick.dx = 0; moveJoystick.dy = 0; moveJoystick.inJumpUp = false; }
}

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  if (tcDragging) { tcDragging = null; return; }
  for (const t of e.changedTouches) clearTouch(t.identifier);
  updateTouchControlsFromActive();
}, { passive: false });

canvas.addEventListener('touchcancel', e => {
  e.preventDefault();
  tcDragging = null;
  for (const t of e.changedTouches) clearTouch(t.identifier);
  updateTouchControlsFromActive();
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  // Touch controls editor drag
  if (tcDragging && state === 'menu' && menuState === 'touchcontrols') {
    const t = e.changedTouches[0];
    const { x: cx, y: cy } = clientToCanvas(t.clientX, t.clientY);
    const pvScaleX = (W - 80) / W;
    const newX = Math.max(60, Math.min(W - 60, (cx - tcDragOffX - 40) / pvScaleX));
    if (tcDragging === 'move') { touchLayout.moveX = Math.round(newX); }
    else if (tcDragging === 'aim') { touchLayout.aimX = Math.round(newX); }
    touchPresetName = 'custom';
    saveTouchLayout();
    return;
  }
  for (const t of e.changedTouches) {
    // Aim joystick drag
    if (t.identifier === aimTouchId) {
      const { x: cx, y: cy } = clientToCanvas(t.clientX, t.clientY);
      updateAimFromTouch(cx, cy);
    }
    // Movement joystick drag
    if (t.identifier === moveJoystick.touchId) {
      const { x: cx, y: cy } = clientToCanvas(t.clientX, t.clientY);
      moveJoystick.dx = cx - getMoveCenterX();
      moveJoystick.dy = cy - getMoveCenterY();
      // Joystick pushed up = jump
      if (moveJoystick.dy < MOVE_JUMP_THRESHOLD && !moveJoystick.inJumpUp) {
        moveJoystick.inJumpUp = true;
        touchJumpQueued = true;
        touchControls.up = true;
      } else if (moveJoystick.dy >= MOVE_JUMP_THRESHOLD) {
        moveJoystick.inJumpUp = false;
      }
      updateTouchControlsFromActive();
    }
  }
}, { passive: false });

// ── Player ──
let player = createPlayer();
function createPlayer() {
  return {
    x: 80, y: GROUND_Y - 80,
    w: 52, h: 80,
    vx: 0, vy: 0,
    onGround: false,
    onWall: false,
    wallDir: 0,
    climbingBigWall: false,
    jumpBuffer: 0,
    coyoteTime: 0,
    facing: 1,
    runFrame: 0,
    runTimer: 0,
    alive: true,
    won: false,
    trail: [],
    hp: 15,
    maxHp: 15,
    throwCooldown: 0,
    iFrames: 0,
    jumpsLeft: 2,
    maxJumps: 2,
    prevUp: false,
  };
}

// ── Level Elements ──
let walls = [];
let guards = [];
let bigWall = null;
let decorations = [];

function buildLevel() {
  walls = [];
  guards = [];
  decorations = [];

  // Small walls to jump over
  const wallPositions = [400, 800, 1300, 1800, 2400, 3000];
  wallPositions.forEach((x, i) => {
    const h = 70 + Math.random() * 40;
    walls.push({ x, y: GROUND_Y - h, w: 50, h, color: '#b08040' });
  });

  // Some platforms
  const platforms = [
    { x: 500, y: GROUND_Y - 140, w: 120 },
    { x: 1000, y: GROUND_Y - 150, w: 140 },
    { x: 1400, y: GROUND_Y - 130, w: 110 },
    { x: 1900, y: GROUND_Y - 160, w: 130 },
    { x: 2300, y: GROUND_Y - 140, w: 120 },
    { x: 2900, y: GROUND_Y - 170, w: 140 },
  ];
  platforms.forEach(p => {
    walls.push({ x: p.x, y: p.y, w: p.w, h: 20, color: '#666', isPlatform: true });
  });

  // Guards patrolling
  const dmGuards = getDiffMult();
  const guardSpots = [
    { x: 500, range: 100 },
    { x: 850, range: 90 },
    { x: 1200, range: 110 },
    { x: 1600, range: 100 },
    { x: 2000, range: 90 },
    { x: 2500, range: 110 },
    { x: 2900, range: 100 },
  ];
  guardSpots.forEach(g => {
    guards.push({
      x: g.x, y: GROUND_Y - 84,
      w: 56, h: 84,
      startX: g.x,
      range: g.range,
      speed: (1.2 + Math.random() * 0.7) * dmGuards.enemySpeed,
      dir: Math.random() > 0.5 ? 1 : -1,
      alert: false,
      alertTimer: 0,
      frame: 0,
      frameTimer: 0,
      hp: Math.ceil(3 * dmGuards.enemyHp),
      maxHp: Math.ceil(3 * dmGuards.enemyHp),
      climbing: false,
      shootCooldown: 60 + Math.floor(Math.random() * 60),
      dead: false,
    });
  });

  // THE BIG WALL at the end - MASSIVE (very wide)
  bigWall = {
    x: levelWidth - 900,
    y: GROUND_Y - 1200,
    w: 800,
    h: 1200,
  };

  // Background decorations - desert theme
  for (let i = 0; i < 40; i++) {
    const rng = Math.random();
    let type;
    if (rng < 0.35) type = 'cactus';
    else if (rng < 0.55) type = 'tumbleweed';
    else if (rng < 0.75) type = 'rock';
    else type = 'scrub';
    decorations.push({
      x: Math.random() * levelWidth,
      y: GROUND_Y,
      type,
      size: 14 + Math.random() * 30,
    });
  }
}

function skipToFinalBoss() {
  // Initialize the game first
  player = createPlayer();
  buildLevel();
  particles = [];
  projectiles = [];
  epsteinProjectiles = [];
  epstein = null;
  phonecallTimer = 0;
  fusionBoss = null;
  fusionCutsceneTimer = 0;
  bullets = [];
  cameraX = 0;
  cameraY = 0;
  boss = null;
  bossMinions = [];
  bossVfx = [];
  bossDeathTimer = 0;
  screenFlash = 0;
  hawkingPhase2 = false;
  hawkingRefusalTimer = 0;
  hawkingRefusalPhase = 0;
  hawkingDeathTimer = 0;
  hawkingDeathPhase = 0;
  winCutsceneTimer = 0;
  winCutsceneOfficeX = 0;
  bossIntroTimer = 0;
  bossDialogue = { active: false, texts: [], index: 0, timer: 0 };
  gameTimer = 0;
  restartCooldown = 0;
  
  const dm = getDiffMult();
  
  // Set up the arena
  const arenaW = 2400;
  const arenaH = 800;
  const arenaLeft = bigWall.x + bigWall.w / 2 - arenaW / 2;
  const arenaRight = arenaLeft + arenaW;
  const arenaTop = bigWall.y + 40;
  const arenaBottom = arenaTop + arenaH;
  arenaPlats = [
    { x: arenaLeft, y: arenaBottom, w: arenaW, h: 30, isArena: true, isFloor: true },
    { x: arenaLeft, y: arenaTop, w: arenaW, h: 20, isArena: true, isCeiling: true },
    { x: arenaLeft - 40, y: arenaTop, w: 40, h: arenaH + 30, isArena: true, isSideWall: true },
    { x: arenaRight, y: arenaTop, w: 40, h: arenaH + 30, isArena: true, isSideWall: true },
    { x: arenaLeft + 120, y: arenaBottom - 180, w: 200, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + 500, y: arenaBottom - 280, w: 220, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + arenaW / 2 - 120, y: arenaBottom - 400, w: 240, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 720, y: arenaBottom - 280, w: 220, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 320, y: arenaBottom - 180, w: 200, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + 300, y: arenaBottom - 100, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaLeft + arenaW / 2 - 60, y: arenaBottom - 150, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaRight - 420, y: arenaBottom - 100, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaLeft + 80, y: arenaBottom - 450, w: 160, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 240, y: arenaBottom - 450, w: 160, h: 18, isArena: true, isPlatform: true },
  ];
  
  // Spawn 5 mini-bosses spread across right side
  const miniDefs = [
    { name: 'TRUMP', img: 'boss', color: '#ff4400', hp: Math.ceil(18 * dm.enemyHp), speed: 2.8 * dm.enemySpeed },
    { name: 'EPSTEIN', img: 'epstein', color: '#8844ff', hp: Math.ceil(15 * dm.enemyHp), speed: 3.2 * dm.enemySpeed },
    { name: 'MUSK', img: 'musk', color: '#4488ff', hp: Math.ceil(15 * dm.enemyHp), speed: 3.8 * dm.enemySpeed },
    { name: 'CLINTON', img: 'clinton', color: '#cc2222', hp: Math.ceil(12 * dm.enemyHp), speed: 2.5 * dm.enemySpeed },
    { name: 'HAWKING', img: 'hawking', color: '#44ff88', hp: Math.ceil(35 * dm.enemyHp), speed: 1.0 * dm.enemySpeed },
  ];
  miniBosses = [];
  for (let i = 0; i < miniDefs.length; i++) {
    const md = miniDefs[i];
    const bx = arenaLeft + arenaW * (0.55 + i * 0.08);
    const by = i === 4 ? (arenaBottom - 280) : (arenaBottom - 100 - Math.random() * 60);
    miniBosses.push({
      x: bx - 40, y: by - 50,
      w: 80, h: 100,
      hp: md.hp, maxHp: md.hp,
      name: md.name, imgKey: md.img, color: md.color,
      dir: -1,
      speed: md.speed,
      frame: 0, frameTimer: 0,
      dead: false,
      vy: 0, vx: 0,
      shootCooldown: 60 + i * 15,
      attackTimer: 0,
    });
  }
  
  // Player on left side with full HP
  player.maxHp = 50;
  player.hp = player.maxHp;
  player.x = arenaLeft + arenaW * 0.15;
  player.y = arenaBottom - player.h - 10;
  player.facing = 1;
  
  state = 'splitfight';
  bossIntroTimer = 0; // skip cinematic, go straight to fight
  screenFlash = 30;
  screenFlashColor = '#ffffff';
  shakeTimer = 20;
}

function watchCutscene() {
  // Same setup as skipToFinalBoss but WITH the cinematic
  player = createPlayer();
  buildLevel();
  particles = [];
  projectiles = [];
  epsteinProjectiles = [];
  epstein = null;
  phonecallTimer = 0;
  fusionBoss = null;
  fusionCutsceneTimer = 0;
  bullets = [];
  cameraX = 0;
  cameraY = 0;
  boss = null;
  bossMinions = [];
  bossVfx = [];
  bossDeathTimer = 0;
  screenFlash = 0;
  hawkingPhase2 = false;
  hawkingRefusalTimer = 0;
  hawkingRefusalPhase = 0;
  hawkingDeathTimer = 0;
  hawkingDeathPhase = 0;
  winCutsceneTimer = 0;
  winCutsceneOfficeX = 0;
  bossIntroTimer = 0;
  bossDialogue = { active: false, texts: [], index: 0, timer: 0 };
  gameTimer = 0;
  restartCooldown = 0;
  
  const arenaW = 2400;
  const arenaH = 800;
  const arenaLeft = bigWall.x + bigWall.w / 2 - arenaW / 2;
  const arenaRight = arenaLeft + arenaW;
  const arenaTop = bigWall.y + 40;
  const arenaBottom = arenaTop + arenaH;
  arenaPlats = [
    { x: arenaLeft, y: arenaBottom, w: arenaW, h: 30, isArena: true, isFloor: true },
    { x: arenaLeft, y: arenaTop, w: arenaW, h: 20, isArena: true, isCeiling: true },
    { x: arenaLeft - 40, y: arenaTop, w: 40, h: arenaH + 30, isArena: true, isSideWall: true },
    { x: arenaRight, y: arenaTop, w: 40, h: arenaH + 30, isArena: true, isSideWall: true },
    { x: arenaLeft + 120, y: arenaBottom - 180, w: 200, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + 500, y: arenaBottom - 280, w: 220, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + arenaW / 2 - 120, y: arenaBottom - 400, w: 240, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 720, y: arenaBottom - 280, w: 220, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 320, y: arenaBottom - 180, w: 200, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + 300, y: arenaBottom - 100, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaLeft + arenaW / 2 - 60, y: arenaBottom - 150, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaRight - 420, y: arenaBottom - 100, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaLeft + 80, y: arenaBottom - 450, w: 160, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 240, y: arenaBottom - 450, w: 160, h: 18, isArena: true, isPlatform: true },
  ];
  
  const dm2 = getDiffMult();
  const miniDefs = [
    { name: 'TRUMP', img: 'boss', color: '#ff4400', hp: Math.ceil(18 * dm2.enemyHp), speed: 2.8 * dm2.enemySpeed },
    { name: 'EPSTEIN', img: 'epstein', color: '#8844ff', hp: Math.ceil(15 * dm2.enemyHp), speed: 3.2 * dm2.enemySpeed },
    { name: 'MUSK', img: 'musk', color: '#4488ff', hp: Math.ceil(15 * dm2.enemyHp), speed: 3.8 * dm2.enemySpeed },
    { name: 'CLINTON', img: 'clinton', color: '#cc2222', hp: Math.ceil(12 * dm2.enemyHp), speed: 2.5 * dm2.enemySpeed },
    { name: 'HAWKING', img: 'hawking', color: '#44ff88', hp: Math.ceil(35 * dm2.enemyHp), speed: 1.0 * dm2.enemySpeed },
  ];
  const cx = arenaLeft + arenaW / 2;
  const cy = arenaTop + arenaH / 2;
  miniBosses = [];
  for (let i = 0; i < miniDefs.length; i++) {
    const angle = (i / miniDefs.length) * Math.PI * 2 - Math.PI / 2;
    const spawnDist = 120;
    const md = miniDefs[i];
    miniBosses.push({
      x: cx + Math.cos(angle) * spawnDist - 40,
      y: cy + Math.sin(angle) * spawnDist - 50,
      w: 80, h: 100,
      hp: md.hp, maxHp: md.hp,
      name: md.name, imgKey: md.img, color: md.color,
      dir: Math.random() > 0.5 ? 1 : -1,
      speed: md.speed,
      frame: 0, frameTimer: 0,
      dead: false,
      vy: 0, vx: 0,
      shootCooldown: 60 + i * 15,
      attackTimer: 0,
    });
  }
  
  player.maxHp = 50;
  player.hp = player.maxHp;
  player.x = arenaLeft + arenaW * 0.15;
  player.y = arenaBottom - player.h - 10;
  player.facing = 1;
  
  state = 'splitfight';
  bossIntroTimer = 1800; // full 30-second cinematic
  screenFlash = 40;
  screenFlashColor = '#ffffff';
  shakeTimer = 20;
}

function startGame() {
  player = createPlayer();
  buildLevel();
  particles = [];
  projectiles = [];
  epsteinProjectiles = [];
  epstein = null;
  phonecallTimer = 0;
  fusionBoss = null;
  fusionCutsceneTimer = 0;
  miniBosses = [];
  bullets = [];
  cameraX = 0;
  cameraY = 0;
  mpDeathSynced = false;
  mpSpectating = false;
  mpSpectateTarget = null;
  mpSpectateIndex = 0;
  mpRetryVotes = {};
  mpRetrySelection = 0;
  // Boss starts hidden - spawns after cutscene at wall top
  boss = null;
  bossMinions = [];
  bossVfx = [];
  bossDeathTimer = 0;
  screenFlash = 0;
  hawkingPhase2 = false;
  hawkingRefusalTimer = 0;
  hawkingRefusalPhase = 0;
  hawkingDeathTimer = 0;
  hawkingDeathPhase = 0;
  winCutsceneTimer = 0;
  winCutsceneOfficeX = 0;
  bossIntroTimer = 0;
  bossDialogue = { active: false, texts: [], index: 0, timer: 0 };
  
  // Build BORDER WALL arena — fills most of the screen area
  const arenaW = 2400; // very wide — nearly full screen
  const arenaH = 800; // tall room
  const arenaLeft = bigWall.x + bigWall.w / 2 - arenaW / 2;
  const arenaRight = arenaLeft + arenaW;
  const arenaTop = bigWall.y + 40; // below wall top so it feels underground
  const arenaBottom = arenaTop + arenaH;
  arenaPlats = [
    // Main arena floor
    { x: arenaLeft, y: arenaBottom, w: arenaW, h: 30, isArena: true, isFloor: true },
    // Ceiling
    { x: arenaLeft, y: arenaTop, w: arenaW, h: 20, isArena: true, isCeiling: true },
    // Left wall (fully enclosed)
    { x: arenaLeft - 40, y: arenaTop, w: 40, h: arenaH + 30, isArena: true, isSideWall: true },
    // Right wall (fully enclosed)
    { x: arenaRight, y: arenaTop, w: 40, h: arenaH + 30, isArena: true, isSideWall: true },
    // Elevated platforms for dodging — more of them, spread out
    { x: arenaLeft + 120, y: arenaBottom - 180, w: 200, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + 500, y: arenaBottom - 280, w: 220, h: 18, isArena: true, isPlatform: true },
    { x: arenaLeft + arenaW / 2 - 120, y: arenaBottom - 400, w: 240, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 720, y: arenaBottom - 280, w: 220, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 320, y: arenaBottom - 180, w: 200, h: 18, isArena: true, isPlatform: true },
    // Small cover platforms
    { x: arenaLeft + 300, y: arenaBottom - 100, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaLeft + arenaW / 2 - 60, y: arenaBottom - 150, w: 120, h: 14, isArena: true, isPlatform: true },
    { x: arenaRight - 420, y: arenaBottom - 100, w: 120, h: 14, isArena: true, isPlatform: true },
    // High side platforms
    { x: arenaLeft + 80, y: arenaBottom - 450, w: 160, h: 18, isArena: true, isPlatform: true },
    { x: arenaRight - 240, y: arenaBottom - 450, w: 160, h: 18, isArena: true, isPlatform: true },
  ];
  
  cutscene = {
    active: false, timer: 0, phase: 0, dialogueIndex: 0,
    dialogues: [
      '...',
      'Well, well, well... Look who made it to the WALL.',
      'Welcome to MY border. The BEST wall. TREMENDOUS.',
      'Nobody gets through. NOBODY.',
      'I\'m gonna Make America Great Again!',
      'You think you can cross MY wall? NOT HAPPENING!',
      'Now get ready to be DEPORTED! BIGLY!',
    ],
    fadeAlpha: 0,
  };
  // Start cinematic intro
  introTimer = 0;
  introPhase = 0;
  introParticles = [];
  gameTimer = 0;
  // Apply difficulty to player HP
  const dm = getDiffMult();
  player.hp = dm.playerHp;
  player.maxHp = dm.playerHp;
  state = 'intro';
  restartCooldown = 30;
}

// ── Cutscene Control ──
function advanceCutscene() {
  // Mid-fight boss dialogue
  if (state === 'bossdialogue') {
    bossDialogue.index++;
    if (bossDialogue.index >= bossDialogue.texts.length) {
      bossDialogue.active = false;
      // Return to correct fight state
      if (fusionBoss && !fusionBoss.dead) state = 'fusionfight';
      else if (miniBosses.length > 0 && !miniBosses.every(m => m.dead)) state = 'splitfight';
      else if (epstein && !epstein.dead) state = 'epsteinfight';
      else state = 'bossfight';
    }
    bossDialogue.timer = 0;
    return;
  }
  if (cutscene.phase === 0) return; // still fading in
  if (cutscene.phase === 1) {
    // Boss image shown, advance to dialogue
    cutscene.phase = 2;
    cutscene.dialogueIndex = 0;
    cutscene.timer = 0;
  } else if (cutscene.phase === 2) {
    cutscene.dialogueIndex++;
    if (cutscene.dialogueIndex >= cutscene.dialogues.length) {
      cutscene.phase = 3;
      cutscene.timer = 0;
    }
  }
}

// ── Throw Projectile ──
function throwProjectile() {
  if (!player.alive) return;
  if (state === 'hawkingDeath' || state === 'hawkingRefusal') return;
  const p = player;
  if (p.throwCooldown > 0 && !cheats.noCooldown) return;
  p.throwCooldown = cheats.noCooldown ? 0 : 18;
  // Aim: mouse on PC, joystick on touch, fallback to facing direction
  let vx, vy;
  const pjSpd = cheats.bigProjectiles ? 20 : 12;
  if (touchAim.active) {
    // Touch aim joystick — fire in joystick direction
    vx = Math.cos(touchAim.angle) * pjSpd;
    vy = Math.sin(touchAim.angle) * pjSpd;
    p.facing = vx > 0 ? 1 : -1;
  } else if (mouseActive) {
    // Aim toward mouse position (in screen coords, adjust for camera)
    const px = p.x + p.w/2 - cameraX;
    const py = p.y + p.h/3 - cameraY;
    const dx = mouseX - px;
    const dy = mouseY - py;
    const dist = Math.sqrt(dx*dx + dy*dy) || 1;
    vx = (dx / dist) * pjSpd;
    vy = (dy / dist) * pjSpd;
    p.facing = vx > 0 ? 1 : -1;
  } else {
    vx = p.facing * pjSpd;
    vy = 0;
  }
  const pjSize = cheats.bigProjectiles ? 50 : 28;
  projectiles.push({
    x: p.x + p.w / 2,
    y: p.y + p.h / 3,
    vx: vx,
    vy: vy,
    w: pjSize,
    h: pjSize,
    life: 100,
  });
}

// ── Collision ──
function rectsOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

// ── Particles ──
const MAX_PARTICLES = 800;
function spawnParticles(x, y, color, count) {
  if (!settings.particles) return; // respect particles setting
  if (particles.length >= MAX_PARTICLES) return; // cap total particles for performance
  const allowed = Math.min(count, MAX_PARTICLES - particles.length);
  for (let i = 0; i < allowed; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 1) * 5,
      life: 30 + Math.random() * 30,
      color,
      size: 2 + Math.random() * 3,
    });
  }
}

// ── Colorblind-safe color helper ──
function cbColor(normal, colorblindAlt) {
  return settings.colorblind ? colorblindAlt : normal;
}
// Colorblind palette replacements:
// Red (#ff4444) → Orange (#ff8800)
// Green (#44ff44, #22aa22) → Cyan (#44ddff, #2299cc)  
// Red+Green HP bars → Blue+Yellow scheme
function cbHP(pct) {
  if (settings.colorblind) {
    if (pct > 0.5) return { a: '#2299cc', b: '#44ddff' }; // high = cyan
    if (pct > 0.25) return { a: '#aa8800', b: '#ffcc22' }; // mid = yellow
    return { a: '#cc4400', b: '#ff8800' }; // low = orange
  }
  if (pct > 0.5) return { a: '#22aa22', b: '#44ff44' }; // high = green
  if (pct > 0.25) return { a: '#aa8800', b: '#ffcc22' }; // mid = yellow
  return { a: '#aa2222', b: '#ff4444' }; // low = red
}

// ── Update ──
function update() {
  if (restartCooldown > 0) restartCooldown--;
  if (shakeTimer > 0 && settings.screenShake) shakeTimer--;
  else if (!settings.screenShake) shakeTimer = 0;

  // Toast life management
  for (let i = mpToasts.length - 1; i >= 0; i--) {
    mpToasts[i].life--;
    if (mpToasts[i].life <= 0) mpToasts.splice(i, 1);
  }
  
  // ── MULTIPLAYER SYNC ──
  if (mpEnabled && player) {
    syncMyPosition();
    if (isHost) syncEnemyData();
    if (!isHost) applyEnemyData();
    // Immediately sync death (once, not every frame)
    if (!player.alive && state === 'dead' && !mpDeathSynced) {
      mpDeathSynced = true;
      syncMyPositionImmediate();
    }
    if (player.alive) mpDeathSynced = false;
    
    // Host checks if ALL players are dead → game over for everyone
    if (isHost && !player.alive && state !== 'dead' && state !== 'won' && state !== 'menu') {
      const anyAlive = Object.keys(roomPlayers).some(pid => {
        const rp = roomPlayers[pid];
        return rp && rp.alive && rp.hp > 0;
      });
      if (!anyAlive) {
        state = 'dead';
        mpSpectating = false;
        restartCooldown = 60;
      }
    }
    // Host auto-triggers retry when all votes are in
    if (isHost && (state === 'won' || state === 'dead') && restartCooldown <= 0) {
      const totalPlayers = Object.keys(roomPlayers).length;
      const retryCount = Object.keys(mpRetryVotes).length;
      if (retryCount > 0 && retryCount >= totalPlayers) {
        mpTriggerRetry();
      }
    }
  }
  textCursorBlink = (textCursorBlink + 1) % 60;
  
  // ── CHEAT EFFECTS ──
  if (cheats.godMode && player.alive) {
    player.hp = player.maxHp;
  }

  // Player invulnerable during hawkingDeath scene and splitfight cutscene
  if (state === 'hawkingDeath' || (state === 'splitfight' && bossIntroTimer > 0)) {
    player.iFrames = Math.max(player.iFrames, 5);
  }

  // ── MENU BACKGROUND UPDATE ──
  if (state === 'menu' || state === 'tutorial') {
    menuBgTimer++;
    menuBgFloorY = H - 100;
    // Spawn bullets from right
    if (menuBgTimer % 40 === 0) {
      menuBgBullets.push({
        x: W + 10, y: menuBgFloorY - 20 - Math.random() * 60,
        vx: -3 - Math.random() * 3,
        size: 4 + Math.random() * 4,
      });
    }
    // Update bullets
    for (let i = menuBgBullets.length - 1; i >= 0; i--) {
      menuBgBullets[i].x += menuBgBullets[i].vx;
      if (menuBgBullets[i].x < -20) menuBgBullets.splice(i, 1);
    }
    // Update runners
    for (const r of menuBgRunners) {
      r.frameTimer++;
      if (r.frameTimer > 6) { r.frameTimer = 0; r.frame = (r.frame + 1) % 4; }
      r.x += 2;
      if (r.x > W + 60) r.x = -60;
      // Jump over incoming bullets
      r.jumpTimer--;
      let shouldJump = false;
      for (const b of menuBgBullets) {
        if (b.x > r.x && b.x < r.x + 80 && Math.abs(b.y - r.y) < 50) { shouldJump = true; break; }
      }
      if ((r.jumpTimer <= 0 || shouldJump) && r.onGround) {
        r.vy = -10 - Math.random() * 3;
        r.onGround = false;
        r.jumpTimer = 60 + Math.floor(Math.random() * 60);
      }
      r.vy += 0.5;
      r.y += r.vy;
      if (r.y >= menuBgFloorY - r.h) {
        r.y = menuBgFloorY - r.h;
        r.vy = 0;
        r.onGround = true;
      }
    }
    if (state === 'menu') return; // don't update game logic
  }

  // ── CINEMATIC INTRO ──
  if (state === 'intro') {
    introTimer++;
    
    // Phase 0: Black screen (0-60)
    if (introPhase === 0 && introTimer > 60) {
      introPhase = 1; introTimer = 0;
    }
    // Phase 1: Title slam (0-90)
    if (introPhase === 1 && introTimer > 90) {
      introPhase = 2; introTimer = 0;
    }
    // Phase 2: Subtitle + tagline (0-80)
    if (introPhase === 2 && introTimer > 80) {
      introPhase = 3; introTimer = 0;
    }
    // Phase 3: Camera sweep across level (0-180)
    if (introPhase === 3) {
      // Pan camera across the level
      const sweepProgress = Math.min(1, introTimer / 160);
      const eased = sweepProgress < 0.5 ? 2 * sweepProgress * sweepProgress : 1 - Math.pow(-2 * sweepProgress + 2, 2) / 2;
      cameraX = eased * (levelWidth - W);
      cameraY = 0;
      // Spawn cinematic dust particles
      if (introTimer % 3 === 0) {
        introParticles.push({
          x: cameraX + Math.random() * W, y: Math.random() * H,
          vx: -1 + Math.random() * 2, vy: -0.5 + Math.random(),
          life: 60, size: 1 + Math.random() * 3, color: `hsl(${40 + Math.random()*20}, 80%, ${50+Math.random()*30}%)`
        });
      }
      if (introTimer > 180) { introPhase = 4; introTimer = 0; }
    }
    // Phase 4: Zoom to player (0-60)
    if (introPhase === 4) {
      const zoomProgress = Math.min(1, introTimer / 50);
      const eased = 1 - Math.pow(1 - zoomProgress, 3);
      cameraX = (levelWidth - W) * (1 - eased);
      if (introTimer > 60) { introPhase = 5; introTimer = 0; }
    }
    // Phase 5: "GO!" flash (0-50)
    if (introPhase === 5) {
      if (introTimer === 1) { screenFlash = 20; screenFlashColor = '#ffffff'; shakeTimer = 10; }
      if (introTimer > 50) { introPhase = 6; }
    }
    // Phase 6: Start playing
    if (introPhase >= 6) {
      cameraX = 0; cameraY = 0;
      state = 'playing';
    }
    
    // Update intro particles
    for (let i = introParticles.length - 1; i >= 0; i--) {
      const ip = introParticles[i];
      ip.x += ip.vx; ip.y += ip.vy; ip.life--;
      if (ip.life <= 0) introParticles.splice(i, 1);
    }
    
    // Still update screen effects
    if (screenFlash > 0) screenFlash--;
    if (shakeTimer > 0) shakeTimer--;
    particles = particles.filter(pt => { pt.x += pt.vx; pt.y += pt.vy; pt.vy += 0.15; pt.life--; pt.size *= 0.97; return pt.life > 0; });
    return;
  }

  // Cutscene update
  if (state === 'cutscene') {
    cutscene.timer++;
    if (cutscene.phase === 0) {
      // Fade to black
      cutscene.fadeAlpha += 0.025;
      if (cutscene.fadeAlpha >= 1) { cutscene.fadeAlpha = 1; cutscene.phase = 1; cutscene.timer = 0; }
    } else if (cutscene.phase === 1 && cutscene.timer > 120) {
      // Auto-advance from boss image to dialogue after 2 sec
      cutscene.phase = 2; cutscene.dialogueIndex = 0; cutscene.timer = 0;
    } else if (cutscene.phase === 2 && cutscene.timer > 180) {
      // Auto-advance dialogue lines every ~3 seconds
      advanceCutscene();
      cutscene.timer = 0;
    } else if (cutscene.phase === 3) {
      // Fade out from cutscene to bossfight
      cutscene.fadeAlpha -= 0.03;
      if (cutscene.fadeAlpha <= 0) {
        cutscene.fadeAlpha = 0;
        cutscene.active = false;
        // Spawn the boss in the border arena
        const arenaTop2 = bigWall.y + 40;
        const arenaH2 = 800;
        const arenaBottom2 = arenaTop2 + arenaH2;
        const dmBoss = getDiffMult();
        const bossBaseHp = Math.ceil(40 * dmBoss.enemyHp);
        boss = {
          x: bigWall.x + bigWall.w / 2 - 60,
          y: arenaBottom2 - 160,
          w: 120,
          h: 160,
          hp: bossBaseHp,
          maxHp: bossBaseHp,
          dir: -1,
          frame: 0,
          frameTimer: 0,
          shootCooldown: 50,
          dead: false,
          alert: true,
          phase: 1, // 1, 2, 3
          phaseTriggered2: false,
          phaseTriggered3: false,
          attackTimer: 0,
          currentAttack: 'shoot', // shoot, charge, slam, summon
          chargeVx: 0,
          charging: false,
          slamming: false,
          slamTimer: 0,
          summonCooldown: 300,
          speed: 1.5 * dmBoss.enemySpeed,
          vy: 0,
        };
        bossMinions = [];
        bossIntroTimer = 120; // dramatic entrance animation
        // Teleport player into the border arena!
        const arenaW2 = 2400;
        const arenaLeft2 = bigWall.x + bigWall.w/2 - arenaW2/2;
        player.x = arenaLeft2 + 100;
        player.y = arenaBottom2 - player.h;
        player.vy = 0;
        player.vx = 0;
        player.onGround = true;
        player.climbingBigWall = false;
        player.onWall = false;
        // Boss entrance flash - dramatic!
        screenFlash = 45;
        screenFlashColor = '#ff4444';
        shakeTimer = 30;
        // Dramatic VFX rings
        for (let r = 0; r < 3; r++) {
          bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h/2, radius: 30 + r*40, maxRadius: 250 + r*60, color: r===0?'#ff0000':r===1?'#ff8800':'#ffffff', life: 60, maxLife: 60 });
        }
        bossVfx.push({ type: 'text', x: boss.x + boss.w/2, y: boss.y - 40, text: '🔥 TRUMP AWAITS 🔥', color: '#ff4444', size: 38, life: 180, maxLife: 180, vy: -0.3 });
        state = 'bossfight';
      }
    }
    // Still update particles during cutscene
    if (screenFlash > 0) screenFlash--;
    if (bossIntroTimer > 0) bossIntroTimer--;
    particles = particles.filter(pt => { pt.x += pt.vx; pt.y += pt.vy; pt.vy += 0.15; pt.life--; pt.size *= 0.97; return pt.life > 0; });
    return;
  }

  // Boss mid-fight dialogue update (typewriter timer)
  if (state === 'bossdialogue') {
    bossDialogue.timer++;
    // Auto-advance dialogue after ~3 seconds per line
    if (bossDialogue.timer > 180) {
      advanceCutscene();
    }
    if (screenFlash > 0) screenFlash--;
    // Update VFX during dialogue too
    for (let i = bossVfx.length - 1; i >= 0; i--) {
      bossVfx[i].life--;
      if (bossVfx[i].type === 'ring') {
        const prog = 1 - bossVfx[i].life / bossVfx[i].maxLife;
        bossVfx[i].radius = bossVfx[i].maxRadius * prog;
      }
      if (bossVfx[i].life <= 0) bossVfx.splice(i, 1);
    }
    particles = particles.filter(pt => { pt.x += pt.vx; pt.y += pt.vy; pt.vy += 0.15; pt.life--; pt.size *= 0.97; return pt.life > 0; });
    return;
  }

  // ── PHONE CALL CUTSCENE UPDATE ──
  if (state === 'phonecall') {
    phonecallTimer--;
    // Advance dialogue automatically
    if (bossDialogue.active) {
      bossDialogue.timer++;
      if (bossDialogue.timer > 80) {
        bossDialogue.timer = 0;
        bossDialogue.index++;
        if (bossDialogue.index >= bossDialogue.texts.length) {
          bossDialogue.active = false;
        }
      }
    }
    if (phonecallTimer <= 0) {
      // Spawn Epstein!
      const bArenaW2 = 2400;
      const arenaLeft2 = bigWall.x + bigWall.w/2 - bArenaW2/2;
      const arenaTop2 = bigWall.y + 40;
      const arenaFloor2 = arenaTop2 + 800;
      const dmEps = getDiffMult();
      const epsBaseHp = Math.ceil(30 * dmEps.enemyHp);
      epstein = {
        x: arenaLeft2 + bArenaW2/2 - 50,
        y: arenaTop2 + 30,
        w: 100, h: 140,
        hp: epsBaseHp, maxHp: epsBaseHp,
        dir: -1, speed: 2.8 * dmEps.enemySpeed,
        frame: 0, frameTimer: 0,
        dead: false, phase: 1,
        phaseTriggered2: false,
        attackTimer: 0,
        shootCooldown: 40,
        teleportCooldown: 200,
        vy: 0,
        charging: false, chargeVx: 0,
      };
      state = 'epsteinfight';
      screenFlash = 40;
      screenFlashColor = '#8844ff';
      shakeTimer = 30;
      bossIntroTimer = 120; // longer dramatic entrance
      // +5 max HP for beating Trump
      player.maxHp += 5;
      player.hp = player.maxHp;
      bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 500, life: 50, maxLife: 50, color: '#8844ff' });
      bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 300, life: 40, maxLife: 40, color: '#ff44ff' });
      bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 150, life: 30, maxLife: 30, color: '#ffffff' });
      bossVfx.push({ type: 'text', x: epstein.x+epstein.w/2, y: epstein.y - 30, text: '\u2620 EPSTEIN HAS ARRIVED \u2620', life: 180, maxLife: 180, color: '#ff44ff' });
    }
    // Update VFX during phone call
    if (screenFlash > 0) screenFlash--;
    if (bossIntroTimer > 0) bossIntroTimer--;
    for (let i = bossVfx.length - 1; i >= 0; i--) {
      bossVfx[i].life--;
      if (bossVfx[i].type === 'ring') {
        const prog = 1 - bossVfx[i].life / bossVfx[i].maxLife;
        bossVfx[i].radius = bossVfx[i].maxRadius * prog;
      }
      if (bossVfx[i].life <= 0) bossVfx.splice(i, 1);
    }
    particles = particles.filter(pt => { pt.x += pt.vx; pt.y += pt.vy; pt.vy += 0.15; pt.life--; pt.size *= 0.97; return pt.life > 0; });
    return;
  }

  // ── FUSION CUTSCENE UPDATE ──
  if (state === 'fusioncutscene') {
    fusionCutsceneTimer--;
    const bArenaW = 2400;
    const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
    const arenaFloor = bigWall.y + 40 + 800;
    const centerX = arenaLeft + bArenaW/2;
    const centerY = arenaFloor - 200;
    const prog = 1 - fusionCutsceneTimer / 360;
    // Move Trump and Epstein toward center
    if (boss) {
      const targetX = centerX - 80;
      boss.x += (targetX - boss.x) * 0.04;
      boss.y += (centerY - boss.h/2 - boss.y) * 0.04;
      boss.dead = false;
    }
    if (epstein) {
      const targetX = centerX + 80 - epstein.w;
      epstein.x += (targetX - epstein.x) * 0.04;
      epstein.y += (centerY - epstein.h/2 - epstein.y) * 0.04;
      epstein.dead = false;
    }
    // Energy particles swirling toward center
    if (Math.random() < 0.5) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 200 + Math.random() * 200;
      particles.push({
        x: centerX + Math.cos(angle) * dist,
        y: centerY + Math.sin(angle) * dist,
        vx: -Math.cos(angle) * 3, vy: -Math.sin(angle) * 3,
        life: 40, color: ['#ff4400','#8844ff','#ffffff','#ffdd44'][Math.floor(Math.random()*4)],
        size: 3 + Math.random() * 5,
      });
    }
    // Periodic VFX
    if (fusionCutsceneTimer % 60 === 0 && fusionCutsceneTimer > 60) {
      bossVfx.push({ type: 'ring', x: centerX, y: centerY, radius: 10, maxRadius: 300, life: 30, maxLife: 30, color: '#ff8844' });
      shakeTimer = 10;
    }
    // Final merge — spawn fusion boss
    if (fusionCutsceneTimer <= 0) {
      screenFlash = 60;
      screenFlashColor = '#ffffff';
      shakeTimer = 50;
      const dmFus = getDiffMult();
      const fusBaseHp = Math.ceil(55 * dmFus.enemyHp);
      fusionBoss = {
        x: centerX - 75, y: centerY - 100,
        w: 150, h: 200,
        hp: fusBaseHp, maxHp: fusBaseHp,
        dir: -1, speed: 3.3 * dmFus.enemySpeed,
        frame: 0, frameTimer: 0,
        dead: false, phase: 1,
        phaseTriggered2: false,
        attackTimer: 0,
        shootCooldown: 30,
        slamCooldown: 200,
        dashCooldown: 150,
        vy: 0,
        charging: false, chargeVx: 0,
        mergeGlow: 1.0,
      };
      if (boss) { boss.x = -9999; boss.dead = true; }
      if (epstein) { epstein.x = -9999; epstein.dead = true; }
      state = 'fusionfight';
      bossIntroTimer = 120; // longer dramatic entrance
      // 40 HP for fusion fight
      player.maxHp = 40;
      player.hp = player.maxHp;
      bossVfx.push({ type: 'ring', x: centerX, y: centerY, radius: 10, maxRadius: 800, life: 60, maxLife: 60, color: '#ff4400' });
      bossVfx.push({ type: 'ring', x: centerX, y: centerY, radius: 10, maxRadius: 600, life: 50, maxLife: 50, color: '#8844ff' });
      bossVfx.push({ type: 'ring', x: centerX, y: centerY, radius: 10, maxRadius: 400, life: 40, maxLife: 40, color: '#ffffff' });
      bossVfx.push({ type: 'text', x: centerX, y: centerY - 130, text: '\u2605 TRUMPSTEIN AWAKENS \u2605', life: 180, maxLife: 180, color: '#ff4444' });
    }
    // Update VFX during fusion cutscene
    if (screenFlash > 0) screenFlash--;
    if (shakeTimer > 0) shakeTimer--;
    for (let i = bossVfx.length - 1; i >= 0; i--) {
      bossVfx[i].life--;
      if (bossVfx[i].type === 'ring') {
        const prog2 = 1 - bossVfx[i].life / bossVfx[i].maxLife;
        bossVfx[i].radius = bossVfx[i].maxRadius * prog2;
      }
      if (bossVfx[i].life <= 0) bossVfx.splice(i, 1);
    }
    particles = particles.filter(pt => { pt.x += pt.vx; pt.y += pt.vy; pt.vy += 0.15; pt.life--; pt.size *= 0.97; return pt.life > 0; });
    return;
  }

  if (state !== 'playing' && state !== 'bossfight' && state !== 'epsteinfight' && state !== 'fusionfight' && state !== 'splitfight' && state !== 'hawkingRefusal' && state !== 'hawkingDeath' && state !== 'winCutscene') return;

  gameTimer++;
  const p = player;

  // Slow passive HP regeneration (1 HP every 10 seconds = 600 frames)
  if (p.alive && p.hp < p.maxHp && gameTimer % 600 === 0) {
    p.hp++;
    spawnParticles(p.x + p.w/2, p.y + p.h/2, hawkingPhase2 ? '#ffd700' : '#44ff88', 3);
  }

  // Input — skip if dead (spectating)
  if (p.alive) {
  const left = keys['ArrowLeft'] || keys['KeyA'] || touchControls.left;
  const right = keys['ArrowRight'] || keys['KeyD'] || touchControls.right;
  const up = keys['ArrowUp'] || keys['KeyW'] || keys['Space'] || touchControls.up;

  // If a touch jump was queued between frames (quick flick), force rising edge
  // so double jumps aren't missed when down→up happens within one frame
  if (touchJumpQueued) p.prevUp = false;

  // After reading touch state, reset for rising edge detection.
  // Reset inJumpUp so holding the stick up doesn't keep triggering jumps,
  // but re-derive continuous 'up' from joystick position for wall climbing.
  moveJoystick.inJumpUp = false;
  touchControls.up = (moveJoystick.active && moveJoystick.dy < MOVE_JUMP_THRESHOLD);
  touchJumpQueued = false;
  if (jumpFlashTimer > 0) jumpFlashTimer--;

  // Horizontal movement
  const pSpeed = cheats.speedBoost ? PLAYER_SPEED * 2 : PLAYER_SPEED;
  if (left) { p.vx = -pSpeed; p.facing = -1; }
  else if (right) { p.vx = pSpeed; p.facing = 1; }
  else { p.vx *= 0.7; }

  // Jump buffer & coyote time — only set on key press (rising edge), not hold
  if (up && !p.prevUp) p.jumpBuffer = 8;
  else if (!up) p.jumpBuffer--;
  p.prevUp = up;

  if (p.onGround) { p.coyoteTime = 6; p.jumpsLeft = p.maxJumps; }
  else p.coyoteTime--;

  // Jump (ground jump or double jump)
  if (p.jumpBuffer > 0) {
    if (p.coyoteTime > 0 || p.onGround) {
      // Normal ground jump
      p.vy = JUMP_FORCE;
      p.jumpBuffer = 0;
      p.coyoteTime = 0;
      p.onGround = false;
      p.jumpsLeft = p.maxJumps - 1;
      jumpFlashTimer = 8;
      spawnParticles(p.x + p.w / 2, p.y + p.h, '#c9a96e', 5);
    } else if ((p.jumpsLeft > 0 || cheats.infiniteJumps) && settings.doubleJump && !p.onGround) {
      // Double jump (air jump) - only when actually airborne
      p.vy = JUMP_FORCE * 0.85;
      p.jumpBuffer = 0;
      jumpFlashTimer = 8;
      if (!cheats.infiniteJumps) p.jumpsLeft = 0; // consume all remaining jumps
      spawnParticles(p.x + p.w / 2, p.y + p.h, '#88ccff', 8);
      // Small visual ring for double jump
      bossVfx.push({ type: 'ring', x: p.x+p.w/2, y: p.y+p.h, radius: 5, maxRadius: 40, life: 15, maxLife: 15, color: '#88ccff' });
    }
  }

  // Wall jump (off small walls — NOT the big wall, which uses climb)
  const _onBigWall = bigWall && state !== 'bossfight' && state !== 'bossdialogue' && rectsOverlap(
    { x: p.x - 4, y: p.y, w: p.w + 8, h: p.h }, bigWall
  );
  if (p.jumpBuffer > 0 && p.onWall && !p.onGround && !_onBigWall) {
    p.vy = JUMP_FORCE * 0.9;
    p.vx = -p.wallDir * 6;
    p.jumpBuffer = 0;
    p.onWall = false;
    spawnParticles(p.x + p.w / 2, p.y + p.h / 2, '#aaa', 4);
  }

  // Climb big wall (disabled during bossfight - player is in arena)
  if (bigWall && p.onWall && state !== 'bossfight' && state !== 'bossdialogue' && rectsOverlap(
    { x: p.x - 4, y: p.y, w: p.w + 8, h: p.h },
    bigWall
  )) {
    p.climbingBigWall = true;
    if (up) {
      p.vy = -WALL_CLIMB_SPEED;
      p.y += p.vy;
      spawnParticles(p.x + p.w / 2, p.y + p.h, '#c9a96e', 1);
    } else {
      p.vy = 0.5; // slide slowly
    }
  } else {
    p.climbingBigWall = false;
  }

  // Gravity
  if (!p.climbingBigWall) {
    p.vy += GRAVITY;
    if (p.onWall && p.vy > 1.5) p.vy = 1.5; // wall slide
  }

  // Move
  p.x += p.vx;
  p.y += p.vy;

  // Collisions
  p.onGround = false;
  p.onWall = false;
  p.wallDir = 0;

  // Ground
  if (p.y + p.h >= GROUND_Y) {
    p.y = GROUND_Y - p.h;
    p.vy = 0;
    p.onGround = true;
  }

  // Walls & platforms (exclude bigWall during bossfight - player is inside arena)
  const inArena = state === 'bossfight' || state === 'bossdialogue' || state === 'cutscene' || state === 'epsteinfight' || state === 'phonecall' || state === 'fusioncutscene' || state === 'fusionfight' || state === 'splitfight' || state === 'hawkingRefusal' || state === 'hawkingDeath';
  const allSolids = [...walls, ...(inArena ? arenaPlats : [bigWall])].filter(Boolean);
  for (const wall of allSolids) {
    if (!rectsOverlap(p, wall)) continue;

    // Resolve collision
    const overlapLeft = (p.x + p.w) - wall.x;
    const overlapRight = (wall.x + wall.w) - p.x;
    const overlapTop = (p.y + p.h) - wall.y;
    const overlapBottom = (wall.y + wall.h) - p.y;

    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

    if (minOverlap === overlapTop && p.vy >= 0) {
      p.y = wall.y - p.h;
      p.vy = 0;
      p.onGround = true;
    } else if (minOverlap === overlapBottom && p.vy < 0 && !wall.isPlatform) {
      p.y = wall.y + wall.h;
      p.vy = 0;
    } else if (minOverlap === overlapLeft && !wall.isPlatform) {
      p.x = wall.x - p.w;
      p.onWall = true;
      p.wallDir = 1;
    } else if (minOverlap === overlapRight && !wall.isPlatform) {
      p.x = wall.x + wall.w;
      p.onWall = true;
      p.wallDir = -1;
    }
  }

  // Trigger cutscene when ANY player reaches top of wall (first time) — HOST ONLY
  if (state === 'playing' && (!mpEnabled || isHost) && bigWall && !boss && !cutscene.active) {
  let anyPlayerAtWall = p.y < bigWall.y + 80 && p.x > bigWall.x - 100 && p.x < bigWall.x + bigWall.w + 100;
  if (!anyPlayerAtWall && mpEnabled) {
    for (const uid of Object.keys(roomPlayers)) {
      if (uid === myUid()) continue;
      const rp = roomPlayers[uid];
      if (rp && rp.y < bigWall.y + 80 && rp.x > bigWall.x - 100 && rp.x < bigWall.x + bigWall.w + 100) {
        anyPlayerAtWall = true; break;
      }
    }
  }
  if (anyPlayerAtWall) {
    state = 'cutscene';
    cutscene.active = true;
    cutscene.timer = 0;
    cutscene.phase = 0;
    cutscene.fadeAlpha = 0;
    cutscene.dialogueIndex = 0;
  }
  }

  // Win condition: player goes over the big wall AND boss is dead
  if (state !== 'winCutscene' && state !== 'won' && bigWall && p.x > bigWall.x + bigWall.w && p.y < bigWall.y + 40 && boss && boss.dead) {
    state = 'winCutscene';
    winCutsceneTimer = 0;
    p.won = true;
    p.alive = true;
    p.hp = p.maxHp;
    p.iFrames = 99999;
    mpSpectating = false;
    spawnParticles(p.x, p.y, '#ffdd44', 40);
    spawnParticles(p.x, p.y, '#ff6644', 30);
    restartCooldown = 60;
  }

  // Bounds
  if (p.x < 0) p.x = 0;

  // Animation
  if (Math.abs(p.vx) > 0.5 && p.onGround) {
    p.runTimer++;
    if (p.runTimer > 6) { p.runTimer = 0; p.runFrame = (p.runFrame + 1) % 4; }
  } else {
    p.runFrame = 0;
  }

  // Trail
  if (Math.abs(p.vx) > 2 || Math.abs(p.vy) > 2) {
    p.trail.push({ x: p.x + p.w / 2, y: p.y + p.h / 2, life: 10 });
  }
  p.trail = p.trail.filter(t => { t.life--; return t.life > 0; });
  } else {
    // Dead/spectating — still consume touch state to prevent stale inputs
    touchControls.up = false;
    touchJumpQueued = false;
    moveJoystick.inJumpUp = false;
  } // end if (p.alive) — player input/physics

  // ── Guards ──
  const _mpHost = !mpEnabled || isHost;
  for (const g of guards) {
    if (g.dead) continue;

    if (_mpHost) {
    // Get nearest player target for this guard (multiplayer-aware)
    const _gTarget = mpEnabled ? getNearestPlayerTarget(g.x + g.w/2, g.y + g.h/2) : p;
    // Check if ANY player is climbing the big wall - guards follow!
    let playerOnWall = _gTarget.climbingBigWall || (bigWall && _gTarget.x >= bigWall.x - 100 && _gTarget.y < bigWall.y + bigWall.h - 100);
    if (!playerOnWall && mpEnabled) {
      for (const _pid in roomPlayers) {
        const _rp = roomPlayers[_pid];
        if (_rp && _rp.alive && (_rp.climbingBigWall || (bigWall && _rp.x >= bigWall.x - 100 && _rp.y < bigWall.y + bigWall.h - 100))) {
          playerOnWall = true; break;
        }
      }
    }

    if (playerOnWall && bigWall && !g.climbing) {
      // Guard runs toward the wall
      if (Math.abs(g.x - bigWall.x) < 60) {
        g.climbing = true;
        g.x = bigWall.x - g.w - 5;
      } else {
        if (g.x < bigWall.x) g.dir = 1;
        else g.dir = -1;
        g.speed = 2.5;
        g.alert = true;
      }
    }

    if (g.climbing && bigWall) {
      // Guard climbs the wall following nearest player
      g.x = bigWall.x - g.w - 5;
      const targetY = Math.min(_gTarget.y + 80, GROUND_Y - g.h);
      if (g.y > targetY) {
        g.y -= 1.6;
      } else if (g.y < targetY - 20) {
        g.y += 0.5;
      }
      g.alert = true;
    } else {
      // Normal patrol
      g.x += g.speed * g.dir;
      if (g.x < g.startX - g.range || g.x > g.startX + g.range) {
        g.dir *= -1;
      }
      g.y = GROUND_Y - g.h;

      // Alert if nearest player nearby
      const dist = Math.abs(_gTarget.x - g.x);
      if (dist < 150) {
        g.alert = true;
        g.alertTimer = 50;
        if (_gTarget.x < g.x) g.dir = -1;
        else g.dir = 1;
        g.speed = 1.8;
      } else {
        if (g.alertTimer > 0) g.alertTimer--;
        else {
          g.alert = false;
          g.speed = 1.0 + Math.random() * 0.3;
        }
      }
    }

    // Animation
    g.frameTimer++;
    if (g.frameTimer > 8) { g.frameTimer = 0; g.frame = (g.frame + 1) % 4; }
    } // end _mpHost guard AI

    // Damage player on touch (with iFrames) — ALL players
    if (p.alive && !p.won && p.iFrames <= 0 && rectsOverlap(p, g)) {
      p.hp--;
      p.iFrames = 40;
      shakeTimer = 10;
      spawnParticles(p.x + p.w / 2, p.y + p.h / 2, '#ff4444', 10);
      if (p.hp <= 0) {
        handlePlayerDeath();
      }
    }
  }

  // Remove dead guards (single-player only — MP preserves array indices for sync)
  if (!mpEnabled) {
    for (let i = guards.length - 1; i >= 0; i--) {
      if (guards[i].dead) guards.splice(i, 1);
    }
  }

  // ── Boss Update ──
  if (boss && !boss.dead) {
   if (_mpHost) {
    const bArenaW = 2400;
    const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
    const arenaRight = arenaLeft + bArenaW;
    const arenaTop = bigWall.y + 40;
    const arenaFloor = arenaTop + 800;
    
    // Phase transitions with mid-fight dialogue
    const hpPct = boss.hp / boss.maxHp;
    if (hpPct <= 0.6 && !boss.phaseTriggered2) {
      boss.phaseTriggered2 = true;
      boss.phase = 2;
      boss.speed = 1.8;
      bossDialogue = { active: true, texts: bossPhaseDialogues[2], index: 0, timer: 0 };
      state = 'bossdialogue';
      shakeTimer = 30;
      screenFlash = 25;
      screenFlashColor = '#ff6600';
      // Explosion ring VFX
      bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h/2, radius: 10, maxRadius: 350, life: 40, maxLife: 40, color: '#ff8800' });
      bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h/2, radius: 10, maxRadius: 250, life: 30, maxLife: 30, color: '#ffcc00' });
      for (let a = 0; a < Math.PI * 2; a += 0.3) {
        spawnParticles(boss.x + boss.w/2 + Math.cos(a)*60, boss.y + boss.h/2 + Math.sin(a)*60, '#ff8800', 3);
      }
      spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ff8800', 40);
      spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ffdd44', 30);
    }
    if (hpPct <= 0.25 && !boss.phaseTriggered3) {
      boss.phaseTriggered3 = true;
      boss.phase = 3;
      boss.speed = 2.5;
      bossDialogue = { active: true, texts: bossPhaseDialogues[3], index: 0, timer: 0 };
      state = 'bossdialogue';
      shakeTimer = 35;
      screenFlash = 30;
      screenFlashColor = '#ff0000';
      // Multiple explosion rings
      bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h/2, radius: 10, maxRadius: 500, life: 50, maxLife: 50, color: '#ff0000' });
      bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h/2, radius: 10, maxRadius: 350, life: 40, maxLife: 40, color: '#ff4400' });
      bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h/2, radius: 10, maxRadius: 200, life: 30, maxLife: 30, color: '#ffcc00' });
      for (let a = 0; a < Math.PI * 2; a += 0.2) {
        spawnParticles(boss.x + boss.w/2 + Math.cos(a)*80, boss.y + boss.h/2 + Math.sin(a)*80, '#ff0000', 4);
      }
      spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ff0000', 50);
      spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ffdd44', 35);
      spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ffffff', 25);
    }

    // Animation
    boss.frameTimer++;
    if (boss.frameTimer > 8) { boss.frameTimer = 0; boss.frame = (boss.frame + 1) % 4; }
    boss.attackTimer++;
    boss.alert = true;

    // Boss gravity
    boss.vy += GRAVITY * 0.8;
    boss.y += boss.vy;
    // Boss arena floor collision
    for (const plat of arenaPlats) {
      if (rectsOverlap(boss, plat) && boss.vy >= 0) {
        const oTop = (boss.y + boss.h) - plat.y;
        if (oTop > 0 && oTop < 40) {
          boss.y = plat.y - boss.h;
          boss.vy = 0;
        }
      }
    }

    // ── Boss Attack Patterns ──
    // Multiplayer: bosses target nearest player
    const bossTarget = mpEnabled ? getNearestPlayerTarget(boss.x + boss.w/2, boss.y + boss.h/2) : p;
    if (!boss.charging && !boss.slamming) {
      // PHASE 1: Shoot + patrol
      if (boss.phase === 1) {
        boss.x += boss.dir * boss.speed;
        if (boss.x < arenaLeft + 30) { boss.x = arenaLeft + 30; boss.dir = 1; }
        if (boss.x + boss.w > arenaRight - 30) { boss.x = arenaRight - boss.w - 30; boss.dir = -1; }
        
        // Aimed shots — slower
        boss.shootCooldown--;
        if (boss.shootCooldown <= 0) {
          boss.shootCooldown = 60 + Math.floor(Math.random() * 40);
          const dx = bossTarget.x + (bossTarget.w||52)/2 - (boss.x + boss.w/2);
          const dy = bossTarget.y + (bossTarget.h||80)/2 - (boss.y + boss.h/2);
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist > 0) {
            bullets.push({ x: boss.x + boss.w/2, y: boss.y + boss.h/3, vx: (dx/dist)*4, vy: (dy/dist)*4, life: 160 });
            spawnParticles(boss.x + boss.w/2, boss.y + boss.h/3, '#ff4444', 4);
          }
        }
      }

      // PHASE 2: Charge attack + spread shots + summon minions
      if (boss.phase === 2) {
        if (bossTarget.x < boss.x) boss.dir = -1; else boss.dir = 1;
        boss.x += boss.dir * boss.speed;
        if (boss.x < arenaLeft + 30) { boss.x = arenaLeft + 30; boss.dir = 1; }
        if (boss.x + boss.w > arenaRight - 30) { boss.x = arenaRight - boss.w - 30; boss.dir = -1; }
        
        // Charge attack every ~180 frames
        if (boss.attackTimer % 180 === 0 && Math.random() < 0.4) {
          boss.charging = true;
          boss.chargeVx = (bossTarget.x < boss.x ? -1 : 1) * 8;
          spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ff8800', 10);
        }
        
        // Spread shot — fewer bullets, slower
        boss.shootCooldown--;
        if (boss.shootCooldown <= 0) {
          boss.shootCooldown = 70 + Math.floor(Math.random() * 30);
          for (let angle = -0.3; angle <= 0.3; angle += 0.3) {
            const baseDir = bossTarget.x < boss.x ? -1 : 1;
            bullets.push({ x: boss.x + boss.w/2, y: boss.y + boss.h/3, vx: baseDir * 4 * Math.cos(angle), vy: 4 * Math.sin(angle), life: 120 });
          }
          spawnParticles(boss.x + boss.w/2, boss.y + boss.h/3, '#ffaa00', 6);
        }
        
        // Summon minions
        boss.summonCooldown--;
        if (boss.summonCooldown <= 0 && bossMinions.length < 2) {
          boss.summonCooldown = 350;
          const spawnX = arenaLeft + 50 + Math.random() * (arenaRight - arenaLeft - 100);
          bossMinions.push({
            x: spawnX, y: arenaFloor - 84, w: 48, h: 72, hp: 2, maxHp: 2, vy: 0,
            dir: Math.random() > 0.5 ? 1 : -1, speed: 1.2 + Math.random() * 0.5,
            frame: 0, frameTimer: 0, dead: false,
            startX: spawnX, range: 160,
          });
          spawnParticles(spawnX, arenaFloor - 40, '#ffdd44', 12);
        }
      }

      // PHASE 3: All attacks + faster + ground slam + more minions
      if (boss.phase === 3) {
        if (bossTarget.x < boss.x) boss.dir = -1; else boss.dir = 1;
        boss.x += boss.dir * boss.speed;
        if (boss.x < arenaLeft + 30) { boss.x = arenaLeft + 30; boss.dir = 1; }
        if (boss.x + boss.w > arenaRight - 30) { boss.x = arenaRight - boss.w - 30; boss.dir = -1; }
        
        // Charge more often
        if (boss.attackTimer % 120 === 0 && Math.random() < 0.5) {
          boss.charging = true;
          boss.chargeVx = (bossTarget.x < boss.x ? -1 : 1) * 10;
          spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, '#ff0000', 12);
        }
        
        // Ground slam
        if (boss.attackTimer % 150 === 0 && !boss.slamming) {
          boss.slamming = true;
          boss.slamTimer = 0;
          boss.vy = -14; // jump up
          spawnParticles(boss.x + boss.w/2, boss.y + boss.h, '#ff4444', 8);
        }
        
        // Rapid fire — still fast but more manageable
        boss.shootCooldown--;
        if (boss.shootCooldown <= 0) {
          boss.shootCooldown = 30 + Math.floor(Math.random() * 20);
          const dx = bossTarget.x + (bossTarget.w||52)/2 - (boss.x + boss.w/2);
          const dy = bossTarget.y + (bossTarget.h||80)/2 - (boss.y + boss.h/2);
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist > 0) {
            bullets.push({ x: boss.x + boss.w/2, y: boss.y + boss.h/3, vx: (dx/dist)*5.5, vy: (dy/dist)*5.5, life: 150 });
          }
          // Extra spread bullets — less frequent
          if (Math.random() < 0.2) {
            for (let a = -0.4; a <= 0.4; a += 0.4) {
              bullets.push({ x: boss.x + boss.w/2, y: boss.y + boss.h/3, vx: boss.dir * 5 * Math.cos(a), vy: 5 * Math.sin(a) - 1, life: 100 });
            }
          }
          spawnParticles(boss.x + boss.w/2, boss.y + boss.h/3, '#ff2222', 4);
        }
        
        // More minions
        boss.summonCooldown--;
        if (boss.summonCooldown <= 0 && bossMinions.length < 3) {
          boss.summonCooldown = 250;
          for (let m = 0; m < 1; m++) {
            const spawnX = arenaLeft + 50 + Math.random() * (arenaRight - arenaLeft - 100);
            bossMinions.push({
              x: spawnX, y: arenaFloor - 84, w: 48, h: 72, hp: 2, maxHp: 2, vy: 0,
              dir: Math.random() > 0.5 ? 1 : -1, speed: 1.5 + Math.random() * 0.5,
              frame: 0, frameTimer: 0, dead: false,
              startX: spawnX, range: 180,
            });
            spawnParticles(spawnX, arenaFloor - 40, '#ff4444', 10);
          }
        }
      }
    }

    // Charge movement
    if (boss.charging) {
      boss.x += boss.chargeVx;
      spawnParticles(boss.x + (boss.chargeVx > 0 ? 0 : boss.w), boss.y + boss.h/2, '#ff880088', 2);
      if (boss.x < arenaLeft + 10 || boss.x + boss.w > arenaRight - 10) {
        boss.charging = false;
        boss.chargeVx = 0;
        shakeTimer = 15;
        screenFlash = 8;
        screenFlashColor = '#ff880088';
        // Wall impact explosion
        const impactX = boss.x < arenaLeft + 50 ? arenaLeft + 20 : arenaRight - 20;
        bossVfx.push({ type: 'ring', x: impactX, y: boss.y + boss.h/2, radius: 5, maxRadius: 120, life: 20, maxLife: 20, color: '#ffaa44' });
        spawnParticles(impactX, boss.y + boss.h/2, '#ffaa44', 25);
        spawnParticles(impactX, boss.y + boss.h/2, '#ffffff', 10);
        // Debris
        for (let d = 0; d < 8; d++) {
          spawnParticles(impactX, boss.y + boss.h * Math.random(), '#999', 2);
        }
      }
    }

    // Slam landing
    if (boss.slamming) {
      boss.slamTimer++;
      // Safety: force-end slam after 90 frames to prevent freeze
      if (boss.slamTimer > 90) {
        boss.slamming = false;
        boss.vy = 0;
        boss.y = arenaFloor - boss.h;
        boss._slamShock = 25;
        shakeTimer = 25;
      }
      else if (boss.vy >= 0 && boss.slamTimer > 10) {
        // Check if landed
        for (const plat of arenaPlats) {
          if (rectsOverlap(boss, plat)) {
            boss.slamming = false;
            shakeTimer = 25;
            screenFlash = 12;
            screenFlashColor = '#ff440088';
            boss._slamShock = 25; // Flag for ALL players to check outside gate
            // Shockwave rings
            bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h, radius: 5, maxRadius: 300, life: 30, maxLife: 30, color: '#ff4400' });
            bossVfx.push({ type: 'ring', x: boss.x + boss.w/2, y: boss.y + boss.h, radius: 5, maxRadius: 200, life: 25, maxLife: 25, color: '#ff8800' });
            // Ground crack lines
            bossVfx.push({ type: 'crack', x: boss.x + boss.w/2, y: boss.y + boss.h, life: 60, maxLife: 60 });
            // Visual shockwave particles - way more
            for (let sx = -shockRange; sx <= shockRange; sx += 12) {
              spawnParticles(boss.x + boss.w/2 + sx, boss.y + boss.h, '#ff8800', 3);
            }
            // Debris flying up
            for (let d = 0; d < 15; d++) {
              particles.push({ x: boss.x + boss.w/2 + (Math.random()-0.5)*shockRange, y: boss.y + boss.h, vx: (Math.random()-0.5)*8, vy: -Math.random()*12-3, life: 40+Math.random()*30, color: '#888', size: 3+Math.random()*4 });
            }
            break;
          }
        }
      }
    }
   } // end _mpHost boss AI

    // Boss slam shockwave damage — ALL players
    if (boss._slamShock > 0) {
      boss._slamShock--;
      if (boss._slamShock > 20) { // Only damage on first few frames
        shakeTimer = Math.max(shakeTimer, boss._slamShock);
        const shockRange2 = 250;
        if (p.alive && Math.abs(p.x - boss.x) < shockRange2 && p.y > boss.y - 50 && p.iFrames <= 0) {
          p.hp -= 1;
          p.iFrames = 30;
          p.vy = -12;
          p.vx = (p.x < boss.x ? -1 : 1) * 8;
          spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4444', 15);
        }
      }
    }

    // Boss contact damage — ALL players (guest uses synced positions)
    if (boss.charging && p.alive && !p.won && p.iFrames <= 0 && rectsOverlap(p, boss)) {
      p.hp -= 1;
      p.iFrames = 60;
      p.vx = (boss.chargeVx || boss.dir * 8) * 0.8;
      p.vy = -8;
      shakeTimer = 12;
      spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4444', 15);
    } else if (!boss.charging && p.alive && !p.won && p.iFrames <= 0 && rectsOverlap(p, boss)) {
      p.hp -= 1;
      p.iFrames = 40;
      p.vx = (p.x < boss.x ? -1 : 1) * 5;
      p.vy = -6;
      shakeTimer = 8;
      spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4444', 10);
    }

    // Boss death check
    if (p.hp <= 0) {
      handlePlayerDeath();
    }
  }

  // ── Boss Minions Update ──
  // Arena floor reference for minion clamping
  const mArenaH = 800;
  const mArenaTopY = bigWall.y + 40;
  const mArenaFloorY = mArenaTopY + mArenaH;
  for (const m of bossMinions) {
    if (m.dead) continue;
    if (_mpHost) {
    // Gravity for minions
    if (m.vy === undefined || m.vy === null) m.vy = 0;
    m.vy += GRAVITY;
    m.y += m.vy;
    // Floor collision for minions — only land on actual floor, not mid-air platforms
    let onPlatform = false;
    let platformY = mArenaFloorY;
    for (const plat of arenaPlats) {
      if (plat.isFloor && rectsOverlap(m, plat) && m.vy >= 0) {
        const oTop = (m.y + m.h) - plat.y;
        if (oTop > 0 && oTop < 50) {
          m.y = plat.y - m.h;
          m.vy = 0;
          onPlatform = true;
        }
      }
    }
    // Hard clamp: never go below arena floor or above ceiling
    if (m.y + m.h > mArenaFloorY) { m.y = mArenaFloorY - m.h; m.vy = 0; }
    if (m.y < mArenaTopY + 20) { m.y = mArenaTopY + 20; if (m.vy < 0) m.vy = 0; }
    // Always chase player actively
    const mTarget = mpEnabled ? getNearestPlayerTarget(m.x + m.w/2, m.y + m.h/2) : p;
    const mDist = Math.abs(mTarget.x - m.x);
    m.dir = mTarget.x < m.x ? -1 : 1;
    if (mDist < 250) {
      m.speed = 2.2; // sprint when close
    } else {
      m.speed = 1.5; // jog toward player from far
    }
    m.x += m.speed * m.dir;
    // Clamp to arena bounds
    const mArenaW = 2400;
    const mArenaLeft = bigWall.x + bigWall.w/2 - mArenaW/2;
    const mArenaRight = mArenaLeft + mArenaW;
    if (m.x < mArenaLeft + 20) m.x = mArenaLeft + 20;
    if (m.x + m.w > mArenaRight - 20) m.x = mArenaRight - m.w - 20;
    m.frameTimer++;
    if (m.frameTimer > 8) { m.frameTimer = 0; m.frame = (m.frame + 1) % 4; }
    } // end _mpHost boss minion AI
    // Damage player — ALL players
    if (p.alive && !p.won && p.iFrames <= 0 && rectsOverlap(p, m)) {
      p.hp--;
      p.iFrames = 35;
      shakeTimer = 6;
      spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4444', 8);
      if (p.hp <= 0) {
        handlePlayerDeath();
      }
    }
  }
  // Remove dead minions (single-player only — MP preserves indices for sync)
  if (!mpEnabled) {
    for (let i = bossMinions.length - 1; i >= 0; i--) {
      if (bossMinions[i].dead) bossMinions.splice(i, 1);
    }
  }

  // ── Projectiles (player throws) ──
  if (p.throwCooldown > 0) p.throwCooldown--;
  if (p.iFrames > 0 && p.alive) p.iFrames--;

  // Auto-fire while touch aim joystick is active
  if (touchAim.active && p.throwCooldown <= 0 && p.alive) {
    throwProjectile();
  }

  for (let i = projectiles.length - 1; i >= 0; i--) {
    const proj = projectiles[i];
    if (!proj) continue;
    proj.x += proj.vx;
    proj.y += proj.vy;
    proj.vy += 0.12;
    proj.life--;

    // Hit guards
    let hit = false;
    // ── GUEST: simplified collision (VFX + send damage to host) ──
    if (mpEnabled && !isHost) {
      for (let gi = 0; gi < guards.length; gi++) {
        const gg = guards[gi];
        if (gg.dead) continue;
        if (rectsOverlap(proj, gg)) {
          spawnParticles(gg.x + gg.w/2, gg.y + gg.h/3, '#ffaa00', 8);
          shakeTimer = 5;
          mpSendDamage('guard', gi, 1);
          hit = true; break;
        }
      }
      if (!hit && boss && !boss.dead && rectsOverlap(proj, boss)) {
        spawnParticles(boss.x + boss.w/2, boss.y + boss.h/3, '#ff6600', 12);
        shakeTimer = 8;
        mpSendDamage('boss', 0, 1);
        hit = true;
      }
      if (!hit && epstein && !epstein.dead && rectsOverlap(proj, epstein)) {
        spawnParticles(epstein.x + epstein.w/2, epstein.y + epstein.h/3, '#8844ff', 12);
        shakeTimer = 8;
        mpSendDamage('epstein', 0, 1);
        hit = true;
      }
      if (!hit && fusionBoss && !fusionBoss.dead && rectsOverlap(proj, fusionBoss)) {
        spawnParticles(fusionBoss.x + fusionBoss.w/2, fusionBoss.y + fusionBoss.h/3, '#ff8844', 12);
        shakeTimer = 8;
        mpSendDamage('fusion', 0, 1);
        hit = true;
      }
      if (!hit && miniBosses.length > 0) {
        for (let mi = 0; mi < miniBosses.length; mi++) {
          const mmb = miniBosses[mi];
          if (mmb.dead) continue;
          if (mmb.name === 'HAWKING' && state === 'hawkingDeath') continue;
          if (rectsOverlap(proj, mmb)) {
            spawnParticles(mmb.x + mmb.w/2, mmb.y + mmb.h/3, mmb.color, 10);
            shakeTimer = 6;
            mpSendDamage('mini', mi, 1);
            hit = true; break;
          }
        }
      }
      if (!hit) {
        for (let bi = 0; bi < bossMinions.length; bi++) {
          const bm2 = bossMinions[bi];
          if (bm2.dead) continue;
          if (rectsOverlap(proj, bm2)) {
            spawnParticles(bm2.x + bm2.w/2, bm2.y + bm2.h/3, '#ffaa00', 8);
            shakeTimer = 4;
            mpSendDamage('bossMinion', bi, 1);
            hit = true; break;
          }
        }
      }
      if (hit || proj.life <= 0) { projectiles.splice(i, 1); }
      continue;
    }
    // ── HOST/SINGLE-PLAYER: full collision + damage + death handling ──
    for (const g of guards) {
      if (g.dead) continue;
      if (rectsOverlap(proj, g)) {
        g.hp = cheats.oneHitKill ? 0 : g.hp - 1;
        spawnParticles(g.x + g.w / 2, g.y + g.h / 3, '#ffaa00', 8);
        shakeTimer = 5;
        if (g.hp <= 0) {
          g.dead = true;
          spawnParticles(g.x + g.w / 2, g.y + g.h / 2, '#ff4444', 15);
        }
        hit = true;
        break;
      }
    }
    // Hit boss
    if (!hit && boss && !boss.dead && rectsOverlap(proj, boss)) {
      boss.hp = cheats.oneHitKill ? 0 : boss.hp - 1;
      spawnParticles(boss.x + boss.w / 2, boss.y + boss.h / 3, '#ff6600', 12);
      shakeTimer = 8;
      if (boss.hp <= 0) {
        boss.dead = true;
        bossDeathTimer = 180;
        bossMinions = [];
        bullets = [];
        shakeTimer = 60;
        screenFlash = 40;
        screenFlashColor = '#ffffff';
        for (let wave = 0; wave < 5; wave++) {
          const ox = (Math.random()-0.5) * boss.w;
          const oy = (Math.random()-0.5) * boss.h;
          spawnParticles(boss.x + boss.w/2 + ox, boss.y + boss.h/2 + oy, '#ff4444', 20);
          spawnParticles(boss.x + boss.w/2 + ox, boss.y + boss.h/2 + oy, '#ffdd44', 15);
        }
        bossVfx.push({ type: 'ring', x: boss.x+boss.w/2, y: boss.y+boss.h/2, radius: 10, maxRadius: 600, life: 60, maxLife: 60, color: '#ff4400' });
        bossVfx.push({ type: 'ring', x: boss.x+boss.w/2, y: boss.y+boss.h/2, radius: 10, maxRadius: 400, life: 50, maxLife: 50, color: '#ffcc00' });
      }
      hit = true;
    }
    // Hit epstein boss
    if (!hit && epstein && !epstein.dead && rectsOverlap(proj, epstein)) {
      epstein.hp = cheats.oneHitKill ? 0 : epstein.hp - 1;
      spawnParticles(epstein.x + epstein.w/2, epstein.y + epstein.h/3, '#8844ff', 12);
      shakeTimer = 8;
      if (epstein.hp <= 0) {
        epstein.dead = true;
        bossDeathTimer = 200;
        bullets = [];
        epsteinProjectiles = [];
        shakeTimer = 60;
        screenFlash = 50;
        screenFlashColor = '#ffffff';
        for (let wave = 0; wave < 8; wave++) {
          const ox = (Math.random()-0.5) * epstein.w * 2;
          const oy = (Math.random()-0.5) * epstein.h * 2;
          spawnParticles(epstein.x + epstein.w/2 + ox, epstein.y + epstein.h/2 + oy, '#8844ff', 20);
          spawnParticles(epstein.x + epstein.w/2 + ox, epstein.y + epstein.h/2 + oy, '#ffdd44', 15);
          spawnParticles(epstein.x + epstein.w/2 + ox, epstein.y + epstein.h/2 + oy, '#ffffff', 10);
        }
        bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 700, life: 60, maxLife: 60, color: '#8844ff' });
        bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 500, life: 50, maxLife: 50, color: '#ffcc00' });
        bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 300, life: 40, maxLife: 40, color: '#ffffff' });
        bossVfx.push({ type: 'text', x: epstein.x+epstein.w/2, y: epstein.y - 20, text: 'EXPOSED!', life: 150, maxLife: 150, color: '#ffdd44' });
      }
      hit = true;
    }
    // Hit fusion boss
    if (!hit && fusionBoss && !fusionBoss.dead && rectsOverlap(proj, fusionBoss)) {
      fusionBoss.hp = cheats.oneHitKill ? 0 : fusionBoss.hp - 1;
      spawnParticles(fusionBoss.x + fusionBoss.w/2, fusionBoss.y + fusionBoss.h/3, '#ff8844', 12);
      shakeTimer = 8;
      if (fusionBoss.hp <= 0) {
        fusionBoss.dead = true;
        bossDeathTimer = 200;
        bullets = [];
        epsteinProjectiles = [];
        shakeTimer = 60;
        screenFlash = 60;
        screenFlashColor = '#ffffff';
        for (let wave = 0; wave < 10; wave++) {
          const ox = (Math.random()-0.5) * fusionBoss.w * 2;
          const oy = (Math.random()-0.5) * fusionBoss.h * 2;
          spawnParticles(fusionBoss.x + fusionBoss.w/2 + ox, fusionBoss.y + fusionBoss.h/2 + oy, '#ff4400', 20);
          spawnParticles(fusionBoss.x + fusionBoss.w/2 + ox, fusionBoss.y + fusionBoss.h/2 + oy, '#8844ff', 15);
          spawnParticles(fusionBoss.x + fusionBoss.w/2 + ox, fusionBoss.y + fusionBoss.h/2 + oy, '#ffffff', 10);
        }
        bossVfx.push({ type: 'ring', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y+fusionBoss.h/2, radius: 10, maxRadius: 800, life: 60, maxLife: 60, color: '#ff4400' });
        bossVfx.push({ type: 'ring', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y+fusionBoss.h/2, radius: 10, maxRadius: 600, life: 50, maxLife: 50, color: '#8844ff' });
        bossVfx.push({ type: 'ring', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y+fusionBoss.h/2, radius: 10, maxRadius: 400, life: 40, maxLife: 40, color: '#ffffff' });
        bossVfx.push({ type: 'text', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y - 30, text: 'UNFUSED!', life: 180, maxLife: 180, color: '#ffdd44' });
      }
      hit = true;
    }
    // Hit mini-bosses
    if (!hit && miniBosses.length > 0) {
      for (const mb of miniBosses) {
        if (mb.dead) continue;
        // Skip all collision with Hawking during his death scene
        if (mb.name === 'HAWKING' && state === 'hawkingDeath') continue;
        if (rectsOverlap(proj, mb)) {
          // Hawking is invulnerable until other 4 are dead
          const othersAlive = miniBosses.filter(m => !m.dead && m.name !== 'HAWKING').length;
          if (mb.name === 'HAWKING' && othersAlive > 0) {
            // Deflect! Shield flash (gold if phase 2)
            const shieldCol = hawkingPhase2 ? '#ffd700' : '#44ff88';
            spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, shieldCol, 6);
            bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 20, text: 'SHIELDED', life: 40, maxLife: 40, color: shieldCol });
            hit = true;
            break;
          }
          mb.hp = cheats.oneHitKill ? 0 : mb.hp - 1;
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, mb.color, 10);
          shakeTimer = 6;
          if (mb.hp <= 0) {
            // Hawking first death — trigger Undertale refusal cutscene
            if (mb.name === 'HAWKING' && !hawkingPhase2) {
              mb.hp = 1; // keep alive temporarily
              hawkingRefusalTimer = 0;
              hawkingRefusalPhase = 0;
              // Save Hawking's position for later
              mb._savedX = mb.x;
              mb._savedY = mb.y;
              state = 'hawkingRefusal';
              epsteinProjectiles = [];
              bossMinions = [];
              bossVfx = [];
              screenFlash = 40;
              screenFlashColor = '#44ff88';
              shakeTimer = 30;
              spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#44ff88', 40);
              hit = true;
              break;
            }
            // Hawking FINAL death — trigger epic death scene
            if (mb.name === 'HAWKING' && hawkingPhase2) {
              mb.hp = 1; // keep alive for cutscene
              hawkingDeathTimer = 0;
              hawkingDeathPhase = 0;
              mb._deathX = mb.x + mb.w/2;
              mb._deathY = mb.y + mb.h/2;
              state = 'hawkingDeath';
              projectiles = [];
              epsteinProjectiles = [];
              bossMinions = [];
              bossVfx = [];
              screenFlash = 60;
              screenFlashColor = '#ffd700';
              shakeTimer = 40;
              spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffd700', 60);
              spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffffff', 40);
              hit = true;
              break;
            }
            mb.dead = true;
            spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, mb.color, 25);
            spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffffff', 15);
            bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 250, life: 30, maxLife: 30, color: mb.color });
            bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 20, text: mb.name + ' DOWN!', life: 120, maxLife: 120, color: mb.color });
            screenFlash = 15;
            screenFlashColor = mb.color;
            // When Hawking becomes vulnerable, announce it
            const nowOthersAlive = miniBosses.filter(m => !m.dead && m.name !== 'HAWKING').length;
            if (nowOthersAlive === 0) {
              const hawk = miniBosses.find(m => m.name === 'HAWKING' && !m.dead);
              if (hawk) {
                const hawkCol = hawkingPhase2 ? '#ffd700' : '#44ff88';
                bossVfx.push({ type: 'text', x: hawk.x+hawk.w/2, y: hawk.y - 40, text: 'NOW IT\'S JUST US.', life: 180, maxLife: 180, color: hawkCol });
                bossVfx.push({ type: 'ring', x: hawk.x+hawk.w/2, y: hawk.y+hawk.h/2, radius: 10, maxRadius: 500, life: 50, maxLife: 50, color: hawkCol });
                screenFlash = 30;
                screenFlashColor = hawkCol;
                shakeTimer = 20;
              }
            }
          }
          hit = true;
          break;
        }
      }
    }
    // Hit boss minions
    if (!hit) {
      for (const m of bossMinions) {
        if (m.dead) continue;
        if (rectsOverlap(proj, m)) {
          m.hp = cheats.oneHitKill ? 0 : m.hp - 1;
          spawnParticles(m.x + m.w/2, m.y + m.h/3, '#ffaa00', 8);
          shakeTimer = 4;
          if (m.hp <= 0) {
            m.dead = true;
            spawnParticles(m.x + m.w/2, m.y + m.h/2, '#ff4444', 12);
          }
          hit = true;
          break;
        }
      }
    }
    if (hit || proj.life <= 0) {
      projectiles.splice(i, 1);
    }
  }

  // ── Bullets (guards shoot) ──
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;
    b.life--;

    // Hit player
    if (p.iFrames <= 0 && p.alive && !p.won && rectsOverlap({ x: b.x - 5, y: b.y - 5, w: 10, h: 10 }, p)) {
      p.hp--;
      p.iFrames = 40;
      shakeTimer = 8;
      spawnParticles(p.x + p.w / 2, p.y + p.h / 2, '#ff4444', 8);
      bullets.splice(i, 1);
      if (p.hp <= 0) {
        handlePlayerDeath();
      }
      continue;
    }

    if (b.life <= 0) {
      bullets.splice(i, 1);
    }
  }

  // Camera
  let targetCamX = p.x - W / 3;
  
  // In arena: track between player and active boss so boss stays on screen
  const inArenaState = state === 'bossfight' || state === 'bossdialogue' || state === 'epsteinfight' || state === 'phonecall' || state === 'cutscene' || state === 'fusioncutscene' || state === 'fusionfight' || state === 'splitfight' || state === 'hawkingRefusal' || state === 'hawkingDeath';
  if (inArenaState && bigWall) {
    const bArenaW = 2400;
    const arenaLeftCam = bigWall.x + bigWall.w/2 - bArenaW/2;
    const arenaRightCam = arenaLeftCam + bArenaW;
    
    // Find active boss position
    let bossX = null;
    if (boss && !boss.dead) bossX = boss.x + boss.w/2;
    else if (epstein && !epstein.dead) bossX = epstein.x + epstein.w/2;
    else if (fusionBoss && !fusionBoss.dead) bossX = fusionBoss.x + fusionBoss.w/2;
    else if (miniBosses.length > 0) {
      let sumX = 0, count = 0;
      for (const mb of miniBosses) { if (!mb.dead) { sumX += mb.x + mb.w/2; count++; } }
      if (count > 0) bossX = sumX / count;
    }
    
    if (bossX !== null) {
      // Camera centers between player and boss
      const midX = p.x * 0.5 + bossX * 0.5;
      targetCamX = midX - W / 2;
    } else {
      // No boss — center on player
      targetCamX = p.x + p.w/2 - W / 2;
    }
    
    // Hard clamp to arena edges
    if (targetCamX < arenaLeftCam - 30) targetCamX = arenaLeftCam - 30;
    if (targetCamX + W > arenaRightCam + 30) targetCamX = arenaRightCam + 30 - W;
  }
  
  // Faster lerp in arena for responsive tracking
  const camSpeed = inArenaState ? 0.15 : 0.1;
  
  // Spectator camera — follow spectated player
  if (mpSpectating && mpSpectateTarget && roomPlayers[mpSpectateTarget]) {
    const sp = roomPlayers[mpSpectateTarget];
    // Check if target is still alive
    if (!sp.alive || sp.hp <= 0) {
      // Find next alive player
      const alive = getAlivePlayerList();
      if (alive.length > 0) {
        mpSpectateIndex = mpSpectateIndex % alive.length;
        mpSpectateTarget = alive[mpSpectateIndex].uid;
      } else {
        // All players dead
        mpSpectating = false;
        state = 'dead';
      }
    }
    if (mpSpectating && roomPlayers[mpSpectateTarget]) {
      const sp2 = roomPlayers[mpSpectateTarget];
      targetCamX = sp2.x + 26 - W / 2;
      if (inArenaState) {
        const targetCamY2 = sp2.y - H * 0.5 + 40;
        cameraY += (targetCamY2 - cameraY) * 0.12;
      }
    }
  }
  
  cameraX += (targetCamX - cameraX) * camSpeed;
  if (cameraX < 0) cameraX = 0;
  if (cameraX > levelWidth - W) cameraX = levelWidth - W;

  // Vertical camera - follows player upward when climbing
  if (inArenaState) {
    // In arena — camera follows player vertically (arena is underground)
    const arenaCenter = bigWall ? bigWall.y + 40 + 400 : GROUND_Y;
    const targetCamY = p.y - H * 0.5 + p.h/2;
    cameraY += (targetCamY - cameraY) * 0.12;
  } else if (p.climbingBigWall || p.y < GROUND_Y - p.h - 50) {
    // Camera needs to go NEGATIVE to shift world DOWN (so we see upward)
    const comfortY = GROUND_Y - H * 0.6;
    const targetCamY = Math.min(0, p.y - comfortY);
    cameraY += (targetCamY - cameraY) * 0.1;
  } else {
    // Player on ground - smoothly return camera to 0
    cameraY += (0 - cameraY) * 0.08;
  }
  // Clamp: don't look below ground (only when not in arena)
  if (!inArenaState && cameraY > 0) cameraY = 0;

  // ── VFX Updates ──
  if (screenFlash > 0) screenFlash--;
  if (bossIntroTimer > 0) {
    bossIntroTimer--;
    // When cutscene ends, spread mini-bosses FAR from the player so you don't insta-die
    if (bossIntroTimer === 0 && state === 'splitfight' && miniBosses.length > 0) {
      const bArenaW = 2400;
      const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
      const arenaFloor = bigWall.y + 40 + 800;
      // Place player at center-left of arena
      player.x = arenaLeft + bArenaW * 0.15;
      player.y = arenaFloor - player.h - 10;
      player.vy = 0;
      // Spread bosses to the RIGHT side of the arena, far from player
      const spawnPositions = [
        { x: arenaLeft + bArenaW * 0.55, y: arenaFloor - 110 }, // Trump - mid
        { x: arenaLeft + bArenaW * 0.65, y: arenaFloor - 110 }, // Epstein - mid-right
        { x: arenaLeft + bArenaW * 0.75, y: arenaFloor - 110 }, // Musk - right
        { x: arenaLeft + bArenaW * 0.85, y: arenaFloor - 110 }, // Clinton - far right
        { x: arenaLeft + bArenaW * 0.70, y: arenaFloor - 280 }, // Hawking - elevated center-right
      ];
      for (let i = 0; i < miniBosses.length; i++) {
        const mb = miniBosses[i];
        if (mb.dead) continue;
        const sp = spawnPositions[i] || spawnPositions[0];
        mb.x = sp.x - mb.w/2;
        mb.y = sp.y;
        mb.vy = 0;
        mb.vx = 0;
        mb.dir = -1; // face toward player
        mb.shootCooldown = 60 + i * 15; // stagger first attacks
        mb.attackTimer = 0;
        mb.specialTimer = 0;
      }
      // Brief dramatic flash + text
      screenFlash = 30;
      screenFlashColor = '#ffffff';
      shakeTimer = 20;
      bossVfx.push({ type: 'text', x: player.x + player.w/2 + 400, y: player.y - 60, text: '⚔ FIGHT! ⚔', life: 120, maxLife: 120, color: '#ffdd44', size: 48, vy: -0.3 });
    }
  }
  
  // Boss death sequence - triggers phone call to Epstein
  if (bossDeathTimer > 0 && boss && boss.dead && !epstein) {
    bossDeathTimer--;
    // Repeated explosions during death
    if (bossDeathTimer % 12 === 0 && bossDeathTimer > 30) {
      const ox = (Math.random()-0.5) * 200;
      const oy = (Math.random()-0.5) * 200;
      spawnParticles(boss.x + boss.w/2 + ox, boss.y + boss.h/2 + oy, '#ff' + ['4444','8800','cc00','dd44','ffff'][Math.floor(Math.random()*5)], 15);
      shakeTimer = Math.max(shakeTimer, 8);
      if (bossDeathTimer % 36 === 0) {
        bossVfx.push({ type: 'ring', x: boss.x+boss.w/2+ox, y: boss.y+boss.h/2+oy, radius: 5, maxRadius: 200, life: 25, maxLife: 25, color: '#ff8800' });
      }
    }
    // Trump falls, then makes phone call
    if (bossDeathTimer === 30) {
      screenFlash = 30;
      screenFlashColor = '#ffffff';
      shakeTimer = 20;
      bossVfx.push({ type: 'text', x: boss.x+boss.w/2, y: boss.y - 20, text: 'Wait... one call...', life: 150, maxLife: 150, color: '#ff8844' });
      // Start phone call cutscene
      phonecallTimer = 300; // 5 seconds of phone call
      state = 'phonecall';
      bossDialogue = { active: true, texts: epsteinDialogues, index: 0, timer: 0 };
    }
  }

  // ── Epstein Boss Update ──
  if (epstein && !epstein.dead && state === 'epsteinfight') {
   if (_mpHost) {
    const bArenaW3 = 2400;
    const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW3/2;
    const arenaRight = arenaLeft + bArenaW3;
    const arenaTop = bigWall.y + 40;
    const arenaFloor = arenaTop + 800;

    // Phase transition
    const eHpPct = epstein.hp / epstein.maxHp;
    if (eHpPct <= 0.4 && !epstein.phaseTriggered2) {
      epstein.phaseTriggered2 = true;
      epstein.phase = 2;
      epstein.speed = 3.5;
      bossDialogue = { active: true, texts: epsteinPhaseDialogues[2], index: 0, timer: 0 };
      state = 'bossdialogue';
      shakeTimer = 25;
      screenFlash = 20;
      screenFlashColor = '#8844ff';
      bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 10, maxRadius: 400, life: 40, maxLife: 40, color: '#8844ff' });
    }

    epstein.frameTimer++;
    if (epstein.frameTimer > 7) { epstein.frameTimer = 0; epstein.frame = (epstein.frame + 1) % 4; }
    epstein.attackTimer++;

    // Gravity
    epstein.vy += GRAVITY * 0.8;
    epstein.y += epstein.vy;
    for (const plat of arenaPlats) {
      if (rectsOverlap(epstein, plat) && epstein.vy >= 0) {
        const oTop = (epstein.y + epstein.h) - plat.y;
        if (oTop > 0 && oTop < 40) {
          epstein.y = plat.y - epstein.h;
          epstein.vy = 0;
        }
      }
    }

    // Movement — chase player
    const epTarget = mpEnabled ? getNearestPlayerTarget(epstein.x + epstein.w/2, epstein.y + epstein.h/2) : p;
    if (epTarget.x < epstein.x) epstein.dir = -1; else epstein.dir = 1;
    if (!epstein.charging) {
      epstein.x += epstein.dir * epstein.speed;
      if (epstein.x < arenaLeft + 30) epstein.x = arenaLeft + 30;
      if (epstein.x + epstein.w > arenaRight - 30) epstein.x = arenaRight - epstein.w - 30;
    }

    // Attack: Throw files (image projectiles) — BIGGER projectiles
    epstein.shootCooldown--;
    if (epstein.shootCooldown <= 0) {
      epstein.shootCooldown = epstein.phase === 2 ? 25 + Math.floor(Math.random()*20) : 45 + Math.floor(Math.random()*25);
      const dx = epTarget.x + (epTarget.w||52)/2 - (epstein.x + epstein.w/2);
      const dy = epTarget.y + (epTarget.h||80)/2 - (epstein.y + epstein.h/2);
      const dist = Math.sqrt(dx*dx + dy*dy) || 1;
      epsteinProjectiles.push({
        x: epstein.x + epstein.w/2, y: epstein.y + epstein.h/3,
        vx: (dx/dist) * 5, vy: (dy/dist) * 5,
        life: 180, rotation: 0, size: 50 + Math.random()*20,
        imgIdx: Math.floor(Math.random() * 5),
      });
      spawnParticles(epstein.x + epstein.w/2, epstein.y + epstein.h/3, '#8844ff', 5);
      // Phase 2: throw spread
      if (epstein.phase === 2 && Math.random() < 0.3) {
        for (let a = -0.3; a <= 0.3; a += 0.3) {
          epsteinProjectiles.push({
            x: epstein.x + epstein.w/2, y: epstein.y + epstein.h/3,
            vx: epstein.dir * 5 * Math.cos(a), vy: 5 * Math.sin(a),
            life: 150, rotation: Math.random()*Math.PI*2, size: 45 + Math.random()*15,
            imgIdx: Math.floor(Math.random() * 5),
          });
        }
      }
    }

    // Epstein summons minions periodically
    if (!epstein.summonCooldown) epstein.summonCooldown = 400;
    epstein.summonCooldown--;
    if (epstein.summonCooldown <= 0) {
      epstein.summonCooldown = epstein.phase === 2 ? 300 : 500;
      // Spawn 1-2 minions
      const mCount = epstein.phase === 2 ? 2 : 1;
      // Limit to max 3 epstein minions alive
      const aliveMinions = bossMinions.filter(m => !m.dead).length;
      if (aliveMinions < 3) {
        for (let mi = 0; mi < mCount && (aliveMinions + mi) < 3; mi++) {
          const spawnX = epstein.x + (mi === 0 ? -80 : 80 + epstein.w);
          const spawnY = epstein.y + epstein.h - 60;
          bossMinions.push({
            x: Math.max(arenaLeft + 30, Math.min(arenaRight - 60, spawnX)),
            y: spawnY,
            w: 40, h: 60,
            hp: 2, maxHp: 2,
            dir: Math.random() > 0.5 ? 1 : -1,
            speed: 2 + Math.random(),
            frame: 0, frameTimer: 0,
            dead: false, vy: -4,
            isEpstein: true,
          });
          spawnParticles(spawnX, spawnY, '#8844ff', 10);
          bossVfx.push({ type: 'ring', x: spawnX, y: spawnY, radius: 5, maxRadius: 60, life: 15, maxLife: 15, color: '#ff44ff' });
        }
        // Announce
        bossVfx.push({ type: 'text', x: epstein.x+epstein.w/2, y: epstein.y - 50, text: 'COME, MY MINIONS!', life: 60, maxLife: 60, color: '#ff44ff' });
      }
    }

    // Teleport dash (phase 2)
    if (epstein.phase === 2) {
      epstein.teleportCooldown--;
      if (epstein.teleportCooldown <= 0) {
        epstein.teleportCooldown = 150 + Math.floor(Math.random()*100);
        // Teleport behind player
        spawnParticles(epstein.x + epstein.w/2, epstein.y + epstein.h/2, '#8844ff', 20);
        bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 5, maxRadius: 100, life: 15, maxLife: 15, color: '#8844ff' });
        epstein.x = epTarget.x + (Math.random() > 0.5 ? 150 : -150);
        epstein.x = Math.max(arenaLeft + 40, Math.min(arenaRight - epstein.w - 40, epstein.x));
        spawnParticles(epstein.x + epstein.w/2, epstein.y + epstein.h/2, '#ff44ff', 20);
        bossVfx.push({ type: 'ring', x: epstein.x+epstein.w/2, y: epstein.y+epstein.h/2, radius: 5, maxRadius: 120, life: 15, maxLife: 15, color: '#ff44ff' });
        screenFlash = 5;
        screenFlashColor = '#8844ff44';
      }
    }

   } // end _mpHost epstein AI

    // Contact damage — ALL players
    if (p.alive && !p.won && p.iFrames <= 0 && rectsOverlap(p, epstein)) {
      p.hp -= 1;
      p.iFrames = 45;
      p.vx = (p.x < epstein.x ? -1 : 1) * 6;
      p.vy = -7;
      shakeTimer = 8;
      spawnParticles(p.x + p.w/2, p.y + p.h/2, '#8844ff', 10);
    }

    if (p.hp <= 0) {
      handlePlayerDeath();
    }
  }

  // Epstein projectile update
  for (let i = epsteinProjectiles.length - 1; i >= 0; i--) {
    const ep = epsteinProjectiles[i];
    ep.x += ep.vx;
    ep.y += ep.vy;
    ep.rotation += 0.1;
    ep.life--;
    // Hit player
    if (p.iFrames <= 0 && p.alive && rectsOverlap({ x: ep.x - ep.size/2, y: ep.y - ep.size/2, w: ep.size, h: ep.size }, p)) {
      p.hp--;
      p.iFrames = 40;
      shakeTimer = 8;
      spawnParticles(p.x + p.w/2, p.y + p.h/2, '#8844ff', 8);
      epsteinProjectiles.splice(i, 1);
      if (p.hp <= 0) {
        handlePlayerDeath();
      }
      continue;
    }
    if (ep.life <= 0) epsteinProjectiles.splice(i, 1);
  }

  // Epstein death → triggers FUSION CUTSCENE
  if (bossDeathTimer > 0 && epstein && epstein.dead && !fusionBoss) {
    bossDeathTimer--;
    if (bossDeathTimer % 10 === 0 && bossDeathTimer > 40) {
      const ox = (Math.random()-0.5) * 250;
      const oy = (Math.random()-0.5) * 250;
      spawnParticles(epstein.x + epstein.w/2 + ox, epstein.y + epstein.h/2 + oy, ['#8844ff','#ff44ff','#ffdd44','#ffffff'][Math.floor(Math.random()*4)], 18);
      shakeTimer = Math.max(shakeTimer, 10);
    }
    if (bossDeathTimer === 40) {
      screenFlash = 50;
      screenFlashColor = '#ffffff';
      shakeTimer = 40;
      // Start fusion cutscene instead of victory
      fusionCutsceneTimer = 360; // 6 seconds
      state = 'fusioncutscene';
      bossVfx.push({ type: 'text', x: epstein.x+epstein.w/2, y: epstein.y - 30, text: 'WAIT... WHAT?!', life: 150, maxLife: 150, color: '#ff4444' });
    }
  }

  // ── FUSION BOSS UPDATE ──
  if (fusionBoss && !fusionBoss.dead && state === 'fusionfight') {
   if (_mpHost) {
    const bArenaW = 2400;
    const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
    const arenaRight = arenaLeft + bArenaW;
    const arenaTop = bigWall.y + 40;
    const arenaFloor = arenaTop + 800;
    const fb = fusionBoss;

    // Phase transition
    const fHpPct = fb.hp / fb.maxHp;
    if (fHpPct <= 0.4 && !fb.phaseTriggered2) {
      fb.phaseTriggered2 = true;
      fb.phase = 2;
      fb.speed = 4;
      shakeTimer = 30;
      screenFlash = 25;
      screenFlashColor = '#ff440088';
      bossVfx.push({ type: 'ring', x: fb.x+fb.w/2, y: fb.y+fb.h/2, radius: 10, maxRadius: 500, life: 40, maxLife: 40, color: '#ff4400' });
      bossVfx.push({ type: 'text', x: fb.x+fb.w/2, y: fb.y - 30, text: 'FULL POWER!', life: 120, maxLife: 120, color: '#ff2222' });
      bossDialogue = { active: true, texts: ['You think you\'ve won?!', 'WE ARE ONE NOW!', 'This isn\'t even our final form... wait, yes it is.', 'PREPARE TO BE DEPORTED TO THE SHADOW REALM!'], index: 0, timer: 0 };
      state = 'bossdialogue';
    }

    fb.frameTimer++;
    if (fb.frameTimer > 6) { fb.frameTimer = 0; fb.frame = (fb.frame + 1) % 4; }
    fb.attackTimer++;

    // Merge glow fades
    if (fb.mergeGlow > 0) fb.mergeGlow -= 0.005;

    // Gravity
    fb.vy += GRAVITY * 0.7;
    fb.y += fb.vy;
    for (const plat of arenaPlats) {
      if (rectsOverlap(fb, plat) && fb.vy >= 0) {
        const oTop = (fb.y + fb.h) - plat.y;
        if (oTop > 0 && oTop < 40) {
          fb.y = plat.y - fb.h;
          fb.vy = 0;
        }
      }
    }

    // Clamp fusion boss to arena bounds (prevent escaping above)
    if (fb.y < arenaTop) { fb.y = arenaTop; fb.vy = 0; }
    if (fb.y + fb.h > arenaFloor) { fb.y = arenaFloor - fb.h; fb.vy = 0; }

    // Chase player
    const fbTarget = mpEnabled ? getNearestPlayerTarget(fb.x + fb.w/2, fb.y + fb.h/2) : p;
    if (fbTarget.x < fb.x) fb.dir = -1; else fb.dir = 1;
    if (!fb.charging) {
      fb.x += fb.dir * fb.speed;
      if (fb.x < arenaLeft + 30) fb.x = arenaLeft + 30;
      if (fb.x + fb.w > arenaRight - 30) fb.x = arenaRight - fb.w - 30;
    }

    // Attack 1: Throw mixed projectiles (both red + purple)
    fb.shootCooldown--;
    if (fb.shootCooldown <= 0) {
      fb.shootCooldown = fb.phase === 2 ? 18 + Math.floor(Math.random()*15) : 30 + Math.floor(Math.random()*20);
      const dx = fbTarget.x + (fbTarget.w||52)/2 - (fb.x + fb.w/2);
      const dy = fbTarget.y + (fbTarget.h||80)/2 - (fb.y + fb.h/2);
      const dist = Math.sqrt(dx*dx + dy*dy) || 1;
      // Throw 2 projectiles
      epsteinProjectiles.push({
        x: fb.x + fb.w/2, y: fb.y + fb.h/3,
        vx: (dx/dist) * 6, vy: (dy/dist) * 6,
        life: 180, rotation: 0, size: 30 + Math.random()*15,
        imgIdx: Math.floor(Math.random() * 5),
      });
      // Occasional bullet too
      if (Math.random() < 0.4) {
        bullets.push({
          x: fb.x + fb.w/2, y: fb.y + fb.h * 0.4,
          vx: fb.dir * 5.5, vy: (Math.random()-0.5) * 2,
          life: 200,
        });
      }
      spawnParticles(fb.x + fb.w/2, fb.y + fb.h/3, '#ff8844', 5);
      // Phase 2: spread shot
      if (fb.phase === 2 && Math.random() < 0.35) {
        for (let a = -0.4; a <= 0.4; a += 0.2) {
          epsteinProjectiles.push({
            x: fb.x + fb.w/2, y: fb.y + fb.h/3,
            vx: fb.dir * 6 * Math.cos(a), vy: 6 * Math.sin(a),
            life: 150, rotation: Math.random()*Math.PI*2, size: 25 + Math.random()*10,
            imgIdx: Math.floor(Math.random() * 5),
          });
        }
      }
    }

    // Attack 2: Ground slam
    fb.slamCooldown--;
    if (fb.slamCooldown <= 0 && fb.vy === 0) {
      fb.slamCooldown = fb.phase === 2 ? 120 + Math.floor(Math.random()*60) : 180 + Math.floor(Math.random()*80);
      fb.vy = -18;
      shakeTimer = 15;
      // After landing, shockwave
      setTimeout(() => {
        if (!fusionBoss || fusionBoss.dead) return;
        shakeTimer = 20;
        screenFlash = 8;
        screenFlashColor = '#ff440044';
        bossVfx.push({ type: 'ring', x: fb.x+fb.w/2, y: fb.y+fb.h, radius: 10, maxRadius: 400, life: 25, maxLife: 25, color: '#ff4400' });
        // Set slam shock flag for ALL players to check outside gate
        fusionBoss._slamShock = 25;
      }, 600);
    }

    // Attack 3: Dash charge (phase 2)
    if (fb.phase === 2) {
      fb.dashCooldown--;
      if (fb.dashCooldown <= 0 && !fb.charging) {
        fb.dashCooldown = 100 + Math.floor(Math.random()*80);
        fb.charging = true;
        fb.chargeVx = fb.dir * 12;
        setTimeout(() => { if (fusionBoss) fusionBoss.charging = false; }, 800);
        bossVfx.push({ type: 'text', x: fb.x+fb.w/2, y: fb.y - 20, text: 'CHARGE!', life: 40, maxLife: 40, color: '#ff4400' });
      }
      if (fb.charging) {
        fb.x += fb.chargeVx;
        if (fb.x < arenaLeft + 20) { fb.x = arenaLeft + 20; fb.charging = false; }
        if (fb.x + fb.w > arenaRight - 20) { fb.x = arenaRight - fb.w - 20; fb.charging = false; }
        spawnParticles(fb.x + (fb.chargeVx > 0 ? 0 : fb.w), fb.y + fb.h/2, '#ff4400', 3);
      }
    }

   } // end _mpHost fusion AI

    // Contact damage — ALL players
    if (p.alive && !p.won && p.iFrames <= 0 && rectsOverlap(p, fusionBoss)) {
      p.hp -= 2;
      p.iFrames = 50;
      p.vx = (p.x < fusionBoss.x ? -1 : 1) * 8;
      p.vy = -8;
      shakeTimer = 12;
      spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4400', 12);
    }

    // Fusion slam shockwave damage — ALL players
    if (fusionBoss._slamShock > 0) {
      fusionBoss._slamShock--;
      if (fusionBoss._slamShock > 20) {
        shakeTimer = Math.max(shakeTimer, fusionBoss._slamShock);
        if (p.alive && p.onGround && Math.abs(p.x - fusionBoss.x) < 300 && p.iFrames <= 0) {
          p.hp--;
          p.iFrames = 45;
          p.vy = -10;
          spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4400', 10);
        }
      }
    }

    if (p.hp <= 0) {
      handlePlayerDeath();
    }
  }

  // ── Fusion death → SPLIT into mini-bosses ──
  if (bossDeathTimer > 0 && fusionBoss && fusionBoss.dead && miniBosses.length === 0) {
    bossDeathTimer--;
    if (bossDeathTimer % 8 === 0 && bossDeathTimer > 40) {
      const ox = (Math.random()-0.5) * 300;
      const oy = (Math.random()-0.5) * 300;
      spawnParticles(fusionBoss.x + fusionBoss.w/2 + ox, fusionBoss.y + fusionBoss.h/2 + oy, ['#ff4400','#8844ff','#ffdd44','#ffffff','#ff44ff'][Math.floor(Math.random()*5)], 20);
      shakeTimer = Math.max(shakeTimer, 12);
    }
    if (bossDeathTimer === 50) {
      screenFlash = 60;
      screenFlashColor = '#ffffff';
      shakeTimer = 50;
      bossVfx.push({ type: 'ring', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y+fusionBoss.h/2, radius: 10, maxRadius: 900, life: 60, maxLife: 60, color: '#ffffff' });
      bossVfx.push({ type: 'text', x: fusionBoss.x+fusionBoss.w/2, y: fusionBoss.y - 40, text: 'THEY\'RE SPLITTING!', life: 180, maxLife: 180, color: '#ff4444' });

      // Spawn 5 mini-bosses: Trump, Epstein, Musk, Clinton, Hawking
      const bArenaW = 2400;
      const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
      const arenaFloor = bigWall.y + 40 + 800;
      const cx = fusionBoss.x + fusionBoss.w/2;
      const cy = fusionBoss.y + fusionBoss.h/2;
      const dm3 = getDiffMult();
      const miniDefs = [
          { name: 'TRUMP', img: 'boss', color: '#ff4400', hp: Math.ceil(18 * dm3.enemyHp), speed: 2.8 * dm3.enemySpeed },
          { name: 'EPSTEIN', img: 'epstein', color: '#8844ff', hp: Math.ceil(15 * dm3.enemyHp), speed: 3.2 * dm3.enemySpeed },
          { name: 'MUSK', img: 'musk', color: '#4488ff', hp: Math.ceil(15 * dm3.enemyHp), speed: 3.8 * dm3.enemySpeed },
          { name: 'CLINTON', img: 'clinton', color: '#cc2222', hp: Math.ceil(12 * dm3.enemyHp), speed: 2.5 * dm3.enemySpeed },
          { name: 'HAWKING', img: 'hawking', color: '#44ff88', hp: Math.ceil(35 * dm3.enemyHp), speed: 1.0 * dm3.enemySpeed },
        ];
      for (let i = 0; i < miniDefs.length; i++) {
        const angle = (i / miniDefs.length) * Math.PI * 2 - Math.PI/2;
        const spawnDist = 120;
        const md = miniDefs[i];
        miniBosses.push({
          x: cx + Math.cos(angle) * spawnDist - 40,
          y: cy + Math.sin(angle) * spawnDist - 50,
          w: 80, h: 100,
          hp: md.hp, maxHp: md.hp,
          name: md.name, imgKey: md.img, color: md.color,
          dir: Math.random() > 0.5 ? 1 : -1,
          speed: md.speed,
          frame: 0, frameTimer: 0,
          dead: false,
          vy: -5 - Math.random() * 5, // burst outward
          vx: Math.cos(angle) * 6,
          shootCooldown: 30 + Math.floor(Math.random() * 40),
          attackTimer: 0,
        });
        // Spawn burst particles
        spawnParticles(cx + Math.cos(angle) * spawnDist, cy + Math.sin(angle) * spawnDist, md.color, 15);
        bossVfx.push({ type: 'ring', x: cx + Math.cos(angle)*spawnDist, y: cy + Math.sin(angle)*spawnDist, radius: 5, maxRadius: 150, life: 20, maxLife: 20, color: md.color });
      }

      state = 'splitfight';
      bossIntroTimer = 1800; // epic 30-second cinematic
      // Clear leftover enemies from previous phases
      bossMinions = [];
      bullets = [];
      epsteinProjectiles = [];
      // 50 HP for the final fight
      player.maxHp = 50;
      player.hp = player.maxHp;

      // MASSIVE entrance VFX
      screenFlash = 80;
      screenFlashColor = '#ffffff';
      shakeTimer = 60;
      // Explosion rings for each mini-boss color
      const splitColors = ['#ff4400','#8844ff','#4488ff','#cc2222', hawkingPhase2 ? '#ffd700' : '#44ff88'];
      for (let sc = 0; sc < splitColors.length; sc++) {
        bossVfx.push({ type: 'ring', x: cx, y: cy, radius: 5 + sc*20, maxRadius: 400 + sc*150, life: 70 + sc*10, maxLife: 70 + sc*10, color: splitColors[sc] });
      }
      // Lightning bolts from edges
      for (let lb = 0; lb < 12; lb++) {
        const lx = arenaLeft + Math.random() * bArenaW;
        const ly = bigWall.y + 40 + Math.random() * 400;
        spawnParticles(lx, ly, splitColors[lb % 5], 15);
        bossVfx.push({ type: 'ring', x: lx, y: ly, radius: 3, maxRadius: 80, life: 20, maxLife: 20, color: splitColors[lb % 5] });
      }
      bossVfx.push({ type: 'text', x: cx, y: cy - 80, text: '⚡ THE CABAL UNLEASHED ⚡', life: 240, maxLife: 240, color: '#ffdd44', size: 42, vy: -0.2 });
      bossVfx.push({ type: 'text', x: cx, y: cy - 40, text: 'FIVE AGAINST ONE', life: 200, maxLife: 200, color: '#ff4444', size: 28, vy: -0.15 });
    }
  }

  // ── MINI-BOSS UPDATE (Split Fight) ──
  if (state === 'splitfight' && miniBosses.length > 0) {
    const bArenaW = 2400;
    const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
    const arenaRight = arenaLeft + bArenaW;
    const arenaTop = bigWall.y + 40;
    const arenaFloor = arenaTop + 800;
    const othersAlive = miniBosses.filter(m => !m.dead && m.name !== 'HAWKING').length;
    const hawkingAlone = othersAlive === 0;

    for (const mb of miniBosses) {
      if (mb.dead) continue;

      mb.frameTimer++;
      if (mb.frameTimer > 8) { mb.frameTimer = 0; mb.frame = (mb.frame + 1) % 4; }
      mb.attackTimer++;
      if (!mb.specialTimer) mb.specialTimer = 0;
      mb.specialTimer++;

      if (_mpHost) {
      // Gravity
      mb.vy += GRAVITY * 0.8;
      mb.y += mb.vy;
      if (mb.vx) { mb.x += mb.vx; mb.vx *= 0.95; if (Math.abs(mb.vx) < 0.3) mb.vx = 0; }
      for (const plat of arenaPlats) {
        if (rectsOverlap(mb, plat) && mb.vy >= 0) {
          const oTop = (mb.y + mb.h) - plat.y;
          if (oTop > 0 && oTop < 40) {
            mb.y = plat.y - mb.h;
            mb.vy = 0;
          }
        }
      }

      // Chase player (speed varies per boss)
      const mbTarget = mpEnabled ? getNearestPlayerTarget(mb.x + mb.w/2, mb.y + mb.h/2) : p;
      if (mbTarget.x < mb.x) mb.dir = -1; else mb.dir = 1;
      const chaseSpeed = mb.name === 'HAWKING' && hawkingAlone ? mb.speed * 2.5 : mb.speed;
      mb.x += mb.dir * chaseSpeed;
      if (mb.x < arenaLeft + 20) mb.x = arenaLeft + 20;
      if (mb.x + mb.w > arenaRight - 20) mb.x = arenaRight - mb.w - 20;

      // === UNIQUE ATTACKS PER BOSS (Enhanced) ===
      mb.shootCooldown--;
      const dx = mbTarget.x + (mbTarget.w||52)/2 - (mb.x + mb.w/2);
      const dy = mbTarget.y + (mbTarget.h||80)/2 - (mb.y + mb.h/2);
      const dist = Math.sqrt(dx*dx + dy*dy) || 1;
      const dm = getDiffMult();

      if (mb.name === 'TRUMP') {
        // Trump: Rage mode — shotgun burst + ground slam + wall of fire
        if (mb.shootCooldown <= 0) {
          mb.shootCooldown = 50 + Math.floor(Math.random() * 20);
          // 5-way spread shotgun
          for (let s = -2; s <= 2; s++) {
            const angle = Math.atan2(dy, dx) + s * 0.2;
            epsteinProjectiles.push({
              x: mb.x + mb.w/2, y: mb.y + mb.h/3,
              vx: Math.cos(angle) * 5.5 * dm.projSpeed, vy: Math.sin(angle) * 5.5 * dm.projSpeed,
              life: 120, rotation: Math.random()*Math.PI*2, size: 20, imgIdx: 0,
            });
          }
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, '#ff4400', 10);
        }
        // Ground slam every 140 frames
        if (mb.specialTimer % 140 === 0 && mb.vy === 0) {
          mb.vy = -14;
          setTimeout(() => {
            if (mb.dead) return;
            shakeTimer = 15;
            spawnParticles(mb.x + mb.w/2, mb.y + mb.h, '#ff4400', 20);
            // Fire wave — ground projectiles spreading left and right
            for (let fw = -1; fw <= 1; fw += 2) {
              for (let fi = 1; fi <= 3; fi++) {
                epsteinProjectiles.push({
                  x: mb.x + mb.w/2 + fw * fi * 40, y: mb.y + mb.h - 20,
                  vx: fw * fi * 2.5, vy: -1,
                  life: 80, rotation: 0, size: 22, imgIdx: 0, isFireWave: true,
                });
              }
            }
            // Trump slam shockwave — flag for ALL players
            mb._slamShock = 25;
          }, 350);
        }
        // Rage roar — speed boost + rapid fire burst every 400 frames
        if (mb.specialTimer % 400 === 0) {
          bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 30, text: 'MAGA RAGE!', life: 60, maxLife: 60, color: '#ff4400' });
          bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 200, life: 25, maxLife: 25, color: '#ff4400' });
          mb.shootCooldown = 0; // immediate next shot
          shakeTimer = 8;
        }
      }
      else if (mb.name === 'EPSTEIN') {
        // Epstein: Shadow master — homing projectiles + shadow vanish + poison trail
        if (mb.shootCooldown <= 0) {
          mb.shootCooldown = 50 + Math.floor(Math.random() * 20);
          // Fire 2 homing projectiles
          for (let h = 0; h < 2; h++) {
            const spreadAngle = Math.atan2(dy, dx) + (h === 0 ? -0.3 : 0.3);
            epsteinProjectiles.push({
              x: mb.x + mb.w/2, y: mb.y + mb.h/3,
              vx: Math.cos(spreadAngle) * 3.5 * dm.projSpeed, vy: Math.sin(spreadAngle) * 3.5 * dm.projSpeed,
              life: 220, rotation: Math.random()*Math.PI*2, size: 25,
              imgIdx: 4, homing: true,
            });
          }
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, '#8844ff', 6);
        }
        // Shadow vanish — teleport to random position every 200 frames
        if (mb.specialTimer % 200 === 0) {
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#8844ff', 18);
          // Leave a poison cloud at old position
          for (let pc = 0; pc < 4; pc++) {
            epsteinProjectiles.push({
              x: mb.x + mb.w/2 + (Math.random()-0.5)*60, y: mb.y + mb.h/2 + (Math.random()-0.5)*60,
              vx: (Math.random()-0.5)*1.5, vy: (Math.random()-0.5)*1.5,
              life: 150, rotation: Math.random()*Math.PI*2, size: 30, imgIdx: 4,
            });
          }
          // Teleport to random arena position near player
          const teleX = mbTarget.x + (Math.random() > 0.5 ? 1 : -1) * (120 + Math.random() * 200);
          mb.x = Math.max(arenaLeft + 30, Math.min(arenaRight - mb.w - 30, teleX));
          mb.y = Math.max(arenaTop + 50, mb.y - 100 - Math.random() * 100);
          mb.vy = 0;
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#8844ff', 18);
          bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 20, text: 'FROM THE SHADOWS', life: 50, maxLife: 50, color: '#8844ff' });
          shakeTimer = 6;
        }
        // Web trap — slow projectile ring every 350 frames
        if (mb.specialTimer % 350 === 0) {
          for (let w = 0; w < 6; w++) {
            const angle = (Math.PI * 2 / 6) * w;
            epsteinProjectiles.push({
              x: mb.x + mb.w/2, y: mb.y + mb.h/2,
              vx: Math.cos(angle) * 2.5, vy: Math.sin(angle) * 2.5,
              life: 180, rotation: angle, size: 22, imgIdx: 4,
            });
          }
          bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 180, life: 20, maxLife: 20, color: '#8844ff' });
        }
      }
      else if (mb.name === 'MUSK') {
        // Musk: Tech genius — laser burst + drone strike + EMP dash
        if (mb.shootCooldown <= 0) {
          mb.shootCooldown = 35 + Math.floor(Math.random() * 15);
          // Triple laser burst
          for (let b = 0; b < 3; b++) {
            const spread = (b - 1) * 0.15;
            const angle = Math.atan2(dy, dx) + spread;
            epsteinProjectiles.push({
              x: mb.x + mb.w/2, y: mb.y + mb.h/3,
              vx: Math.cos(angle) * 7 * dm.projSpeed, vy: Math.sin(angle) * 7 * dm.projSpeed,
              life: 90, rotation: Math.random()*Math.PI*2, size: 16, imgIdx: 0,
            });
          }
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, '#4488ff', 6);
        }
        // EMP dash every 100 frames — leaves electric trail
        if (mb.specialTimer % 100 === 0) {
          const oldX = mb.x;
          mb.vx = mb.dir * 22;
          mb.vy = -5;
          // Electric trail
          for (let et = 0; et < 5; et++) {
            epsteinProjectiles.push({
              x: oldX + mb.w/2 + et * mb.dir * 20, y: mb.y + mb.h/2,
              vx: 0, vy: -0.5,
              life: 60, rotation: Math.random()*Math.PI*2, size: 18, imgIdx: 0,
            });
          }
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#4488ff', 15);
          bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 120, life: 15, maxLife: 15, color: '#4488ff' });
        }
        // Drone strike every 250 frames — rains projectiles from above
        if (mb.specialTimer % 250 === 0) {
          bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 30, text: 'DRONE STRIKE!', life: 60, maxLife: 60, color: '#4488ff' });
          for (let ds = 0; ds < 6; ds++) {
            const dropX = mbTarget.x - 150 + ds * 60 + (Math.random()-0.5)*30;
            epsteinProjectiles.push({
              x: dropX, y: arenaTop + 20,
              vx: (Math.random()-0.5)*1.5, vy: 5 + Math.random()*2,
              life: 120, rotation: Math.random()*Math.PI*2, size: 20, imgIdx: 0,
            });
          }
          shakeTimer = 8;
        }
      }
      else if (mb.name === 'CLINTON') {
        // Clinton: Political assassin — poison shots + backstab teleport + decoy
        if (mb.shootCooldown <= 0) {
          mb.shootCooldown = 60 + Math.floor(Math.random() * 30);
          // Double shot — one aimed, one arcing
          epsteinProjectiles.push({
            x: mb.x + mb.w/2, y: mb.y + mb.h/3,
            vx: (dx/dist) * 4.5 * dm.projSpeed, vy: (dy/dist) * 4.5 * dm.projSpeed,
            life: 160, rotation: Math.random()*Math.PI*2, size: 24, imgIdx: 4,
          });
          // Arc shot that goes high and comes down
          epsteinProjectiles.push({
            x: mb.x + mb.w/2, y: mb.y + mb.h/3,
            vx: (dx/dist) * 3, vy: -6,
            life: 140, rotation: Math.random()*Math.PI*2, size: 22, imgIdx: 4,
          });
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, '#cc2222', 6);
        }
        // Backstab teleport every 160 frames
        if (mb.specialTimer % 160 === 0) {
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#cc2222', 18);
          const behindX = mbTarget.x + ((mbTarget.facing||1) > 0 ? -90 : (mbTarget.w||52) + 50);
          mb.x = Math.max(arenaLeft + 20, Math.min(arenaRight - mb.w - 20, behindX));
          mb.y = mbTarget.y - 15;
          mb.vy = 0;
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#cc2222', 18);
          bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 20, text: 'NOTHING HAPPENED', life: 50, maxLife: 50, color: '#cc2222' });
          shakeTimer = 8;
          // Immediate backstab shot
          epsteinProjectiles.push({
            x: mb.x + mb.w/2, y: mb.y + mb.h/3,
            vx: (mbTarget.x < mb.x ? -1 : 1) * 6, vy: 0,
            life: 60, rotation: 0, size: 28, imgIdx: 4,
          });
        }
        // Decoy ring every 300 frames — circle of slow projectiles
        if (mb.specialTimer % 300 === 0) {
          for (let d = 0; d < 8; d++) {
            const angle = (Math.PI * 2 / 8) * d;
            epsteinProjectiles.push({
              x: mb.x + mb.w/2, y: mb.y + mb.h/2,
              vx: Math.cos(angle) * 2, vy: Math.sin(angle) * 2,
              life: 200, rotation: angle, size: 20, imgIdx: 4,
            });
          }
          bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 160, life: 20, maxLife: 20, color: '#cc2222' });
        }
      }
      else if (mb.name === 'HAWKING') {
        const isPhase2 = hawkingPhase2;
        const hawkSpeed = hawkingAlone ? 1.2 : 0.6;
        // Hawking: Genius supreme — orbital ring + gravity well + black hole + time warp
        if (mb.shootCooldown <= 0) {
          mb.shootCooldown = isPhase2 ? 20 : (hawkingAlone ? 30 : 55);
          // Orbital burst - bigger ring in phase 2
          const numProj = isPhase2 ? 12 : (hawkingAlone ? 8 : 5);
          for (let o = 0; o < numProj; o++) {
            const angle = (Math.PI * 2 / numProj) * o + mb.specialTimer * 0.05;
            epsteinProjectiles.push({
              x: mb.x + mb.w/2, y: mb.y + mb.h/3,
              vx: Math.cos(angle) * (isPhase2 ? 5 : 4), vy: Math.sin(angle) * (isPhase2 ? 5 : 4),
              life: 140, rotation: angle, size: isPhase2 ? 24 : 20, imgIdx: 0,
            });
          }
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/3, hawkingPhase2 ? '#ffd700' : '#44ff88', 10);
          // Aimed homing shot
          epsteinProjectiles.push({
            x: mb.x + mb.w/2, y: mb.y + mb.h/3,
            vx: (dx/dist) * 6, vy: (dy/dist) * 6,
            life: 200, rotation: Math.random()*Math.PI*2, size: isPhase2 ? 32 : 28,
            imgIdx: 4, homing: true,
          });
        }
        // Gravity well — stores pull data for ALL players to check
        const gravInterval = isPhase2 ? 150 : (hawkingAlone ? 250 : 400);
        if (mb.specialTimer % gravInterval === 0) {
          bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 300, maxRadius: 10, life: 40, maxLife: 40, color: hawkingPhase2 ? '#ffd700' : '#44ff88' });
          bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y - 30, text: isPhase2 ? 'BLACK HOLE' : 'SINGULARITY', life: 60, maxLife: 60, color: hawkingPhase2 ? '#ffd700' : '#44ff88' });
          mb._gravPull = { active: 40, str: isPhase2 ? 6 : 4, range: isPhase2 ? 700 : 500 };
          shakeTimer = isPhase2 ? 15 : 10;
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, hawkingPhase2 ? '#ffd700' : '#44ff88', 25);
        }
        // Phase 2 exclusive: Hawking radiation — random projectile rain
        if (isPhase2 && mb.specialTimer % 80 === 0) {
          for (let hr = 0; hr < 4; hr++) {
            const rx = mb.x + mb.w/2 + (Math.random()-0.5)*400;
            epsteinProjectiles.push({
              x: rx, y: arenaTop + 10,
              vx: (Math.random()-0.5)*2, vy: 4 + Math.random()*3,
              life: 120, rotation: Math.random()*Math.PI*2, size: 22, imgIdx: 0,
            });
          }
        }
        // Phase 2 exclusive: Wormhole teleport every 200 frames
        if (isPhase2 && mb.specialTimer % 200 === 0) {
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffd700', 20);
          bossVfx.push({ type: 'ring', x: mb.x+mb.w/2, y: mb.y+mb.h/2, radius: 10, maxRadius: 200, life: 20, maxLife: 20, color: '#ffd700' });
          const _warpTarget = mpEnabled ? getNearestPlayerTarget(mb.x + mb.w/2, mb.y + mb.h/2) : p;
          mb.x = _warpTarget.x + (Math.random() > 0.5 ? 200 : -200 - mb.w);
          mb.x = Math.max(arenaLeft + 20, Math.min(arenaRight - mb.w - 20, mb.x));
          spawnParticles(mb.x + mb.w/2, mb.y + mb.h/2, '#ffd700', 20);
          bossVfx.push({ type: 'text', x: mb.x+mb.w/2, y: mb.y-30, text: 'WORMHOLE', life: 40, maxLife: 40, color: '#ffd700' });
        }
      }

      } // end _mpHost mini-boss AI

      // Contact damage — ALL players
      const contactDmg = (mb.name === 'HAWKING' && hawkingAlone) ? (hawkingPhase2 ? 3 : 2) : 1;
      if (p.alive && p.iFrames <= 0 && rectsOverlap(p, mb)) {
        p.hp -= contactDmg;
        p.iFrames = 40;
        p.vx = (p.x < mb.x ? -1 : 1) * 5;
        p.vy = -6;
        shakeTimer = 8;
        spawnParticles(p.x + p.w/2, p.y + p.h/2, mb.color, 8);
      }

      // Hawking gravity well pull — ALL alive players
      if (mb.name === 'HAWKING' && mb._gravPull && mb._gravPull.active > 0) {
        mb._gravPull.active--;
        if (!p.alive) continue;
        const gpDx = (mb.x + mb.w/2) - (p.x + p.w/2);
        const gpDy = (mb.y + mb.h/2) - (p.y + p.h/2);
        const gpDist = Math.sqrt(gpDx*gpDx + gpDy*gpDy) || 1;
        if (gpDist < mb._gravPull.range) {
          p.vx += (gpDx / gpDist) * mb._gravPull.str * 0.15;
          p.vy += (gpDy / gpDist) * (mb._gravPull.str - 1) * 0.15;
        }
      }

      // Trump/mini-boss slam shockwave — ALL players
      if (mb._slamShock > 0) {
        mb._slamShock--;
        if (mb._slamShock > 20) {
          shakeTimer = Math.max(shakeTimer, mb._slamShock);
          const shockDist = Math.abs(p.x - mb.x);
          if (p.alive && shockDist < 250 && p.iFrames <= 0 && Math.abs(p.y + p.h - (mb.y + mb.h)) < 60) {
            p.hp -= 3;
            p.iFrames = 45;
            p.vy = -10;
            spawnParticles(p.x + p.w/2, p.y + p.h/2, '#ff4400', 12);
          }
        }
      }
    }

    // Homing projectile tracking — target nearest player
    for (const proj of epsteinProjectiles) {
      if (proj.homing && proj.life > 30) {
        const _homingTarget = mpEnabled ? getNearestPlayerTarget(proj.x, proj.y) : p;
        const hdx = _homingTarget.x + (_homingTarget.w||52)/2 - proj.x;
        const hdy = _homingTarget.y + (_homingTarget.h||80)/2 - proj.y;
        const hdist = Math.sqrt(hdx*hdx + hdy*hdy) || 1;
        proj.vx += (hdx / hdist) * 0.15;
        proj.vy += (hdy / hdist) * 0.15;
        // Cap speed
        const spd = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy);
        if (spd > 5) { proj.vx = (proj.vx/spd)*5; proj.vy = (proj.vy/spd)*5; }
      }
    }

    if (p.hp <= 0) {
      handlePlayerDeath();
    }

    // Check if all mini-bosses dead → VICTORY (skip if Hawking cutscenes are handling it)
    const allDead = miniBosses.length > 0 && miniBosses.every(mb => mb.dead);
    if (allDead && state === 'splitfight') {
      bossDeathTimer = 0;
      screenFlash = 60;
      screenFlashColor = '#ffffff';
      shakeTimer = 50;
      for (let i = 0; i < 150; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 14;
        particles.push({ x: p.x + p.w/2, y: p.y + p.h/2, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed-3, life: 80+Math.random()*60, color: ['#ff4400','#8844ff','#ffdd44','#ffffff','#44ff88','#4488ff','#ff44ff'][Math.floor(Math.random()*7)], size: 3+Math.random()*8 });
      }
      bossVfx.push({ type: 'ring', x: p.x+p.w/2, y: p.y+p.h/2, radius: 10, maxRadius: 900, life: 70, maxLife: 70, color: '#ffdd44' });
      bossVfx.push({ type: 'text', x: p.x+p.w/2, y: p.y - 50, text: '★ FREEDOM! ★', life: 200, maxLife: 200, color: '#ffdd44' });
      // Teleport player out
      player.x = bigWall.x + bigWall.w + 30;
      player.y = bigWall.y - player.h;
      player.vy = 0; player.vx = 0;
      arenaPlats = [];
      guards = [];
      bullets = [];
      projectiles = [];
      epsteinProjectiles = [];
      bossMinions = [];
      state = 'winCutscene';
      winCutsceneTimer = 0;
      player.won = true;
      player.alive = true;
      player.hp = player.maxHp;
      player.iFrames = 99999;
      mpSpectating = false;
      spawnParticles(player.x, player.y, '#ffdd44', 50);
      spawnParticles(player.x, player.y, '#ff6644', 40);
      restartCooldown = 60;
    }
  }

  // ════════════════════════════════════════════════════════════════
  // HAWKING REFUSAL — Undertale-style "But it refused." cutscene
  // ════════════════════════════════════════════════════════════════
  if (state === 'hawkingRefusal') {
    hawkingRefusalTimer++;
    const t = hawkingRefusalTimer;
    // Phase transitions (timed in frames @ 60fps)
    // 0-60: Fade to black
    // 60-120: Green heart appears in center
    // 120-180: Heart pulses
    // 180-220: Heart cracks (lines appear)
    // 220-280: Heart splits in two halves separating
    // 280-340: Halves float apart, dimming, particles scatter
    // 340-400: Screen fully dark, halves almost gone... then STOP
    // 400-460: "But it refused." text appears letter by letter
    // 460-520: Heart halves SLAM back together, GOLD flash
    // 520-620: Heart pulses BRIGHTER, STRONGER, gold energy radiating
    // 620-780: Close-up normal Hawking face, lingering, dramatic
    // 780-920: Screen shakes violently + golden energy cracks + flash builds
    // 920-1120: Golden Hawking revealed — slow, intimidating, aura radiating
    // 1120+: Return to splitfight with Phase 2 Hawking
    if (t === 1) hawkingRefusalPhase = 0;
    if (t === 60) hawkingRefusalPhase = 1;
    if (t === 120) hawkingRefusalPhase = 2;
    if (t === 180) hawkingRefusalPhase = 3;
    if (t === 220) hawkingRefusalPhase = 4;
    if (t === 280) hawkingRefusalPhase = 5;
    if (t === 340) hawkingRefusalPhase = 6;
    if (t === 400) hawkingRefusalPhase = 7;
    if (t === 460) hawkingRefusalPhase = 8;
    if (t === 520) hawkingRefusalPhase = 9;
    if (t === 620) hawkingRefusalPhase = 10;
    if (t === 780) hawkingRefusalPhase = 11;
    if (t === 920) hawkingRefusalPhase = 12;
    if (t === 1120) hawkingRefusalPhase = 13;

    // At the end — return to splitfight with Phase 2 Hawking
    if (t === 1130) {
      hawkingPhase2 = true;
      state = 'splitfight';
      const hawk = miniBosses.find(m => m.name === 'HAWKING');
      if (hawk) {
        // MASSIVE Hawking — 2x size, full HP reset, boosted stats
        const dm = getDiffMult();
        hawk.w = 160;
        hawk.h = 200;
        hawk.hp = Math.ceil(50 * dm.enemyHp);
        hawk.maxHp = hawk.hp;
        hawk.speed = 1.2 * dm.enemySpeed;
        hawk.dead = false;
        hawk.shootCooldown = 30;
        hawk.specialTimer = 0;
        hawk.color = '#ffd700'; // GOLD theme
        // Reposition center arena
        const bArenaW = 2400;
        const arenaLeft = bigWall.x + bigWall.w/2 - bArenaW/2;
        const arenaFloor = bigWall.y + 40 + 800;
        hawk.x = arenaLeft + bArenaW/2 - hawk.w/2;
        hawk.y = arenaFloor - hawk.h - 50;
        hawk.vy = -15;
      }
      // Restore player HP a bit
      player.hp = Math.min(player.maxHp, player.hp + 15);
      screenFlash = 80;
      screenFlashColor = '#ffd700';
      shakeTimer = 60;
      bossVfx.push({ type: 'text', x: W/2, y: H/2 - 100, text: 'HAWKING TRANSCENDED', life: 180, maxLife: 180, color: '#ffd700' });
      bossVfx.push({ type: 'ring', x: W/2, y: H/2, radius: 10, maxRadius: 800, life: 50, maxLife: 50, color: '#ffd700' });
    }
  }

  // ════════════════════════════════════════════════════════════════
  // HAWKING DEATH — Epic cinematic death scene
  // ════════════════════════════════════════════════════════════════
  if (state === 'hawkingDeath') {
    hawkingDeathTimer++;
    const dt = hawkingDeathTimer;
    const hawk = miniBosses.find(m => m.name === 'HAWKING');
    const hx = hawk ? hawk._deathX || (hawk.x + hawk.w/2) : W/2;
    const hy = hawk ? hawk._deathY || (hawk.y + hawk.h/2) : H/2;

    // Phase 1 (0-80): TIME FREEZE — everything stops, glitch distortion
    if (dt < 80) {
      // Slow-mo particles dripping from Hawking
      if (dt % 4 === 0) {
        spawnParticles(hx + (Math.random()-0.5)*80, hy + (Math.random()-0.5)*80, '#ffd700', 3);
      }
      // Screen shake gets worse
      if (dt > 30) shakeTimer = Math.max(shakeTimer, 3 + Math.floor((dt-30)/10));
    }

    // Phase 2 (80-200): HAWKING RISES — body levitates, energy pours out
    if (dt >= 80 && dt < 200) {
      const riseProg = (dt - 80) / 120;
      if (hawk) {
        hawk.y -= 1.5 * (1 - riseProg); // float upward
      }
      // Massive energy eruption particles
      if (dt % 2 === 0) {
        for (let i = 0; i < 5; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 2 + Math.random() * 6;
          particles.push({
            x: hx, y: hy - (dt-80)*1.2,
            vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
            life: 40 + Math.random() * 40,
            color: ['#ffd700','#ffcc00','#ffaa00','#ffffff','#ffe066'][Math.floor(Math.random()*5)],
            size: 2 + Math.random() * 5,
          });
        }
      }
      // Growing shockwaves
      if (dt % 20 === 0) {
        bossVfx.push({ type: 'ring', x: hx, y: hy - (dt-80)*1.2, radius: 5, maxRadius: 300 + riseProg * 200, life: 35, maxLife: 35, color: '#ffd700' });
      }
      shakeTimer = Math.max(shakeTimer, 5 + Math.floor(riseProg * 15));
      // Screen flashes
      if (dt % 30 === 0) { screenFlash = 8; screenFlashColor = '#ffd700'; }
    }

    // Phase 3 (200-400): REALITY CRACKS — space-time tears around Hawking
    if (dt >= 200 && dt < 400) {
      const crackProg = (dt - 200) / 200;
      // Continuous energy outpour
      if (dt % 3 === 0) {
        for (let i = 0; i < 4; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 3 + Math.random() * 8;
          particles.push({
            x: hx, y: hy - 150,
            vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 2,
            life: 50 + Math.random() * 60,
            color: ['#ffd700','#ffffff','#ffdd44','#4488ff','#ff44ff'][Math.floor(Math.random()*5)],
            size: 3 + Math.random() * 6,
          });
        }
      }
      // Massive expanding shockwaves
      if (dt % 25 === 0) {
        bossVfx.push({ type: 'ring', x: hx, y: hy - 150, radius: 10, maxRadius: 500, life: 40, maxLife: 40, color: '#ffffff' });
      }
      shakeTimer = Math.max(shakeTimer, 10 + Math.floor(crackProg * 25));
      // Periodic screen flashes getting more intense
      if (dt % 15 === 0 && crackProg > 0.5) { screenFlash = 10; screenFlashColor = '#ffffff'; }
    }

    // Phase 4 (400-550): DISINTEGRATION — body breaks into stars
    if (dt >= 400 && dt < 550) {
      const disProg = (dt - 400) / 150;
      // Massive star burst
      if (dt % 2 === 0) {
        for (let i = 0; i < 8; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 1 + Math.random() * 10 * disProg;
          particles.push({
            x: hx + (Math.random()-0.5) * 60 * disProg, y: hy - 150 + (Math.random()-0.5) * 60 * disProg,
            vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 1,
            life: 80 + Math.random() * 80,
            color: ['#ffd700','#ffcc00','#ffffff','#ffdd44','#ffe066','#ffaa00'][Math.floor(Math.random()*6)],
            size: 1 + Math.random() * 4,
          });
        }
      }
      if (dt >= 400 && dt <= 401) { screenFlash = 40; screenFlashColor = '#ffd700'; shakeTimer = 40; }
      if (dt >= 450 && dt <= 451) { screenFlash = 30; screenFlashColor = '#ffffff'; }
      // Hide Hawking sprite progressively (handled in draw)
    }

    // Phase 5 (550-750): COSMIC MOMENT — stars form equation, dialogue
    if (dt >= 550 && dt < 750) {
      // Gentle ambient particles
      if (dt % 6 === 0) {
        particles.push({
          x: Math.random() * W, y: Math.random() * H,
          vx: (Math.random()-0.5) * 0.5, vy: -Math.random() * 0.5 - 0.2,
          life: 60 + Math.random() * 40,
          color: ['#ffd70044','#ffffff44','#ffdd4444'][Math.floor(Math.random()*3)],
          size: 1 + Math.random() * 2,
        });
      }
    }

    // Phase 6 (750-850): WHITE OUT — massive flash, peaceful transition
    if (dt >= 750 && dt <= 751) {
      screenFlash = 80;
      screenFlashColor = '#ffffff';
      shakeTimer = 30;
      // Enormous particle explosion
      for (let i = 0; i < 200; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 15;
        particles.push({
          x: hx, y: hy - 150,
          vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 3,
          life: 80 + Math.random() * 80,
          color: ['#ffd700','#ffffff','#ffdd44','#ffe066','#ffcc00'][Math.floor(Math.random()*5)],
          size: 2 + Math.random() * 8,
        });
      }
    }

    // Phase 7 (850-900): Return to game, mark all dead, trigger victory
    if (dt >= 900) {
      // Mark Hawking dead
      if (hawk) { hawk.hp = 0; hawk.dead = true; }
      // Mark ALL bosses dead (they should already be dead except Hawking)
      for (const mb of miniBosses) mb.dead = true;
      // Now trigger victory
      bossDeathTimer = 0;
      screenFlash = 60;
      screenFlashColor = '#ffffff';
      shakeTimer = 50;
      for (let i = 0; i < 150; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 14;
        particles.push({ x: player.x + player.w/2, y: player.y + player.h/2, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed-3, life: 80+Math.random()*60, color: ['#ff4400','#8844ff','#ffdd44','#ffffff','#44ff88','#4488ff','#ff44ff'][Math.floor(Math.random()*7)], size: 3+Math.random()*8 });
      }
      bossVfx.push({ type: 'ring', x: player.x+player.w/2, y: player.y+player.h/2, radius: 10, maxRadius: 900, life: 70, maxLife: 70, color: '#ffdd44' });
      bossVfx.push({ type: 'text', x: player.x+player.w/2, y: player.y - 50, text: '★ FREEDOM! ★', life: 200, maxLife: 200, color: '#ffdd44' });
      if (bigWall) {
        player.x = bigWall.x + bigWall.w + 30;
        player.y = bigWall.y - player.h;
      }
      player.vy = 0; player.vx = 0;
      arenaPlats = [];
      guards = [];
      bullets = [];
      projectiles = [];
      epsteinProjectiles = [];
      bossMinions = [];
      state = 'winCutscene';
      winCutsceneTimer = 0;
      player.won = true;
      player.alive = true;
      player.hp = player.maxHp;
      player.iFrames = 99999;
      mpSpectating = false;
      spawnParticles(player.x, player.y, '#ffdd44', 50);
      spawnParticles(player.x, player.y, '#ff6644', 40);
      restartCooldown = 60;
    }
    // Cap timer to prevent runaway
    if (hawkingDeathTimer > 910) hawkingDeathTimer = 910;
  }

  // ════════════════════════════════════════════════════════════════
  // WIN CUTSCENE — Player walks to citizenship office, THE END
  // ════════════════════════════════════════════════════════════════
  if (state === 'winCutscene') {
    winCutsceneTimer++;
    const wt = winCutsceneTimer;
    
    // Set office position once at start
    if (wt === 1) {
      winCutsceneOfficeX = player.x + 750;
    }
    
    // Phase 1 (0-300): Player auto-walks right toward office
    if (wt < 300) {
      player.x += 2.5;
      player.runFrame = (player.runFrame || 0) + 0.3;
      player.facing = 1;
    }
    
    // Phase 2: Player stops at office door
    if (wt === 300) {
      player.runFrame = 0;
    }
    
    // Camera always follows player during cutscene (unclamped — player is past level edge)
    cameraX = player.x - W * 0.3;
    if (cameraX < 0) cameraX = 0;
    
    // Phase 3 (700+): Transition to won state with buttons
    if (wt >= 700) {
      state = 'won';
      restartCooldown = 0;
    }
  }
  
  // Update boss VFX
  for (let i = bossVfx.length - 1; i >= 0; i--) {
    const vfx = bossVfx[i];
    vfx.life--;
    if (vfx.type === 'ring') {
      const prog = 1 - vfx.life / vfx.maxLife;
      vfx.radius = vfx.maxRadius * prog;
    }
    if (vfx.life <= 0) bossVfx.splice(i, 1);
  }
  
  // Boss ambient energy particles during fight
  if ((state === 'bossfight' || state === 'bossdialogue') && boss && !boss.dead) {
    // Swirling energy around boss
    if (Math.random() < 0.3 * boss.phase) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 40 + Math.random() * 60;
      const colors = { 1: '#ff660044', 2: '#ff880066', 3: '#ff220088' };
      particles.push({
        x: boss.x + boss.w/2 + Math.cos(angle) * dist,
        y: boss.y + boss.h/2 + Math.sin(angle) * dist,
        vx: Math.cos(angle + Math.PI/2) * 1.5,
        vy: Math.sin(angle + Math.PI/2) * 1.5 - 1,
        life: 20 + Math.random() * 20,
        color: colors[boss.phase],
        size: 2 + Math.random() * 3,
      });
    }
    // Ground fire at boss feet in phase 3
    if (boss.phase === 3 && Math.random() < 0.4) {
      particles.push({
        x: boss.x + Math.random() * boss.w,
        y: boss.y + boss.h,
        vx: (Math.random()-0.5) * 2,
        vy: -Math.random() * 4 - 1,
        life: 15 + Math.random() * 15,
        color: ['#ff2200','#ff6600','#ffaa00','#ffcc00'][Math.floor(Math.random()*4)],
        size: 2 + Math.random() * 4,
      });
    }
  }

  // Epstein ambient energy particles
  if (state === 'epsteinfight' && epstein && !epstein.dead) {
    if (Math.random() < 0.25 * epstein.phase) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 40 + Math.random() * 60;
      particles.push({
        x: epstein.x + epstein.w/2 + Math.cos(angle) * dist,
        y: epstein.y + epstein.h/2 + Math.sin(angle) * dist,
        vx: Math.cos(angle + Math.PI/2) * 1.2,
        vy: Math.sin(angle + Math.PI/2) * 1.2 - 1,
        life: 18 + Math.random() * 18,
        color: epstein.phase === 2 ? '#ff44ff66' : '#8844ff44',
        size: 2 + Math.random() * 3,
      });
    }
    // Purple ground mist
    if (Math.random() < 0.3) {
      particles.push({
        x: epstein.x + Math.random() * epstein.w,
        y: epstein.y + epstein.h,
        vx: (Math.random()-0.5) * 2,
        vy: -Math.random() * 2 - 0.5,
        life: 15 + Math.random() * 15,
        color: ['#8844ff','#aa66ff','#6622cc','#ff44ff'][Math.floor(Math.random()*4)],
        size: 2 + Math.random() * 3,
      });
    }
  }

  // Fusion boss ambient particles
  if (state === 'fusionfight' && fusionBoss && !fusionBoss.dead) {
    if (Math.random() < 0.4) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 50 + Math.random() * 80;
      particles.push({
        x: fusionBoss.x + fusionBoss.w/2 + Math.cos(angle) * dist,
        y: fusionBoss.y + fusionBoss.h/2 + Math.sin(angle) * dist,
        vx: Math.cos(angle + Math.PI/2) * 1.5,
        vy: Math.sin(angle + Math.PI/2) * 1.5 - 1,
        life: 20 + Math.random() * 20,
        color: ['#ff440066','#8844ff66','#ff880044','#ffdd4444'][Math.floor(Math.random()*4)],
        size: 2 + Math.random() * 4,
      });
    }
    // Fire+purple ground mist
    if (Math.random() < 0.4) {
      particles.push({
        x: fusionBoss.x + Math.random() * fusionBoss.w,
        y: fusionBoss.y + fusionBoss.h,
        vx: (Math.random()-0.5) * 3,
        vy: -Math.random() * 4 - 1,
        life: 15 + Math.random() * 15,
        color: ['#ff4400','#8844ff','#ff8800','#ffcc00'][Math.floor(Math.random()*4)],
        size: 2 + Math.random() * 4,
      });
    }
  }

  // Mini-boss ambient particles
  if (state === 'splitfight') {
    for (const mb of miniBosses) {
      if (mb.dead) continue;
      if (Math.random() < 0.15) {
        particles.push({
          x: mb.x + Math.random() * mb.w,
          y: mb.y + mb.h,
          vx: (Math.random()-0.5) * 2,
          vy: -Math.random() * 2 - 0.5,
          life: 12 + Math.random() * 10,
          color: mb.color,
          size: 2 + Math.random() * 2,
        });
      }
    }
  }

  // Particles
  particles = particles.filter(pt => {
    pt.x += pt.vx;
    pt.y += pt.vy;
    pt.vy += 0.15;
    pt.life--;
    pt.size *= 0.97;
    return pt.life > 0;
  });
  // Hard cap — trim oldest particles if over limit (direct pushes bypass spawnParticles cap)
  if (particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);
}

// ── Draw ──
function draw() {
  const shake = shakeTimer > 0 ? (Math.random() - 0.5) * (shakeTimer > 20 ? 7 : 4) : 0;
  ctx.save();
  ctx.translate(shake, shake * 0.6);

  const inBossFight = state === 'bossfight' || state === 'bossdialogue' || state === 'epsteinfight' || state === 'phonecall' || state === 'fusioncutscene' || state === 'fusionfight' || state === 'splitfight' || state === 'hawkingRefusal' || state === 'hawkingDeath';
  const bossPhase = boss ? boss.phase : 1;

  // Skip game-world rendering when in menu (menu draws its own background)
  if (state !== 'menu') {

  // Desert sunset sky — underground sewer during bossfight
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  if (inBossFight || bossDeathTimer > 0) {
    // Dark underground sewer atmosphere
    const p3 = bossPhase === 3 ? 1 : bossPhase === 2 ? 0.6 : 0.3;
    skyGrad.addColorStop(0, '#080808');
    skyGrad.addColorStop(0.3, `rgba(15,20,12,${0.9+p3*0.1})`);
    skyGrad.addColorStop(0.5, '#0d1210');
    skyGrad.addColorStop(0.7, '#0a0f0c');
    skyGrad.addColorStop(1, '#050805');
  } else {
    skyGrad.addColorStop(0, '#1a0a2e');
    skyGrad.addColorStop(0.25, '#4a1942');
    skyGrad.addColorStop(0.45, '#c0392b');
    skyGrad.addColorStop(0.65, '#e67e22');
    skyGrad.addColorStop(0.85, '#f4d03f');
    skyGrad.addColorStop(1, '#d4a043');
  }
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  // Lightning/emergency light flickers during bossfight 
  if (inBossFight && Math.random() < 0.005 * bossPhase) {
    // Flickering emergency light
    ctx.fillStyle = `rgba(180,${bossPhase===3?50:120},0,${0.04 + Math.random()*0.06})`;
    ctx.fillRect(0, 0, W, H);
  }

  // Stars (top of sky only) — hidden during bossfight, with twinkle
  if (!inBossFight) {
    const _starTime = Date.now() / 1000;
    for (let i = 0; i < 50; i++) {
      const sx = ((i * 137 + 50) % W + (cameraX * 0.05) % W) % W;
      const sy = (i * 97 + 20) % (H * 0.3);
      const twinkle = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(_starTime * (1.2 + i * 0.3) + i * 2.7));
      const starSize = 1 + (i % 3) * 0.5;
      ctx.globalAlpha = twinkle * 0.5;
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(sx, sy, starSize, 0, Math.PI * 2); ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Sun (setting)
  const sunX = W * 0.7 + cameraX * 0.01;
  const sunY = GROUND_Y - 40;
  ctx.fillStyle = '#fff4cc66';
  ctx.beginPath();
  ctx.arc(sunX, sunY, 60, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#ffdd6688';
  ctx.beginPath();
  ctx.arc(sunX, sunY, 45, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#ffcc44aa';
  ctx.beginPath();
  ctx.arc(sunX, sunY, 30, 0, Math.PI * 2);
  ctx.fill();

  // Desert mountains (parallax)
  ctx.fillStyle = '#5a3520';
  for (let i = 0; i < 12; i++) {
    const mx = i * 300 - (cameraX * 0.15) % 300;
    const mh = 80 + (i * 67) % 100;
    const mw = 180 + (i * 31) % 120;
    ctx.beginPath();
    ctx.moveTo(mx, GROUND_Y);
    ctx.lineTo(mx + mw / 2, GROUND_Y - mh);
    ctx.lineTo(mx + mw, GROUND_Y);
    ctx.fill();
  }
  // Far mountains
  ctx.fillStyle = '#7a4a3088';
  for (let i = 0; i < 8; i++) {
    const mx = i * 400 - (cameraX * 0.08) % 400 + 100;
    const mh = 50 + (i * 43) % 60;
    const mw = 250 + (i * 29) % 150;
    ctx.beginPath();
    ctx.moveTo(mx, GROUND_Y);
    ctx.lineTo(mx + mw / 2, GROUND_Y - mh);
    ctx.lineTo(mx + mw, GROUND_Y);
    ctx.fill();
  }

  ctx.save();
  ctx.translate(-cameraX, -cameraY);

  // Desert sand ground
  const groundGrad = ctx.createLinearGradient(0, GROUND_Y, 0, H);
  groundGrad.addColorStop(0, '#c9a96e');
  groundGrad.addColorStop(0.3, '#b8944d');
  groundGrad.addColorStop(1, '#8b6914');
  ctx.fillStyle = groundGrad;
  const groundRight = state === 'winCutscene' ? levelWidth + 2000 : levelWidth;
  ctx.fillRect(0, GROUND_Y, groundRight, H - GROUND_Y);
  // Sand texture line
  ctx.fillStyle = '#d4b87a';
  ctx.fillRect(0, GROUND_Y, groundRight, 3);

  // Ground cracks
  ctx.strokeStyle = '#a0854088';
  ctx.lineWidth = 1;
  for (let i = 0; i < levelWidth; i += 60) {
    ctx.beginPath();
    ctx.moveTo(i, GROUND_Y + 12);
    ctx.lineTo(i + 15, GROUND_Y + 18);
    ctx.lineTo(i + 8, GROUND_Y + 25);
    ctx.stroke();
  }

  // Desert decorations
  for (const d of decorations) {
    if (d.type === 'cactus') {
      // Saguaro cactus
      ctx.fillStyle = '#2d6b30';
      const ch = d.size * 2;
      // Main trunk
      ctx.fillRect(d.x, d.y - ch, 8, ch);
      // Left arm
      ctx.fillRect(d.x - 10, d.y - ch * 0.7, 10, 6);
      ctx.fillRect(d.x - 10, d.y - ch * 0.7 - 14, 6, 14);
      // Right arm
      ctx.fillRect(d.x + 8, d.y - ch * 0.5, 12, 6);
      ctx.fillRect(d.x + 14, d.y - ch * 0.5 - 18, 6, 18);
      // Highlight
      ctx.fillStyle = '#3a8a3d';
      ctx.fillRect(d.x + 2, d.y - ch, 3, ch);
    } else if (d.type === 'tumbleweed') {
      ctx.fillStyle = '#8b7355';
      ctx.beginPath();
      ctx.arc(d.x, d.y - d.size / 2, d.size / 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#6b5335';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(d.x, d.y - d.size / 2, d.size / 3, 0, Math.PI * 2);
      ctx.stroke();
    } else if (d.type === 'rock') {
      ctx.fillStyle = '#9a8060';
      ctx.beginPath();
      ctx.moveTo(d.x, d.y);
      ctx.lineTo(d.x - d.size / 2, d.y);
      ctx.lineTo(d.x - d.size / 3, d.y - d.size / 2);
      ctx.lineTo(d.x + d.size / 3, d.y - d.size / 1.5);
      ctx.lineTo(d.x + d.size / 2, d.y);
      ctx.fill();
      ctx.fillStyle = '#b09a70';
      ctx.fillRect(d.x - 2, d.y - d.size / 2, 4, 3);
    } else {
      // Desert scrub brush
      ctx.fillStyle = '#6b7a40';
      ctx.beginPath();
      ctx.arc(d.x, d.y - 4, d.size / 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#5a6930';
      ctx.beginPath();
      ctx.arc(d.x + 4, d.y - 6, d.size / 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Walls - desert obstacles (adobe/sandstone)
  for (const wall of walls) {
    // Drop shadow
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(wall.x + 3, wall.y + 3, wall.w, wall.h);
    if (wall.isPlatform) {
      const platGrad = ctx.createLinearGradient(wall.x, wall.y, wall.x, wall.y + wall.h);
      platGrad.addColorStop(0, '#c0a060');
      platGrad.addColorStop(0.3, '#a08050');
      platGrad.addColorStop(1, '#806030');
      ctx.fillStyle = platGrad;
      ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
      // Top highlight
      ctx.fillStyle = '#d4b87088';
      ctx.fillRect(wall.x, wall.y, wall.w, 2);
      // Bottom edge
      ctx.fillStyle = '#60401044';
      ctx.fillRect(wall.x, wall.y + wall.h - 1, wall.w, 1);
    } else {
      // Adobe/sandstone wall with gradient
      const wallGrad = ctx.createLinearGradient(wall.x, wall.y, wall.x + wall.w, wall.y + wall.h);
      wallGrad.addColorStop(0, '#c09050');
      wallGrad.addColorStop(0.5, '#b08040');
      wallGrad.addColorStop(1, '#906830');
      ctx.fillStyle = wallGrad;
      ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
      ctx.strokeStyle = '#90603022';
      ctx.lineWidth = 1;
      for (let by = wall.y; by < wall.y + wall.h; by += 10) {
        ctx.beginPath();
        ctx.moveTo(wall.x, by);
        ctx.lineTo(wall.x + wall.w, by);
        ctx.stroke();
      }
      // Top highlight
      ctx.fillStyle = '#d4b87066';
      ctx.fillRect(wall.x, wall.y, wall.w, 3);
    }
  }

  // THE BORDER WALL - steel slat fence
  if (bigWall) {
    const bw = bigWall;

    // Steel slat fence look
    ctx.fillStyle = '#888';
    ctx.fillRect(bw.x, bw.y, bw.w, bw.h);

    // Vertical steel slats
    ctx.fillStyle = '#999';
    for (let sx = bw.x; sx < bw.x + bw.w; sx += 6) {
      ctx.fillRect(sx, bw.y, 4, bw.h);
    }
    // Darker gaps
    ctx.fillStyle = '#55555566';
    for (let sx = bw.x + 4; sx < bw.x + bw.w; sx += 6) {
      ctx.fillRect(sx, bw.y, 2, bw.h);
    }

    // Horizontal beams
    ctx.fillStyle = '#777';
    ctx.fillRect(bw.x - 3, bw.y + 20, bw.w + 6, 6);
    ctx.fillRect(bw.x - 3, bw.y + bw.h / 2, bw.w + 6, 6);
    ctx.fillRect(bw.x - 3, bw.y + bw.h - 30, bw.w + 6, 6);

    // Top - anti-climb plate
    ctx.fillStyle = '#aaa';
    ctx.fillRect(bw.x - 8, bw.y - 10, bw.w + 16, 14);
    ctx.fillStyle = '#bbb';
    ctx.fillRect(bw.x - 8, bw.y - 10, bw.w + 16, 3);

    // Barbed wire on top
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let bx = bw.x - 10; bx < bw.x + bw.w + 10; bx += 8) {
      ctx.moveTo(bx, bw.y - 16);
      ctx.lineTo(bx + 4, bw.y - 22);
      ctx.lineTo(bx + 8, bw.y - 16);
    }
    ctx.stroke();
    // Barbs
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    for (let bx = bw.x - 6; bx < bw.x + bw.w + 10; bx += 8) {
      ctx.beginPath();
      ctx.moveTo(bx, bw.y - 19);
      ctx.lineTo(bx - 3, bw.y - 25);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(bx, bw.y - 19);
      ctx.lineTo(bx + 3, bw.y - 25);
      ctx.stroke();
    }

    // ▲ CLIMB text
    ctx.fillStyle = '#ffcc44';
    ctx.font = 'bold 11px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('▲ CLIMB ▲', bw.x + bw.w / 2, bw.y + bw.h / 2);

    // Arrows
    ctx.fillStyle = '#ffcc4466';
    for (let ay = bw.y + 40; ay < bw.y + bw.h - 40; ay += 30) {
      ctx.beginPath();
      ctx.moveTo(bw.x + bw.w / 2, ay - 8);
      ctx.lineTo(bw.x + bw.w / 2 - 6, ay);
      ctx.lineTo(bw.x + bw.w / 2 + 6, ay);
      ctx.fill();
    }

    // MEXICO label (left side)
    ctx.fillStyle = '#006847aa';
    ctx.font = 'bold 16px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('🇲🇽 MÉXICO', bw.x - 60, bw.y + 30);

    // USA label (right side)
    ctx.fillStyle = '#3c3b6eaa';
    ctx.font = 'bold 16px monospace';
    ctx.fillText('🇺🇸 USA', bw.x + bw.w + 60, bw.y + 30);

    // "EL OTRO LADO" sign
    ctx.fillStyle = '#44ff4488';
    ctx.font = 'bold 14px monospace';
    ctx.fillText('★ EL OTRO LADO ★', bw.x + bw.w + 60, bw.y + bw.h - 20);
  }

  // ── BORDER WALL ARENA ──
  // Draw the full sewer background behind platforms (only during bossfight)
  const drawArena = (state === 'bossfight' || state === 'bossdialogue' || state === 'cutscene' || state === 'epsteinfight' || state === 'phonecall' || state === 'fusioncutscene' || state === 'fusionfight' || state === 'splitfight' || state === 'hawkingRefusal' || state === 'hawkingDeath' || bossDeathTimer > 0) && arenaPlats.length > 0;
  if (drawArena) {
    const sewFloor = arenaPlats.find(a => a.isFloor);
    const sewCeil = arenaPlats.find(a => a.isCeiling);
    const sewLeft = arenaPlats.find(a => a.isSideWall && a.x < (sewFloor ? sewFloor.x : 0));
    const sewRight = arenaPlats.find(a => a.isSideWall && a.x > (sewFloor ? sewFloor.x : 0));
    if (sewFloor && sewCeil) {
      const sx = sewCeil.x, sy = sewCeil.y, sw = sewCeil.w, sh = sewFloor.y - sewCeil.y;
      // Dark concrete background
      const bgGrad = ctx.createLinearGradient(sx, sy, sx, sy + sh);
      bgGrad.addColorStop(0, '#1a1e1a');
      bgGrad.addColorStop(0.3, '#141814');
      bgGrad.addColorStop(0.7, '#101410');
      bgGrad.addColorStop(1, '#0c100c');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(sx, sy, sw, sh);
      // Brick/tile pattern on walls
      ctx.strokeStyle = '#1e241e';
      ctx.lineWidth = 1;
      const brickH = 28, brickW = 55;
      for (let row = 0; row < sh / brickH; row++) {
        const by = sy + row * brickH;
        const offset = (row % 2) * brickW / 2;
        for (let col = -1; col < sw / brickW + 1; col++) {
          const bx = sx + col * brickW + offset;
          ctx.strokeRect(bx, by, brickW, brickH);
        }
      }
      // Moss/stain patches
      for (let i = 0; i < 12; i++) {
        const mx2 = sx + ((i*317+50) % sw);
        const my2 = sy + ((i*211+30) % sh);
        ctx.fillStyle = `rgba(40,${60+i*5},30,${0.15 + (i%3)*0.05})`;
        ctx.beginPath();
        ctx.ellipse(mx2, my2, 20+i*3, 12+i*2, 0, 0, Math.PI*2);
        ctx.fill();
      }
      // Pipes along ceiling
      for (let px = sx + 60; px < sx + sw - 60; px += 280) {
        // Horizontal pipe
        ctx.fillStyle = '#3a4038';
        ctx.fillRect(px, sy + 25, 180, 14);
        ctx.fillStyle = '#4a5248';
        ctx.fillRect(px, sy + 25, 180, 4);
        // Pipe joints
        ctx.fillStyle = '#555d52';
        ctx.fillRect(px - 3, sy + 22, 20, 20);
        ctx.fillRect(px + 163, sy + 22, 20, 20);
        // Vertical drip pipe (every other)
        if (px % 560 < 280) {
          ctx.fillStyle = '#3a4038';
          ctx.fillRect(px + 90, sy + 39, 10, 50);
        }
      }
      // Hanging chains
      for (let cx = sx + 150; cx < sx + sw; cx += 400) {
        ctx.strokeStyle = '#44484488';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(cx, sy + 20);
        for (let cy = 0; cy < 80; cy += 12) {
          ctx.lineTo(cx + Math.sin(cy*0.3)*5, sy + 20 + cy);
        }
        ctx.stroke();
      }
      // Water/sludge along bottom
      const waterY = sy + sh - 15;
      const waterGrad = ctx.createLinearGradient(sx, waterY, sx, sy + sh);
      waterGrad.addColorStop(0, 'rgba(20,60,30,0.4)');
      waterGrad.addColorStop(1, 'rgba(15,40,20,0.6)');
      ctx.fillStyle = waterGrad;
      ctx.fillRect(sx, waterY, sw, 15);
      // Water shimmer
      const t = Date.now() / 1000;
      for (let wx = sx; wx < sx + sw; wx += 30) {
        const wy = waterY + Math.sin(wx*0.02 + t*2) * 2;
        ctx.fillStyle = `rgba(80,180,80,${0.08 + Math.sin(wx*0.05+t)*0.04})`;
        ctx.fillRect(wx, wy, 25, 3);
      }
      // Dripping water particles (animated)
      for (let d = 0; d < 5; d++) {
        const dx = sx + ((d*433+100) % sw);
        const dripY = sy + 40 + ((Date.now()/30 + d*97) % (sh - 60));
        ctx.fillStyle = 'rgba(100,200,120,0.5)';
        ctx.fillRect(dx, dripY, 2, 6);
      }
      // Dim emergency lights on walls
      for (let lx = sx + 100; lx < sx + sw; lx += 350) {
        const flicker = Math.sin(Date.now()/300 + lx) * 0.3 + 0.5;
        // Light fixture
        ctx.fillStyle = '#333';
        ctx.fillRect(lx - 8, sy + 50, 16, 10);
        // Light cone
        ctx.fillStyle = `rgba(200,160,50,${flicker * 0.08})`;
        ctx.beginPath();
        ctx.moveTo(lx - 5, sy + 60);
        ctx.lineTo(lx - 80, sy + sh * 0.6);
        ctx.lineTo(lx + 80, sy + sh * 0.6);
        ctx.lineTo(lx + 5, sy + 60);
        ctx.fill();
        // Bulb glow
        ctx.fillStyle = `rgba(255,200,80,${flicker * 0.5})`;
        ctx.beginPath();
        ctx.arc(lx, sy + 58, 4, 0, Math.PI*2);
        ctx.fill();
      }
      // Danger signs
      ctx.fillStyle = '#ffcc0033';
      ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('⚠ RESTRICTED AREA ⚠', sx + sw/2, sy + sh/2 - 50);
      ctx.fillStyle = '#ff333322';
      ctx.font = 'bold 10px monospace';
      ctx.fillText('AUTHORIZED PERSONNEL ONLY', sx + sw/2, sy + sh/2 - 35);
      // Grates on floor
      ctx.strokeStyle = '#2a302a';
      ctx.lineWidth = 2;
      for (let gx = sx + 200; gx < sx + sw - 200; gx += 400) {
        for (let gy2 = 0; gy2 < 30; gy2 += 6) {
          ctx.beginPath();
          ctx.moveTo(gx, sy + sh - 30 + gy2);
          ctx.lineTo(gx + 80, sy + sh - 30 + gy2);
          ctx.stroke();
        }
      }
    }
  }
  // Draw individual arena elements (only during bossfight)
  if (drawArena) for (const ap of arenaPlats) {
    if (ap.isPlatform) {
      // Elevated platforms - rusty metal grating
      const platGrad = ctx.createLinearGradient(ap.x, ap.y, ap.x, ap.y + ap.h);
      platGrad.addColorStop(0, '#5a6355');
      platGrad.addColorStop(1, '#3d4539');
      ctx.fillStyle = platGrad;
      ctx.fillRect(ap.x, ap.y, ap.w, ap.h);
      // Grating lines
      ctx.strokeStyle = '#4a5246';
      ctx.lineWidth = 1;
      for (let gx = ap.x; gx < ap.x + ap.w; gx += 8) {
        ctx.beginPath(); ctx.moveTo(gx, ap.y); ctx.lineTo(gx, ap.y + ap.h); ctx.stroke();
      }
      // Top edge - rusted metal
      ctx.fillStyle = '#6a5540';
      ctx.fillRect(ap.x, ap.y, ap.w, 3);
      // Support chains/beams
      ctx.fillStyle = '#3a3a38';
      ctx.fillRect(ap.x + 8, ap.y + ap.h, 6, 35);
      ctx.fillRect(ap.x + ap.w - 14, ap.y + ap.h, 6, 35);
    } else if (ap.isSideWall) {
      // Thick concrete border walls
      const wallGrad = ctx.createLinearGradient(ap.x, ap.y, ap.x + ap.w, ap.y);
      wallGrad.addColorStop(0, '#2a2e28');
      wallGrad.addColorStop(0.5, '#353935');
      wallGrad.addColorStop(1, '#2a2e28');
      ctx.fillStyle = wallGrad;
      ctx.fillRect(ap.x, ap.y, ap.w, ap.h);
      // Concrete texture lines
      ctx.strokeStyle = '#3a3e38';
      ctx.lineWidth = 1;
      for (let sy = ap.y; sy < ap.y + ap.h; sy += 35) {
        ctx.beginPath(); ctx.moveTo(ap.x, sy); ctx.lineTo(ap.x + ap.w, sy); ctx.stroke();
      }
      // Rust/water stains
      ctx.fillStyle = 'rgba(80,60,40,0.15)';
      for (let st = 0; st < 3; st++) {
        ctx.fillRect(ap.x + 5, ap.y + st*120 + 50, ap.w - 10, 40);
      }
      // Warning stripes at top
      ctx.fillStyle = '#ffcc0022';
      ctx.fillRect(ap.x, ap.y, ap.w, 15);
      ctx.fillStyle = '#33333344';
      for (let s = ap.x; s < ap.x + ap.w; s += 12) {
        ctx.fillRect(s, ap.y, 6, 15);
      }
    } else if (ap.isCeiling) {
      // Concrete ceiling
      ctx.fillStyle = '#252a25';
      ctx.fillRect(ap.x, ap.y, ap.w, ap.h);
      ctx.fillStyle = '#1e231e';
      ctx.fillRect(ap.x, ap.y + ap.h - 3, ap.w, 3);
      // Ceiling cracks
      ctx.strokeStyle = '#1a1e1a';
      ctx.lineWidth = 1;
      for (let c = 0; c < 6; c++) {
        const cx = ap.x + (c * 313 + 100) % ap.w;
        ctx.beginPath();
        ctx.moveTo(cx, ap.y + ap.h);
        ctx.lineTo(cx + (c%2?20:-20), ap.y);
        ctx.stroke();
      }
    } else if (ap.isFloor) {
      // Sewer floor - wet concrete
      const floorGrad = ctx.createLinearGradient(ap.x, ap.y, ap.x, ap.y + ap.h);
      floorGrad.addColorStop(0, '#3a3e38');
      floorGrad.addColorStop(1, '#2a2e28');
      ctx.fillStyle = floorGrad;
      ctx.fillRect(ap.x, ap.y, ap.w, ap.h);
      // Top edge - wear marks
      if (state === 'bossfight' || state === 'bossdialogue') {
        const edgePulse = Math.sin(Date.now() / 500) * 0.3 + 0.7;
        const edgeColor = boss && boss.phase === 3 ? `rgba(255,50,0,${edgePulse * 0.4})` : boss && boss.phase === 2 ? `rgba(200,120,0,${edgePulse * 0.25})` : `rgba(100,140,80,${edgePulse * 0.2})`;
        ctx.fillStyle = edgeColor;
        ctx.fillRect(ap.x, ap.y, ap.w, 2);
      } else {
        ctx.fillStyle = '#4a5048';
        ctx.fillRect(ap.x, ap.y, ap.w, 2);
      }
      // Tile grid
      ctx.strokeStyle = '#32363044';
      ctx.lineWidth = 1;
      for (let gx = ap.x; gx < ap.x + ap.w; gx += 50) {
        ctx.beginPath(); ctx.moveTo(gx, ap.y); ctx.lineTo(gx, ap.y + ap.h); ctx.stroke();
      }
    }
  }

  // ── Boss Minions Drawing ──
  for (const m of bossMinions) {
    if (m.dead) continue;
    const mx = m.x, my = m.y;
    const bounce = Math.sin(m.frame * Math.PI / 2) * 2;
    ctx.save();
    const minionImg = m.isEpstein ? epsteinImg : guardImg;
    if (m.dir < 0) {
      ctx.translate(mx + m.w, my - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(minionImg, 0, 0, m.w, m.h);
    } else {
      ctx.drawImage(minionImg, mx, my - bounce, m.w, m.h);
    }
    ctx.restore();
    // Glow aura (shadow-based, no blocky rect)
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.shadowColor = m.isEpstein ? '#8844ff' : '#ff5000';
    ctx.shadowBlur = 20;
    if (m.dir < 0) {
      ctx.translate(mx + m.w, my - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(minionImg, 0, 0, m.w, m.h);
    } else {
      ctx.drawImage(minionImg, mx, my - bounce, m.w, m.h);
    }
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.restore();
    // HP bar
    const mHpPct = m.hp / m.maxHp;
    ctx.fillStyle = '#000000aa';
    ctx.fillRect(mx, my - 14, m.w, 5);
    ctx.fillStyle = mHpPct > 0.5 ? '#44cc44' : '#cc2222';
    ctx.fillRect(mx, my - 14, m.w * mHpPct, 5);
    // Label
    ctx.fillStyle = m.isEpstein ? '#8844ff88' : '#ff444488';
    ctx.font = 'bold 9px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(m.isEpstein ? 'EPSTEIN' : 'MAGA', mx + m.w/2, my - 18);
  }

  // Guards
  for (const g of guards) {
    if (g.dead) continue;
    const gx = g.x;
    const gy = g.y;
    const bounce = Math.sin(g.frame * Math.PI / 2) * 2;

    // Shadow (only if on ground)
    if (!g.climbing) {
      ctx.fillStyle = '#00000055';
      ctx.beginPath();
      ctx.ellipse(gx + g.w / 2, GROUND_Y, g.w * 0.7, 5, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Guard image
    ctx.save();
    if (g.dir < 0) {
      ctx.translate(gx + g.w, gy - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(guardImg, 0, 0, g.w, g.h);
    } else {
      ctx.drawImage(guardImg, gx, gy - bounce, g.w, g.h);
    }
    ctx.restore();

    // Red glow when alert (shadow-based, no blocky rect)
    if (g.alert) {
      ctx.save();
      ctx.globalAlpha = 0.2;
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 25;
      if (g.dir < 0) {
        ctx.translate(gx + g.w, gy - bounce);
        ctx.scale(-1, 1);
        ctx.drawImage(guardImg, 0, 0, g.w, g.h);
      } else {
        ctx.drawImage(guardImg, gx, gy - bounce, g.w, g.h);
      }
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // HP bar above guard
    const hpBarW = g.w;
    const hpPct = g.hp / g.maxHp;
    ctx.fillStyle = '#000000aa';
    ctx.fillRect(gx, gy - 22 - bounce, hpBarW, 6);
    ctx.fillStyle = hpPct > 0.5 ? '#44cc44' : hpPct > 0.25 ? '#ccaa22' : '#cc2222';
    ctx.fillRect(gx, gy - 22 - bounce, hpBarW * hpPct, 6);

    // Alert indicator
    if (g.alert) {
      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 18px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('!', gx + g.w / 2, gy - 28);
    }

    // Flashlight cone when alert
    if (g.alert && !g.climbing) {
      ctx.fillStyle = '#ffff0011';
      ctx.beginPath();
      ctx.moveTo(gx + g.w / 2, gy + 10);
      if (g.dir > 0) {
        ctx.lineTo(gx + g.w + 80, gy - 20);
        ctx.lineTo(gx + g.w + 80, gy + 50);
      } else {
        ctx.lineTo(gx - 80, gy - 20);
        ctx.lineTo(gx - 80, gy + 50);
      }
      ctx.fill();
    }
  }

  // ── Boss Drawing ──
  if (boss && !boss.dead) {
    const bx = boss.x;
    const by = boss.y;
    const bounce = Math.sin(boss.frame * Math.PI / 2) * 3;
    const t = Date.now() / 1000;

    // Phase-dependent pulsing outer aura (large, dramatic)
    const auraRadius = boss.phase === 3 ? 220 : boss.phase === 2 ? 160 : 110;
    const auraIntensity = 0.05 + Math.sin(t * 3) * 0.03;
    const auraG = ctx.createRadialGradient(bx+boss.w/2, by+boss.h/2, 20, bx+boss.w/2, by+boss.h/2, auraRadius);
    if (boss.phase === 3) {
      auraG.addColorStop(0, `rgba(255,30,0,${auraIntensity * 3})`);
      auraG.addColorStop(0.5, `rgba(255,80,0,${auraIntensity * 2})`);
      auraG.addColorStop(1, 'rgba(255,0,0,0)');
    } else if (boss.phase === 2) {
      auraG.addColorStop(0, `rgba(255,140,0,${auraIntensity * 2.5})`);
      auraG.addColorStop(0.5, `rgba(255,100,0,${auraIntensity * 1.5})`);
      auraG.addColorStop(1, 'rgba(255,80,0,0)');
    } else {
      auraG.addColorStop(0, `rgba(255,100,0,${auraIntensity * 1.5})`);
      auraG.addColorStop(1, 'rgba(255,50,0,0)');
    }
    ctx.fillStyle = auraG;
    ctx.beginPath();
    ctx.arc(bx + boss.w/2, by + boss.h/2, auraRadius, 0, Math.PI * 2);
    ctx.fill();

    // Energy ring rotating around boss
    ctx.strokeStyle = boss.phase === 3 ? 'rgba(255,50,0,0.25)' : boss.phase === 2 ? 'rgba(255,140,0,0.2)' : 'rgba(255,200,0,0.12)';
    ctx.lineWidth = 2;
    const ringR = 80 + boss.phase * 15;
    ctx.beginPath();
    for (let a = 0; a < Math.PI * 2; a += 0.1) {
      const wobble = Math.sin(a * 3 + t * 4) * 8;
      const rx = bx + boss.w/2 + Math.cos(a + t * 2) * (ringR + wobble);
      const ry = by + boss.h/2 + Math.sin(a + t * 2) * (ringR * 0.4 + wobble * 0.3);
      if (a === 0) ctx.moveTo(rx, ry);
      else ctx.lineTo(rx, ry);
    }
    ctx.closePath();
    ctx.stroke();

    // Charge trail — fire and speed lines
    if (boss.charging) {
      const trailDir = boss.chargeVx > 0 ? -1 : 1;
      for (let i = 0; i < 5; i++) {
        const tx = bx + boss.w/2 + trailDir * (20 + i * 25);
        const ty = by + 10 + Math.random() * (boss.h - 20);
        ctx.fillStyle = `rgba(255, ${100 + i*30}, 0, ${0.5 - i*0.08})`;
        ctx.beginPath();
        ctx.arc(tx, ty, 6 + Math.random() * 8, 0, Math.PI * 2);
        ctx.fill();
      }
      // Speed lines across screen
      ctx.strokeStyle = 'rgba(255,150,0,0.15)';
      ctx.lineWidth = 3;
      for (let sl = 0; sl < 12; sl++) {
        const sy = by - 100 + Math.random() * (boss.h + 200);
        const sx = bx + boss.w/2 + trailDir * (50 + Math.random() * 300);
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx + trailDir * (60 + Math.random() * 80), sy);
        ctx.stroke();
      }
    }

    // Slam warning — danger zone on ground
    if (boss.slamming && boss.vy < 0) {
      const warnX = bx + boss.w/2;
      const arenaFloorY = bigWall.y + 40 + 800;
      // Pulsing danger zone
      const warnPulse = Math.sin(t * 15) * 0.3 + 0.5;
      ctx.fillStyle = `rgba(255, 0, 0, ${warnPulse * 0.3})`;
      ctx.beginPath();
      ctx.ellipse(warnX, arenaFloorY, 250, 15, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = `rgba(255, 0, 0, ${warnPulse * 0.8})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(warnX, arenaFloorY, 200, 10, 0, 0, Math.PI * 2);
      ctx.stroke();
      // Warning text
      ctx.fillStyle = `rgba(255, 0, 0, ${warnPulse})`;
      ctx.font = 'bold 24px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('⚠ INCOMING SLAM ⚠', warnX, arenaFloorY - 25);
    }

    // Slam falling — afterimage trail
    if (boss.slamming && boss.vy > 2) {
      for (let ai = 1; ai <= 4; ai++) {
        ctx.globalAlpha = 0.15 / ai;
        ctx.drawImage(bossImg, bx, by - bounce - ai * 30, boss.w, boss.h);
      }
      ctx.globalAlpha = 1;
    }

    // Boss shadow (gets bigger when airborne)
    const airDist = boss.slamming ? Math.max(30, Math.abs(boss.vy) * 3) : 0;
    ctx.fillStyle = `rgba(0,0,0,${boss.slamming ? 0.2 : 0.4})`;
    ctx.beginPath();
    ctx.ellipse(bx + boss.w/2, by + boss.h + 5 + airDist, boss.w * 0.8 + airDist * 0.3, 8 + airDist * 0.1, 0, 0, Math.PI * 2);
    ctx.fill();

    // Boss intro animation
    const introScale = bossIntroTimer > 0 ? 1 + (bossIntroTimer / 120) * 0.5 : 1;
    const introAlpha = bossIntroTimer > 80 ? (120 - bossIntroTimer) / 40 : 1;

    // Boss image (Trump) with intro fx
    ctx.save();
    ctx.globalAlpha = introAlpha;
    if (introScale !== 1) {
      ctx.translate(bx + boss.w/2, by + boss.h/2);
      ctx.scale(introScale, introScale);
      ctx.translate(-(bx + boss.w/2), -(by + boss.h/2));
    }
    if (boss.dir < 0) {
      ctx.translate(bx + boss.w, by - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(bossImg, 0, 0, boss.w, boss.h);
    } else {
      ctx.drawImage(bossImg, bx, by - bounce, boss.w, boss.h);
    }
    ctx.restore();

    // Phase glow aura (re-draw image with shadowBlur instead of blocky fillRect)
    const tintPulse = 0.15 + Math.sin(t * 4) * 0.1;
    ctx.save();
    ctx.globalAlpha = tintPulse;
    ctx.shadowColor = boss.phase === 3 ? '#ff0000' : '#ff8800';
    ctx.shadowBlur = 20 + boss.phase * 10;
    if (boss.dir < 0) {
      ctx.translate(bx + boss.w, by - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(bossImg, 0, 0, boss.w, boss.h);
    } else {
      ctx.drawImage(bossImg, bx, by - bounce, boss.w, boss.h);
    }
    ctx.shadowBlur = 0;
    ctx.restore();

    // Glowing eyes effect (phase 2+)
    if (boss.phase >= 2) {
      const eyeY = by + boss.h * 0.2 - bounce;
      const eyeGlow = Math.sin(t * 6) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(255, ${boss.phase === 3 ? 0 : 100}, 0, ${eyeGlow})`;
      ctx.shadowColor = boss.phase === 3 ? '#ff0000' : '#ff8800';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(bx + boss.w * 0.35, eyeY, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(bx + boss.w * 0.65, eyeY, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // Label with phase — bigger, glowing
    const phaseLabels = { 1: '★ TRUMP ★', 2: '★★ ENRAGED ★★', 3: '★★★ FINAL FORM ★★★' };
    ctx.shadowColor = boss.phase === 3 ? '#ff0000' : boss.phase === 2 ? '#ff6600' : '#ff4444';
    ctx.shadowBlur = boss.phase * 8;
    ctx.fillStyle = boss.phase === 3 ? '#ff0000' : boss.phase === 2 ? '#ff6600' : '#ff2222';
    ctx.font = `bold ${boss.phase === 3 ? 22 : boss.phase === 2 ? 20 : 18}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(phaseLabels[boss.phase], bx + boss.w / 2, by - 48);
    ctx.shadowBlur = 0;

    // Boss HP bar — bigger, more detailed
    const bossHpW = 140;
    const bossHpPct = boss.hp / boss.maxHp;
    ctx.fillStyle = '#000000dd';
    ctx.fillRect(bx + boss.w / 2 - bossHpW / 2 - 1, by - 33, bossHpW + 2, 14);
    // HP gradient
    const hpGrad = ctx.createLinearGradient(bx + boss.w/2 - bossHpW/2, 0, bx + boss.w/2 + bossHpW/2, 0);
    if (bossHpPct > 0.6) { hpGrad.addColorStop(0, '#cc2222'); hpGrad.addColorStop(1, '#ff4444'); }
    else if (bossHpPct > 0.25) { hpGrad.addColorStop(0, '#cc4400'); hpGrad.addColorStop(1, '#ff8800'); }
    else { hpGrad.addColorStop(0, '#cc0000'); hpGrad.addColorStop(1, '#ff0000'); }
    ctx.fillStyle = hpGrad;
    ctx.fillRect(bx + boss.w/2 - bossHpW/2, by - 32, bossHpW * bossHpPct, 12);
    ctx.strokeStyle = '#ff666688';
    ctx.lineWidth = 1;
    ctx.strokeRect(bx + boss.w/2 - bossHpW/2, by - 33, bossHpW, 14);
    // Phase markers on HP bar
    ctx.fillStyle = '#ffffff88';
    ctx.fillRect(bx + boss.w/2 - bossHpW/2 + bossHpW * 0.6, by - 33, 2, 14);
    ctx.fillRect(bx + boss.w/2 - bossHpW/2 + bossHpW * 0.25, by - 33, 2, 14);
    // HP shimmer
    const shimmer = Math.sin(Date.now()/150) * 0.15 + 0.15;
    ctx.fillStyle = `rgba(255,255,255,${shimmer})`;
    ctx.fillRect(bx + boss.w/2 - bossHpW/2, by - 33, bossHpW * bossHpPct * 0.6, 4);
  }

  // ── Boss Death VFX (ghost/fading boss) ──
  if (boss && boss.dead && bossDeathTimer > 0) {
    const deathAlpha = bossDeathTimer > 30 ? 0.5 : bossDeathTimer / 60;
    ctx.globalAlpha = deathAlpha;
    ctx.save();
    const scaleUp = 1 + (180 - bossDeathTimer) * 0.003;
    ctx.translate(boss.x + boss.w/2, boss.y + boss.h/2);
    ctx.scale(scaleUp, scaleUp);
    ctx.translate(-(boss.x + boss.w/2), -(boss.y + boss.h/2));
    ctx.drawImage(bossImg, boss.x, boss.y, boss.w, boss.h);
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // Player trail
  for (const t of player.trail) {
    const alpha = t.life / 10;
    ctx.fillStyle = `rgba(100, 200, 255, ${alpha * 0.3})`;
    ctx.fillRect(t.x - 3, t.y - 3, 6, 6);
  }

  // Player
  if (player.alive) {
    const p = player;
    const px = p.x;
    const py = p.y;
    const runBounce = p.onGround ? Math.sin(p.runFrame * Math.PI / 2) * 2 : 0;

    // Shadow
    ctx.fillStyle = '#00000055';
    ctx.beginPath();
    ctx.ellipse(px + p.w / 2, GROUND_Y, p.w * 0.7, 5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Player image (centered on hitbox)
    const pDrawW = p.w * PLAYER_IMG_SCALE;
    const pDrawH = p.h * PLAYER_IMG_SCALE;
    const pOffX = (p.w - pDrawW) / 2;
    const pOffY = p.h - pDrawH;
    ctx.save();
    if (p.facing < 0) {
      ctx.translate(px + p.w, py - runBounce);
      ctx.scale(-1, 1);
      ctx.drawImage(playerImg, -pOffX, pOffY, pDrawW, pDrawH);
    } else {
      ctx.drawImage(playerImg, px + pOffX, py + pOffY - runBounce, pDrawW, pDrawH);
    }
    ctx.restore();

    // Climbing indicator
    if (p.climbingBigWall) {
      ctx.fillStyle = '#ffcc44cc';
      ctx.font = 'bold 11px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('CLIMBING!', px + p.w / 2, py - 14);
    }

    // Wall sliding indicator
    if (p.onWall && !p.onGround && !p.climbingBigWall) {
      ctx.fillStyle = '#ccc';
      ctx.font = '9px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('wall slide', px + p.w / 2, py - 10);
    }

    // Player flash when iFrames (shadow-based for transparent cutout)
    if (p.iFrames > 0 && Math.floor(p.iFrames / 4) % 2 === 0) {
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 30;
      const drawW = p.w * PLAYER_IMG_SCALE;
      const drawH = p.h * PLAYER_IMG_SCALE;
      const pOffX = (p.w - drawW) / 2;
      const pOffY = p.h - drawH;
      ctx.drawImage(playerImg, px + pOffX, py - runBounce + pOffY, drawW, drawH);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.restore();
    }
  }

  // Draw other multiplayer players
  drawOtherPlayers();

  // Projectiles
  for (const proj of projectiles) {
    ctx.save();
    ctx.translate(proj.x, proj.y);
    const angle = Math.atan2(proj.vy, proj.vx);
    ctx.rotate(angle);
    ctx.drawImage(projectileImg, -proj.w / 2, -proj.h / 2, proj.w, proj.h);
    ctx.restore();
  }

  // Bullets — with fire trails
  for (const b of bullets) {
    // Trail behind bullet
    const speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
    const nx = -b.vx/speed, ny = -b.vy/speed;
    for (let i = 1; i <= 4; i++) {
      ctx.fillStyle = `rgba(255, ${150 + i*25}, 0, ${0.3 - i*0.06})`;
      ctx.beginPath();
      ctx.arc(b.x + nx*i*6, b.y + ny*i*6, 4 - i*0.5, 0, Math.PI * 2);
      ctx.fill();
    }
    // Outer glow
    ctx.fillStyle = '#ff660033';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 12, 0, Math.PI * 2);
    ctx.fill();
    // Mid glow
    ctx.fillStyle = '#ffaa0066';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 7, 0, Math.PI * 2);
    ctx.fill();
    // Bullet core
    ctx.fillStyle = '#ffdd44';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
    ctx.fill();
  }

  // ── Epstein Boss Drawing ──
  if (epstein && !epstein.dead) {
    const ex = epstein.x, ey = epstein.y;
    const bounce = Math.sin(epstein.frame * Math.PI / 2) * 3;
    const t = Date.now() / 1000;

    // Dark purple aura
    const auraSize = 40 + Math.sin(t*3) * 10;
    const auraGrad = ctx.createRadialGradient(ex+epstein.w/2, ey+epstein.h/2, 10, ex+epstein.w/2, ey+epstein.h/2, epstein.w/2 + auraSize);
    auraGrad.addColorStop(0, 'rgba(136,68,255,0.3)');
    auraGrad.addColorStop(0.7, 'rgba(136,68,255,0.1)');
    auraGrad.addColorStop(1, 'rgba(136,68,255,0)');
    ctx.fillStyle = auraGrad;
    ctx.fillRect(ex - auraSize, ey - auraSize, epstein.w + auraSize*2, epstein.h + auraSize*2);

    // Afterimage trail
    for (let ai = 1; ai <= 3; ai++) {
      ctx.globalAlpha = 0.12 / ai;
      ctx.drawImage(epsteinImg, ex - epstein.dir * ai * 12, ey - bounce, epstein.w, epstein.h);
    }
    ctx.globalAlpha = 1;

    // Main sprite
    ctx.save();
    if (epstein.dir < 0) {
      ctx.translate(ex + epstein.w, ey - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(epsteinImg, 0, 0, epstein.w, epstein.h);
    } else {
      ctx.drawImage(epsteinImg, ex, ey - bounce, epstein.w, epstein.h);
    }
    ctx.restore();

    // Purple glow aura (re-draw with shadowBlur instead of blocky fillRect)
    ctx.save();
    ctx.globalAlpha = 0.2;
    ctx.shadowColor = '#8844ff';
    ctx.shadowBlur = 25;
    if (epstein.dir < 0) {
      ctx.translate(ex + epstein.w, ey - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(epsteinImg, 0, 0, epstein.w, epstein.h);
    } else {
      ctx.drawImage(epsteinImg, ex, ey - bounce, epstein.w, epstein.h);
    }
    ctx.shadowBlur = 0;
    ctx.restore();

    // Phase label
    const epPhaseLabels = { 1: '★ EPSTEIN ★', 2: '★★ UNHINGED ★★' };
    ctx.fillStyle = '#ff44ff88';
    ctx.font = 'bold 11px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(epPhaseLabels[epstein.phase] || '', ex + epstein.w/2, ey - 45 - bounce);

    // HP bar
    const eHpPct = epstein.hp / epstein.maxHp;
    ctx.fillStyle = '#000000bb';
    ctx.fillRect(ex - 10, ey - 35 - bounce, epstein.w + 20, 10);
    const eBarGrad = ctx.createLinearGradient(ex - 10, 0, ex + epstein.w + 10, 0);
    eBarGrad.addColorStop(0, '#8844ff');
    eBarGrad.addColorStop(1, '#ff44ff');
    ctx.fillStyle = eBarGrad;
    ctx.fillRect(ex - 10, ey - 35 - bounce, (epstein.w + 20) * eHpPct, 10);

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.ellipse(ex + epstein.w/2, ey + epstein.h + 5, epstein.w/2, 8, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // ── Epstein Projectiles Drawing (spinning files/people/evidence) ──
  for (const ep of epsteinProjectiles) {
    ctx.save();
    ctx.translate(ep.x, ep.y);
    ctx.rotate(ep.rotation);
    // Pick image based on imgIdx — drawn BIGGER, no glow
    const projImg = epProjectileImgs[ep.imgIdx] || epsteinFilesImg;
    try {
      ctx.drawImage(projImg, -ep.size/2, -ep.size/2, ep.size, ep.size);
    } catch(e) {
      ctx.fillStyle = '#cc88ff';
      ctx.fillRect(-ep.size/2, -ep.size/2, ep.size, ep.size);
      ctx.fillStyle = '#fff';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('FILE', 0, 4);
    }
    // Subtle dark outline so they're visible against any background
    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
    ctx.lineWidth = 2;
    ctx.strokeRect(-ep.size/2, -ep.size/2, ep.size, ep.size);
    ctx.restore();
    // Label flash on newer projectiles
    if (ep.life > 150) {
      const labels = ['CLASSIFIED', 'HAWKING??', 'SLICK WILLY', 'MUSK', '...'];
      ctx.fillStyle = `rgba(255,255,255,${(ep.life-150)/30})`;
      ctx.font = 'bold 10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(labels[ep.imgIdx] || '', ep.x, ep.y - ep.size/2 - 8);
    }
  }

  // ── FUSION BOSS Drawing ──
  if (fusionBoss && !fusionBoss.dead) {
    const fx = fusionBoss.x, fy = fusionBoss.y;
    const fb = fusionBoss;
    const bounce = Math.sin(fb.frame * Math.PI / 2) * 4;
    const t = Date.now() / 1000;

    // Dual-color aura (red + purple merged)
    const auraSize = 60 + Math.sin(t*3) * 15;
    const auraGrad = ctx.createRadialGradient(fx+fb.w/2, fy+fb.h/2, 15, fx+fb.w/2, fy+fb.h/2, fb.w/2 + auraSize);
    auraGrad.addColorStop(0, `rgba(255,100,50,${0.25 + Math.sin(t*4)*0.1})`);
    auraGrad.addColorStop(0.5, `rgba(180,50,200,${0.15 + Math.sin(t*3)*0.05})`);
    auraGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = auraGrad;
    ctx.beginPath();
    ctx.arc(fx + fb.w/2, fy + fb.h/2, fb.w/2 + auraSize, 0, Math.PI * 2);
    ctx.fill();

    // Merge glow (fades over time)
    if (fb.mergeGlow > 0) {
      ctx.fillStyle = `rgba(255,255,200,${fb.mergeGlow * 0.3})`;
      ctx.beginPath();
      ctx.arc(fx + fb.w/2, fy + fb.h/2, fb.w + fb.mergeGlow * 100, 0, Math.PI * 2);
      ctx.fill();
    }

    // Dual rotating energy rings
    ctx.save();
    ctx.translate(fx + fb.w/2, fy + fb.h/2);
    ctx.rotate(t * 1.5);
    ctx.strokeStyle = 'rgba(255,68,0,0.25)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.ellipse(0, 0, fb.w * 0.8, fb.h * 0.3, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.rotate(Math.PI / 2);
    ctx.strokeStyle = 'rgba(136,68,255,0.25)';
    ctx.beginPath();
    ctx.ellipse(0, 0, fb.w * 0.7, fb.h * 0.3, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

    // Draw BOTH Trump and Epstein images side by side (fused — half/half)
    ctx.save();
    // Left half = Trump
    ctx.save();
    ctx.beginPath();
    ctx.rect(fx, fy - bounce, fb.w/2, fb.h);
    ctx.clip();
    ctx.drawImage(bossImg, fx, fy - bounce, fb.w, fb.h);
    ctx.restore();
    // Right half = Epstein
    ctx.save();
    ctx.beginPath();
    ctx.rect(fx + fb.w/2, fy - bounce, fb.w/2, fb.h);
    ctx.clip();
    ctx.drawImage(epsteinImg, fx, fy - bounce, fb.w, fb.h);
    ctx.restore();
    ctx.restore();

    // Crackling merge line down the center 
    ctx.strokeStyle = `rgba(255,255,200,${0.4 + Math.sin(t*8)*0.3})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    const cx = fx + fb.w/2;
    for (let ly = fy - bounce; ly < fy + fb.h - bounce; ly += 8) {
      ctx.lineTo(cx + (Math.random()-0.5) * 8, ly);
    }
    ctx.stroke();

    // Glow overlay (shadow-based, follows cutout shape)
    ctx.save();
    ctx.globalAlpha = 0.15;
    ctx.shadowColor = '#ff4400';
    ctx.shadowBlur = 25;
    // Left half glow (red/orange)
    ctx.save();
    ctx.beginPath();
    ctx.rect(fx, fy - bounce, fb.w/2, fb.h);
    ctx.clip();
    ctx.drawImage(bossImg, fx, fy - bounce, fb.w, fb.h);
    ctx.restore();
    // Right half glow (purple)
    ctx.shadowColor = '#8844ff';
    ctx.save();
    ctx.beginPath();
    ctx.rect(fx + fb.w/2, fy - bounce, fb.w/2, fb.h);
    ctx.clip();
    ctx.drawImage(epsteinImg, fx, fy - bounce, fb.w, fb.h);
    ctx.restore();
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.restore();

    // Name label
    ctx.fillStyle = '#ff884488';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#ff4400';
    ctx.shadowBlur = 10;
    ctx.fillText(fb.phase === 2 ? '★★ TRUMPSTEIN - UNLEASHED ★★' : '★ TRUMPSTEIN ★', fx + fb.w/2, fy - 50 - bounce);
    ctx.shadowBlur = 0;

    // HP bar above
    const fHpPct = fb.hp / fb.maxHp;
    ctx.fillStyle = '#000000bb';
    ctx.fillRect(fx - 15, fy - 40 - bounce, fb.w + 30, 12);
    const fBarGrad = ctx.createLinearGradient(fx - 15, 0, fx + fb.w + 15, 0);
    fBarGrad.addColorStop(0, '#ff4400');
    fBarGrad.addColorStop(0.5, '#ff8844');
    fBarGrad.addColorStop(1, '#8844ff');
    ctx.fillStyle = fBarGrad;
    ctx.fillRect(fx - 15, fy - 40 - bounce, (fb.w + 30) * fHpPct, 12);

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(fx + fb.w/2, fy + fb.h + 5, fb.w/2 + 10, 10, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // ── MINI-BOSS Drawing (Split Fight) ──
  for (const mb of miniBosses) {
    if (mb.dead) continue;
    const mx = mb.x, my = mb.y;
    const bounce = Math.sin(mb.frame * Math.PI / 2) * 2;
    const t = Date.now() / 1000;

    // Color aura — MASSIVE for Hawking Phase 2
    const auraRadius = (mb.name === 'HAWKING' && hawkingPhase2) ? mb.w/2 + 80 : mb.w/2 + 25;
    const mAuraGrad = ctx.createRadialGradient(mx+mb.w/2, my+mb.h/2, 5, mx+mb.w/2, my+mb.h/2, auraRadius);
    mAuraGrad.addColorStop(0, mb.color + ((mb.name === 'HAWKING' && hawkingPhase2) ? '88' : '44'));
    mAuraGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = mAuraGrad;
    ctx.beginPath();
    ctx.arc(mx + mb.w/2, my + mb.h/2, auraRadius, 0, Math.PI * 2);
    ctx.fill();

    // Hawking Phase 2 — extra cosmic effects (GOLD theme)
    if (mb.name === 'HAWKING' && hawkingPhase2) {
      // Orbiting energy rings
      for (let ring = 0; ring < 3; ring++) {
        ctx.save();
        ctx.translate(mx + mb.w/2, my + mb.h/2);
        ctx.rotate(t * (0.5 + ring * 0.3) + ring * Math.PI/3);
        ctx.strokeStyle = `rgba(255,215,0,${0.2 + Math.sin(t*2 + ring)*0.1})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, 0, mb.w/2 + 30 + ring*15, mb.h/4 + ring*8, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
      // Glowing particles orbiting
      for (let op = 0; op < 6; op++) {
        const orbitAngle = t * 2 + op * Math.PI / 3;
        const orbitR = mb.w/2 + 40;
        const opx = mx + mb.w/2 + Math.cos(orbitAngle) * orbitR;
        const opy = my + mb.h/2 + Math.sin(orbitAngle) * orbitR * 0.5;
        ctx.fillStyle = '#ffd700';
        ctx.globalAlpha = 0.5 + Math.sin(t*3 + op)*0.3;
        ctx.beginPath();
        ctx.arc(opx, opy, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      // "TRANSCENDED" label
      ctx.fillStyle = `rgba(255,215,0,${0.6 + Math.sin(t*3)*0.3})`;
      ctx.font = 'bold 11px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('TRANSCENDED', mx + mb.w/2, my - 35 - bounce);
    }

    // Hawking shield barrier when others are alive
    if (mb.name === 'HAWKING') {
      const shieldOthers = miniBosses.filter(m => !m.dead && m.name !== 'HAWKING').length;
      if (shieldOthers > 0) {
        // Rotating hexagonal shield
        ctx.save();
        ctx.translate(mx + mb.w/2, my + mb.h/2);
        ctx.rotate(t * 0.8);
        ctx.strokeStyle = `rgba(255,215,0,${0.3 + Math.sin(t*3)*0.15})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let s = 0; s < 6; s++) {
          const angle = (Math.PI * 2 / 6) * s;
          const sr = mb.w/2 + 20 + Math.sin(t*2 + s)*5;
          const sx = Math.cos(angle) * sr;
          const sy = Math.sin(angle) * sr;
          if (s === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
        // Shield text
        ctx.fillStyle = hawkingPhase2 ? `rgba(255,200,0,${0.4 + Math.sin(t*4)*0.2})` : `rgba(68,255,136,${0.4 + Math.sin(t*4)*0.2})`;
        ctx.font = 'bold 7px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('SHIELDED', mx + mb.w/2, my - 28 - bounce);
      }
    }

    // Draw image based on imgKey
    const mbImgMap = { boss: bossImg, epstein: epsteinImg, musk: muskImg, clinton: clintonImg, hawking: (mb.name === 'HAWKING' && hawkingPhase2) ? hawkingGoldImg : hawkingImg };
    const mbImg = mbImgMap[mb.imgKey] || guardImg;
    ctx.save();
    if (mb.dir < 0) {
      ctx.translate(mx + mb.w, my - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(mbImg, 0, 0, mb.w, mb.h);
    } else {
      ctx.drawImage(mbImg, mx, my - bounce, mb.w, mb.h);
    }
    ctx.restore();

    // Glowing aura behind boss (no blocky tint on transparent images)
    ctx.save();
    ctx.globalAlpha = 0.15 + Math.sin(t*4) * 0.05;
    ctx.shadowColor = mb.color;
    ctx.shadowBlur = 25;
    if (mb.dir < 0) {
      ctx.translate(mx + mb.w, my - bounce);
      ctx.scale(-1, 1);
      ctx.drawImage(mbImg, 0, 0, mb.w, mb.h);
    } else {
      ctx.drawImage(mbImg, mx, my - bounce, mb.w, mb.h);
    }
    ctx.restore();

    // Name label
    ctx.fillStyle = mb.color;
    ctx.font = 'bold 9px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(mb.name, mx + mb.w/2, my - 18 - bounce);

    // HP bar
    const mbHpPct = mb.hp / mb.maxHp;
    ctx.fillStyle = '#00000088';
    ctx.fillRect(mx - 5, my - 12 - bounce, mb.w + 10, 7);
    ctx.fillStyle = mb.color;
    ctx.fillRect(mx - 5, my - 12 - bounce, (mb.w + 10) * mbHpPct, 7);
    ctx.strokeStyle = '#ffffff33';
    ctx.lineWidth = 1;
    ctx.strokeRect(mx - 5, my - 12 - bounce, mb.w + 10, 7);

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath();
    ctx.ellipse(mx + mb.w/2, my + mb.h + 3, mb.w/3, 5, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // ── Boss VFX (rings, cracks, text) ──
  for (const vfx of bossVfx) {
    const alpha = vfx.life / vfx.maxLife;
    if (vfx.type === 'ring') {
      ctx.strokeStyle = vfx.color;
      ctx.globalAlpha = alpha;
      ctx.lineWidth = 3 + alpha * 4;
      ctx.beginPath();
      ctx.arc(vfx.x, vfx.y, vfx.radius, 0, Math.PI * 2);
      ctx.stroke();
      // Inner glow ring
      ctx.globalAlpha = alpha * 0.3;
      ctx.lineWidth = 10 + alpha * 8;
      ctx.beginPath();
      ctx.arc(vfx.x, vfx.y, vfx.radius * 0.95, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    } else if (vfx.type === 'crack') {
      ctx.strokeStyle = `rgba(100,50,0,${alpha})`;
      ctx.lineWidth = 2;
      const cx = vfx.x, cy = vfx.y;
      for (let c = 0; c < 8; c++) {
        const angle = c * Math.PI / 4 + 0.2;
        const len = 40 + c * 15;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        let px = cx, py = cy;
        for (let seg = 0; seg < 4; seg++) {
          px += Math.cos(angle + (Math.random()-0.5)*0.6) * len/4;
          py += Math.sin(angle + (Math.random()-0.5)*0.3) * len/8;
          ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
    } else if (vfx.type === 'text') {
      ctx.globalAlpha = alpha;
      ctx.fillStyle = vfx.color;
      ctx.shadowColor = vfx.color;
      ctx.shadowBlur = 20;
      ctx.font = `bold ${32 + (1-alpha)*20}px monospace`;
      ctx.textAlign = 'center';
      ctx.fillText(vfx.text, vfx.x, vfx.y - (1-alpha)*60);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }
  }

  // Particles
  for (const pt of particles) {
    const pAlpha = pt.life / 40;
    ctx.globalAlpha = pAlpha;
    ctx.fillStyle = pt.color;
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, pt.size / 2, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  ctx.restore();

  // ── Screen Vignette ──
  const vg = ctx.createRadialGradient(W/2, H/2, H * 0.35, W/2, H/2, H * 0.95);
  vg.addColorStop(0, 'rgba(0,0,0,0)');
  vg.addColorStop(1, 'rgba(0,0,0,0.45)');
  ctx.fillStyle = vg;
  ctx.fillRect(0, 0, W, H);

  // ── Low HP red vignette ──
  if (player && player.alive && player.hp / player.maxHp < 0.35) {
    const hpPulse = 0.12 + Math.sin(Date.now() / 300) * 0.06;
    const rvg = ctx.createRadialGradient(W/2, H/2, H * 0.25, W/2, H/2, H * 0.85);
    rvg.addColorStop(0, 'rgba(255,0,0,0)');
    rvg.addColorStop(1, `rgba(255,0,0,${hpPulse})`);
    ctx.fillStyle = rvg;
    ctx.fillRect(0, 0, W, H);
  }

  // ── Screen Flash Effect ──
  if (screenFlash > 0) {
    const flashAlpha = Math.min(0.8, screenFlash / 20);
    ctx.globalAlpha = flashAlpha;
    ctx.fillStyle = screenFlashColor;
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
  }

  // ════════════════════════════════════════════════════════════════
  // HAWKING REFUSAL — Undertale "But it refused." full-screen drawing
  // ════════════════════════════════════════════════════════════════
  if (state === 'hawkingRefusal') {
    const t = hawkingRefusalTimer;
    const cx = W / 2;
    const textY = H * 0.28;  // text above center like Undertale
    const heartY = H * 0.52; // heart below text
    ctx.imageSmoothingEnabled = false;

    // Pure black background — instant
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);

    // ── Pixel heart (Undertale 8x7 grid) ──
    function drawPixelHeart(hx, hy, scale, color, alpha) {
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      const px = [
        [0,1,1,0,0,1,1,0],
        [1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1],
        [0,1,1,1,1,1,1,0],
        [0,0,1,1,1,1,0,0],
        [0,0,0,1,1,0,0,0],
      ];
      const ox = hx - 4 * scale;
      const oy = hy - 3.5 * scale;
      for (let r = 0; r < px.length; r++)
        for (let c = 0; c < px[r].length; c++)
          if (px[r][c]) ctx.fillRect(Math.floor(ox + c * scale), Math.floor(oy + r * scale), scale, scale);
      ctx.globalAlpha = 1;
    }

    const hs = 5; // heart pixel scale (small like reference)

    // Helper: draw split halves with zigzag crack edge
    function drawSplitHeart(sep, shakeX, shakeY) {
      const halfW = 4 * hs;
      const hTop = heartY - 4 * hs;
      const hBot = heartY + 4 * hs;
      // Zigzag crack pattern for clip edges
      const zigW = 3; // zigzag width
      const zigH = hs; // zigzag step height
      
      // Left half with zigzag right edge
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(cx - sep - halfW - 10, hTop - 10);
      ctx.lineTo(cx - sep - halfW - 10, hBot + 10);
      // Zigzag up the right edge
      let zy = hBot + 10;
      while (zy > hTop - 10) {
        ctx.lineTo(cx - sep + zigW, zy - zigH / 2);
        ctx.lineTo(cx - sep - zigW, zy - zigH);
        zy -= zigH;
      }
      ctx.closePath();
      ctx.clip();
      drawPixelHeart(cx - sep + shakeX, heartY + shakeY, hs, '#00ff00', 1);
      ctx.restore();
      
      // Right half with zigzag left edge
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(cx + sep + halfW + 10, hTop - 10);
      ctx.lineTo(cx + sep + halfW + 10, hBot + 10);
      // Zigzag up the left edge
      zy = hBot + 10;
      while (zy > hTop - 10) {
        ctx.lineTo(cx + sep - zigW, zy - zigH / 2);
        ctx.lineTo(cx + sep + zigW, zy - zigH);
        zy -= zigH;
      }
      ctx.closePath();
      ctx.clip();
      drawPixelHeart(cx + sep + shakeX, heartY + shakeY, hs, '#00ff00', 1);
      ctx.restore();
    }

    // Phase 1: Heart appears (t: 60-240)
    if (t >= 60 && t < 240) {
      drawPixelHeart(cx, heartY, hs, '#00ff00', 1);
    }

    // Phase 2: Heart splits apart INSTANTLY (t: 240-380)
    if (t >= 240 && t < 380) {
      const sep = 4; // small separation

      // Shake while split (t: 340-380)
      let shakeX = 0, shakeY = 0;
      if (t >= 340) {
        shakeX = Math.floor(Math.sin(t * 0.8) * 2);
        shakeY = Math.floor(Math.cos(t * 1.1) * 1);
      }

      drawSplitHeart(sep, shakeX, shakeY);

      // Small pixel debris
      if (t % 12 === 0 && t < 320) {
        particles.push({
          x: cx + (Math.random()-0.5)*8, y: heartY,
          vx: (Math.random()-0.5)*1.5, vy: Math.random()*1.5 + 0.5,
          life: 25, color: '#00ff00', size: 3,
        });
      }
      // Jolt on initial crack
      if (t === 240) shakeTimer = Math.max(shakeTimer, 4);
    }

    // Phase 3: Halves snap back together INSTANTLY (t: 380)
    if (t >= 380 && t < 410) {
      drawPixelHeart(cx, heartY, hs, '#00ff00', 1);
      if (t === 380) shakeTimer = Math.max(shakeTimer, 4);
    }

    // Phase 4: Heart whole, brief pause (t: 410-440)
    if (t >= 410 && t < 440) {
      drawPixelHeart(cx, heartY, hs, '#00ff00', 1);
    }

    // Phase 5: "* But it refused." letter by letter ABOVE heart (t: 440-530)
    if (t >= 440 && t < 530) {
      drawPixelHeart(cx, heartY, hs, '#00ff00', 1);

      const text = '* But it refused.';
      const letterDelay = 4;
      const lettersShown = Math.min(text.length, Math.floor((t - 440) / letterDelay));
      const displayText = text.substring(0, lettersShown);

      ctx.fillStyle = '#fff';
      ctx.font = 'bold 32px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(displayText, cx, textY);
    }

    // Phase 6: Text + heart pulse — transitions from green to GOLD (t: 530-620)
    if (t >= 530 && t < 620) {
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 32px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('* But it refused.', cx, textY);

      // Heart color transitions green → gold (slower)
      const goldProgress = Math.min(1, (t - 540) / 60);
      const heartColor = goldProgress < 0.5 ? ((t % 8 < 4) ? '#00ff00' : '#44ff88') : ((t % 6 < 3) ? '#ffd700' : '#ffcc00');
      const heartScale = hs + (goldProgress > 0.5 ? Math.sin(t * 0.15) * 1.5 : 0);
      drawPixelHeart(cx, heartY, heartScale, heartColor, 1);

      if (t > 560) shakeTimer = Math.max(shakeTimer, 2 + Math.floor(goldProgress * 3));

      // Gold energy wisps radiating from heart
      if (goldProgress > 0.5) {
        for (let w = 0; w < 6; w++) {
          const wa = (Date.now()/1000 * 1.5 + w * Math.PI / 3) % (Math.PI * 2);
          const wd = 30 + Math.sin(Date.now()/1000 * 2 + w) * 15;
          ctx.fillStyle = `rgba(255, 215, 0, ${0.2 + Math.sin(Date.now()/1000 * 3 + w) * 0.15})`;
          ctx.beginPath();
          ctx.arc(cx + Math.cos(wa) * wd, heartY + Math.sin(wa) * wd, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      if (t >= 545) {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('The will of a genius cannot be extinguished.', cx, heartY + 50);
      }
    }

    // Phase 7: Close-up of NORMAL Hawking — long dramatic linger (t: 620-780)
    if (t >= 620 && t < 780) {
      const phaseDur = 160;
      const fadeIn = Math.min(1, (t - 620) / 30);
      // Black bg
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
      // Normal Hawking close-up — centered, large, slowly zooming in
      const zoomProg = (t - 620) / phaseDur;
      const hawkSize = Math.min(W * 0.45, 320) + zoomProg * 40;
      const hawkH_val = imgH(hawkingImg, hawkSize);
      ctx.globalAlpha = fadeIn;
      ctx.drawImage(hawkingImg, cx - hawkSize/2, H * 0.2 - zoomProg * 15, hawkSize, hawkH_val);
      ctx.globalAlpha = 1;
      // Name text fades in
      if (t > 660) {
        const textAlpha = Math.min(1, (t - 660) / 25);
        ctx.globalAlpha = textAlpha;
        ctx.fillStyle = '#999';
        ctx.font = 'italic 18px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('Stephen Hawking', cx, H * 0.2 + hawkH_val + 20);
        ctx.globalAlpha = 1;
      }
      // Ominous heartbeat pulse effect
      if (t > 700) {
        const hbPhase = ((t - 700) % 40) / 40;
        if (hbPhase < 0.15) {
          const pulseAlpha = Math.sin(hbPhase / 0.15 * Math.PI) * 0.08;
          ctx.fillStyle = `rgba(255, 215, 0, ${pulseAlpha})`;
          ctx.fillRect(0, 0, W, H);
        }
      }
      // Start light shake toward end, building
      if (t > 740) {
        const shk = ((t - 740) / 40) * 4;
        shakeTimer = Math.max(shakeTimer, Math.ceil(shk));
      }
      // Faint gold cracks appear at very end
      if (t > 760) {
        const earlyProg = (t - 760) / 20;
        const crackN = Math.floor(earlyProg * 4);
        for (let c = 0; c < crackN; c++) {
          ctx.strokeStyle = `rgba(255, 215, 0, ${0.15 + Math.random() * 0.1})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          const sx = cx + (Math.sin(c * 5.3) * 0.3) * W;
          const sy = H * 0.35 + Math.cos(c * 3.7) * H * 0.2;
          ctx.moveTo(sx, sy);
          for (let s = 0; s < 3; s++) {
            ctx.lineTo(sx + (Math.random()-0.5) * 60, sy + (Math.random()-0.5) * 50);
          }
          ctx.stroke();
        }
      }
    }

    // Phase 8: VIOLENT SHAKE + golden flash takeover (t: 780-920)
    if (t >= 780 && t < 920) {
      const flashProg = (t - 780) / 140;
      // Black bg with intensifying gold
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
      // Hawking still visible but shaking violently, slowly consumed by gold
      const hawkSize = Math.min(W * 0.45, 320);
      const hawkH_val = imgH(hawkingImg, hawkSize);
      if (flashProg < 0.4) {
        ctx.globalAlpha = 1 - flashProg * 2;
        ctx.drawImage(hawkingImg, cx - hawkSize/2, H * 0.2, hawkSize, hawkH_val);
        ctx.globalAlpha = 1;
      }
      // Gold energy cracks spreading across screen — more over time
      const crackCount = Math.floor(flashProg * 20);
      for (let c = 0; c < crackCount; c++) {
        ctx.strokeStyle = `rgba(255, 215, 0, ${0.2 + Math.random() * 0.4})`;
        ctx.lineWidth = 1 + Math.random() * 3 + flashProg * 2;
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 15 + flashProg * 25;
        ctx.beginPath();
        const startX = cx + (Math.sin(c * 7.3 + flashProg * 2) * 0.5) * W;
        const startY = H * 0.4 + Math.cos(c * 4.1) * H * 0.3;
        ctx.moveTo(startX, startY);
        for (let s = 0; s < 6; s++) {
          ctx.lineTo(startX + (Math.random()-0.5) * 140 * (s+1)/3, startY + (Math.random()-0.5) * 110 * (s+1)/3);
        }
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
      // Golden flash builds from center — slow expansion
      const flashGrad = ctx.createRadialGradient(cx, H * 0.4, 0, cx, H * 0.4, W * flashProg * 0.8);
      flashGrad.addColorStop(0, `rgba(255, 215, 0, ${flashProg * 0.7})`);
      flashGrad.addColorStop(0.5, `rgba(255, 200, 0, ${flashProg * 0.3})`);
      flashGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = flashGrad;
      ctx.fillRect(0, 0, W, H);
      // Increasingly violent shaking
      shakeTimer = Math.max(shakeTimer, Math.ceil(5 + flashProg * 15));
      // Deep rumble — screen flickers
      if (flashProg > 0.5 && Math.random() < flashProg * 0.3) {
        ctx.fillStyle = `rgba(255, 200, 0, ${Math.random() * 0.08})`;
        ctx.fillRect(0, 0, W, H);
      }
      // Final blinding flash at end
      if (flashProg > 0.85) {
        ctx.fillStyle = `rgba(255, 230, 100, ${(flashProg - 0.85) / 0.15})`;
        ctx.fillRect(0, 0, W, H);
      }
    }

    // Phase 9: GOLDEN HAWKING REVEALED — slow, intimidating (t: 920-1120)
    if (t >= 920 && t < 1120) {
      const revealProg = (t - 920) / 200;
      // White/gold flash fading to black
      const bgFade = Math.min(1, revealProg * 2);
      if (revealProg < 0.2) {
        ctx.fillStyle = `rgba(255, 230, 100, ${1 - revealProg * 5})`;
        ctx.fillRect(0, 0, W, H);
      }
      ctx.fillStyle = `rgba(0, 0, 0, ${bgFade})`;
      ctx.fillRect(0, 0, W, H);
      // Golden Hawking — larger, with radiating gold aura
      const hawkSize = Math.min(W * 0.5, 350);
      const hawkH_val = imgH(hawkingGoldImg, hawkSize);
      const hawkAlpha = Math.min(1, revealProg * 3);
      // Multi-layered golden aura
      for (let a = 0; a < 3; a++) {
        const aRad = hawkSize * (0.8 + a * 0.4) + Math.sin(Date.now()/1000 * 2 + a) * 10;
        const aGrad = ctx.createRadialGradient(cx, H * 0.35 + hawkH_val * 0.4, 10, cx, H * 0.35 + hawkH_val * 0.4, aRad);
        aGrad.addColorStop(0, `rgba(255, 215, 0, ${(0.2 - a * 0.05) * hawkAlpha})`);
        aGrad.addColorStop(0.6, `rgba(255, 180, 0, ${(0.08 - a * 0.02) * hawkAlpha})`);
        aGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = aGrad;
        ctx.beginPath();
        ctx.arc(cx, H * 0.35 + hawkH_val * 0.4, aRad, 0, Math.PI * 2);
        ctx.fill();
      }
      // The golden figure
      ctx.globalAlpha = hawkAlpha;
      ctx.shadowColor = '#ffd700';
      ctx.shadowBlur = 40 + revealProg * 40;
      ctx.drawImage(hawkingGoldImg, cx - hawkSize/2, H * 0.2, hawkSize, hawkH_val);
      ctx.drawImage(hawkingGoldImg, cx - hawkSize/2, H * 0.2, hawkSize, hawkH_val);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      // "TRANSCENDED" text — appears early, stays
      if (revealProg > 0.2) {
        const tAlpha = Math.min(1, (revealProg - 0.2) / 0.2);
        ctx.globalAlpha = tAlpha;
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 30px monospace';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 25;
        ctx.fillText('T R A N S C E N D E D', cx, H * 0.1);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }
      // Threatening dialogue — typewriter, appears after reveal settles
      if (revealProg > 0.4) {
        const dlgProg = (revealProg - 0.4) / 0.6;
        const quotes = [
          { at: 0.0, text: '"You thought you could kill me?"', y: 0.78 },
          { at: 0.35, text: '"I have conquered death itself."', y: 0.84 },
          { at: 0.7, text: '"Now... face a GOD."', y: 0.90, bold: true },
        ];
        for (const q of quotes) {
          if (dlgProg >= q.at) {
            const qProg = Math.min(1, (dlgProg - q.at) / 0.2);
            const showLen = Math.floor(q.text.length * Math.min(1, qProg * 3));
            ctx.globalAlpha = Math.min(1, qProg * 2);
            ctx.fillStyle = q.bold ? '#ffd700' : '#dddddd';
            ctx.font = q.bold ? 'bold 24px monospace' : '18px monospace';
            ctx.textAlign = 'center';
            if (q.bold) { ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 15; }
            ctx.fillText(q.text.substring(0, showLen), cx, H * q.y);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          }
        }
      }
      // Energy rings pulsing outward from golden Hawking
      if (revealProg > 0.15) {
        const ringT = Date.now()/1000;
        for (let r = 0; r < 4; r++) {
          const rPhase = ((ringT * 0.6 + r * 0.25) % 1);
          const rRadius = 30 + rPhase * 300;
          ctx.strokeStyle = `rgba(255, 215, 0, ${(1 - rPhase) * 0.2})`;
          ctx.lineWidth = 2 * (1 - rPhase);
          ctx.beginPath();
          ctx.arc(cx, H * 0.35 + hawkH_val * 0.3, rRadius, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
      // Gold particles floating upward — more of them
      if (revealProg > 0.1) {
        for (let gp = 0; gp < 20; gp++) {
          const gpT = Date.now()/1000;
          const gpx = cx + Math.sin(gpT * 1.2 + gp * 0.31) * hawkSize * 0.8;
          const gpy = H * 0.9 - ((gpT * 30 + gp * 25) % (H * 0.75));
          ctx.fillStyle = `rgba(255, 215, 0, ${0.2 + Math.sin(gpT * 3 + gp) * 0.15})`;
          ctx.beginPath();
          ctx.arc(gpx, gpy, 1.5 + Math.sin(gpT * 2 + gp) * 1, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    ctx.imageSmoothingEnabled = true;

    // SKIP button
    ctx.fillStyle = '#ffffff22';
    ctx.fillRect(W - 110, 8, 100, 28);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 110, 8, 100, 28);
    ctx.fillStyle = '#aaa';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SKIP \u25b6\u25b6', W - 60, 27);
  }

  // ════════════════════════════════════════════════════════════════
  // HAWKING DEATH — Epic cinematic death scene drawing
  // ════════════════════════════════════════════════════════════════
  if (state === 'hawkingDeath') {
    const dt = hawkingDeathTimer;
    const hawk = miniBosses.find(m => m.name === 'HAWKING');
    const hx = hawk ? hawk._deathX || W/2 : W/2;
    const hy = hawk ? hawk._deathY || H/2 : H/2;
    const t = Date.now() / 1000;

    // Phase 1 (0-80): TIME FREEZE — dramatic slow-mo distortion
    if (dt < 80) {
      const freezeProg = dt / 80;
      // Darken arena progressively
      ctx.fillStyle = `rgba(0,0,0,${freezeProg * 0.6})`;
      ctx.fillRect(0, 0, W, H);
      // Radial green distortion from Hawking
      const distGrad = ctx.createRadialGradient(hx, hy, 10, hx, hy, 300 + freezeProg * 200);
      distGrad.addColorStop(0, `rgba(255,200,0,${0.15 * freezeProg})`);
      distGrad.addColorStop(0.4, `rgba(255,200,0,${0.05 * freezeProg})`);
      distGrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = distGrad;
      ctx.fillRect(0, 0, W, H);
      // Glitch lines
      if (dt > 30) {
        const glitchN = Math.floor((dt - 30) / 5);
        for (let g = 0; g < glitchN; g++) {
          const gy = ((g * 97 + dt * 7) % H);
          const gw = 50 + Math.random() * 200;
          ctx.fillStyle = `rgba(255,200,0,${0.1 + Math.random() * 0.15})`;
          ctx.fillRect(Math.random() * W, gy, gw, 2);
        }
      }
      // "TIME DISTORTION" text
      if (dt > 40) {
        ctx.globalAlpha = Math.sin((dt - 40) / 40 * Math.PI);
        ctx.fillStyle = '#ffd700';
        ctx.font = `bold ${14 + Math.sin(t * 10) * 2}px monospace`;
        ctx.textAlign = 'center';
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 20;
        ctx.fillText('CRITICAL MASS REACHED', W/2, H * 0.15);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }
    }

    // Phase 2 (80-200): HAWKING RISES — levitation with energy eruption
    if (dt >= 80 && dt < 200) {
      const riseProg = (dt - 80) / 120;
      // Nearly full black
      ctx.fillStyle = `rgba(0,0,0,${0.7 + riseProg * 0.2})`;
      ctx.fillRect(0, 0, W, H);
      // Massive green/white energy column from below
      const colW = 60 + riseProg * 120;
      const colGrad = ctx.createLinearGradient(hx - colW/2, H, hx + colW/2, hy - 200);
      colGrad.addColorStop(0, 'rgba(255,200,0,0)');
      colGrad.addColorStop(0.3, `rgba(255,200,0,${0.2 + riseProg * 0.3})`);
      colGrad.addColorStop(0.6, `rgba(136,255,204,${0.15 + riseProg * 0.25})`);
      colGrad.addColorStop(1, `rgba(255,255,255,${riseProg * 0.3})`);
      ctx.fillStyle = colGrad;
      ctx.fillRect(hx - colW/2, hy - 200, colW, H - hy + 200);
      // Draw Hawking floating up
      if (hawk) {
        const floatY = hy - 100 * riseProg;
        const hSize = 120 + riseProg * 40;
        const hH = imgH(hawkingImg, hSize);
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 30 + riseProg * 60;
        ctx.drawImage(hawkingGoldImg, hx - hSize/2, floatY - hH/2, hSize, hH);
        ctx.shadowBlur = 0;
        ctx.restore();
      }
      // Energy rings expanding outward
      const ringCount = Math.floor(riseProg * 6);
      for (let r = 0; r < ringCount; r++) {
        const rProg = ((t * 0.8 + r * 0.3) % 1);
        const rRadius = 50 + rProg * 350;
        ctx.strokeStyle = `rgba(255,200,0,${(1-rProg) * 0.3})`;
        ctx.lineWidth = 3 * (1 - rProg);
        ctx.beginPath();
        ctx.arc(hx, hy - 100 * riseProg, rRadius, 0, Math.PI * 2);
        ctx.stroke();
      }
      // Floating particles sucked inward then exploding out
      for (let p = 0; p < 8; p++) {
        const pa = (t * 2 + p * 0.785) % (Math.PI * 2);
        const pd = 100 + Math.sin(t * 3 + p) * 40;
        const px = hx + Math.cos(pa) * pd;
        const py = (hy - 100 * riseProg) + Math.sin(pa) * pd * 0.6;
        ctx.fillStyle = `rgba(255,200,0,${0.4 + Math.sin(t*5+p)*0.2})`;
        ctx.beginPath();
        ctx.arc(px, py, 2 + Math.sin(t*4+p)*1, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Phase 3 (200-400): REALITY CRACKS — space-time tears, cosmic energy
    if (dt >= 200 && dt < 400) {
      const crackProg = (dt - 200) / 200;
      // Deep black background
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
      // Star field appearing — cosmos becoming visible
      const starCount = Math.floor(crackProg * 120);
      for (let s = 0; s < starCount; s++) {
        const sx = (s * 73.7 + s * s * 3.1) % W;
        const sy = (s * 47.3 + s * 11.7) % H;
        const twinkle = 0.2 + Math.sin(t * 3 + s * 2) * 0.15;
        ctx.fillStyle = `rgba(255,255,255,${twinkle * crackProg})`;
        const sSize = s % 11 === 0 ? 3 : (s % 5 === 0 ? 2 : 1);
        ctx.fillRect(sx, sy, sSize, sSize);
      }
      // Reality crack lines — jagged tears in space
      const crackCount = Math.floor(crackProg * 8);
      for (let c = 0; c < crackCount; c++) {
        const cStartX = (c * 157 + 100) % W;
        const cStartY = (c * 211 + 80) % H;
        ctx.strokeStyle = `rgba(255,200,0,${0.4 + Math.sin(t*4+c)*0.2})`;
        ctx.lineWidth = 2 + Math.sin(t * 6 + c) * 1;
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.moveTo(cStartX, cStartY);
        for (let seg = 0; seg < 6; seg++) {
          ctx.lineTo(
            cStartX + (Math.random()-0.5) * 150 * (seg+1)/3,
            cStartY + seg * 30 + (Math.random()-0.5) * 40
          );
        }
        ctx.stroke();
        ctx.shadowBlur = 0;
        // Bright glow at crack origin
        const crGlow = ctx.createRadialGradient(cStartX, cStartY, 0, cStartX, cStartY, 30);
        crGlow.addColorStop(0, `rgba(255,200,0,${0.3 * (1 - crackProg * 0.5)})`);
        crGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = crGlow;
        ctx.fillRect(cStartX - 30, cStartY - 30, 60, 60);
      }
      // Hawking still visible, dissolving
      if (hawk) {
        const dissolve = Math.min(1, crackProg * 1.5);
        const floatY = hy - 120 - Math.sin(t * 0.5) * 20;
        const hSize = 160 - crackProg * 40;
        const hH = imgH(hawkingGoldImg, hSize);
        ctx.save();
        ctx.globalAlpha = Math.max(0, 1 - dissolve);
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 40 + crackProg * 80;
        ctx.drawImage(hawkingGoldImg, hx - hSize/2, floatY - hH/2, hSize, hH);
        ctx.shadowBlur = 0;
        ctx.restore();
        // Energy aura where Hawking was
        const auraGrad = ctx.createRadialGradient(hx, floatY, 10, hx, floatY, 200);
        auraGrad.addColorStop(0, `rgba(255,200,0,${0.3 + dissolve * 0.3})`);
        auraGrad.addColorStop(0.4, `rgba(255,200,0,${0.1})`);
        auraGrad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = auraGrad;
        ctx.beginPath();
        ctx.arc(hx, floatY, 200, 0, Math.PI * 2);
        ctx.fill();
      }
      // Chromatic aberration bars
      if (crackProg > 0.5 && Math.random() < crackProg * 0.3) {
        const barY = Math.random() * H;
        ctx.fillStyle = `rgba(255,200,0,${Math.random() * 0.1})`;
        ctx.fillRect(0, barY, W, 2 + Math.random() * 4);
      }
    }

    // Phase 4 (400-550): DISINTEGRATION — body breaks into constellation
    if (dt >= 400 && dt < 550) {
      const disProg = (dt - 400) / 150;
      // Deep space background
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
      // Full star field
      for (let s = 0; s < 150; s++) {
        const sx = (s * 73.7 + s * s * 3.1) % W;
        const sy = (s * 47.3 + s * 11.7) % H;
        const twinkle = 0.15 + Math.sin(t * 2.5 + s * 1.5) * 0.12;
        ctx.fillStyle = `rgba(255,255,255,${twinkle})`;
        ctx.fillRect(sx, sy, s % 7 === 0 ? 2 : 1, s % 7 === 0 ? 2 : 1);
      }
      // Supernova explosion at center — concentric rings
      const novaCenter = { x: hx, y: hy - 120 };
      const novaR = disProg * 400;
      for (let nr = 0; nr < 4; nr++) {
        const nrR = novaR * (0.3 + nr * 0.2);
        const nrAlpha = Math.max(0, (1 - disProg) * 0.4 - nr * 0.08);
        ctx.strokeStyle = `rgba(255,200,0,${nrAlpha})`;
        ctx.lineWidth = 4 - nr;
        ctx.beginPath();
        ctx.arc(novaCenter.x, novaCenter.y, nrR, 0, Math.PI * 2);
        ctx.stroke();
      }
      // Central bright glow fading
      const novaGlow = ctx.createRadialGradient(novaCenter.x, novaCenter.y, 0, novaCenter.x, novaCenter.y, 100 * (1 - disProg * 0.5));
      novaGlow.addColorStop(0, `rgba(255,255,255,${(1 - disProg) * 0.6})`);
      novaGlow.addColorStop(0.3, `rgba(255,200,0,${(1 - disProg) * 0.3})`);
      novaGlow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = novaGlow;
      ctx.beginPath();
      ctx.arc(novaCenter.x, novaCenter.y, 100, 0, Math.PI * 2);
      ctx.fill();
      // Constellation dots forming from the explosion — scattered outward
      const constellationPts = 30;
      for (let cp = 0; cp < constellationPts; cp++) {
        const cpAngle = (cp / constellationPts) * Math.PI * 2 + Math.sin(cp * 3) * 0.5;
        const cpDist = 30 + disProg * (80 + cp * 8);
        const cpx = novaCenter.x + Math.cos(cpAngle) * cpDist;
        const cpy = novaCenter.y + Math.sin(cpAngle) * cpDist * 0.7;
        if (cpx < 0 || cpx > W || cpy < 0 || cpy > H) continue;
        const cpAlpha = Math.min(1, disProg * 3) * (0.3 + Math.sin(t * 2 + cp) * 0.2);
        ctx.fillStyle = `rgba(255,200,0,${cpAlpha})`;
        const cpSize = cp % 4 === 0 ? 4 : 2;
        ctx.beginPath();
        ctx.arc(cpx, cpy, cpSize, 0, Math.PI * 2);
        ctx.fill();
        // Glow around larger dots
        if (cp % 4 === 0) {
          ctx.fillStyle = `rgba(255,200,0,${cpAlpha * 0.3})`;
          ctx.beginPath();
          ctx.arc(cpx, cpy, 10, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      // Connect some constellation points with faint lines
      if (disProg > 0.4) {
        ctx.strokeStyle = `rgba(255,200,0,${(disProg - 0.4) * 0.15})`;
        ctx.lineWidth = 1;
        for (let lp = 0; lp < constellationPts - 1; lp += 3) {
          const a1 = (lp / constellationPts) * Math.PI * 2 + Math.sin(lp * 3) * 0.5;
          const d1 = 30 + disProg * (80 + lp * 8);
          const a2 = ((lp+3) / constellationPts) * Math.PI * 2 + Math.sin((lp+3) * 3) * 0.5;
          const d2 = 30 + disProg * (80 + (lp+3) * 8);
          ctx.beginPath();
          ctx.moveTo(novaCenter.x + Math.cos(a1)*d1, novaCenter.y + Math.sin(a1)*d1*0.7);
          ctx.lineTo(novaCenter.x + Math.cos(a2)*d2, novaCenter.y + Math.sin(a2)*d2*0.7);
          ctx.stroke();
        }
      }
    }

    // Phase 5 (550-750): COSMIC MOMENT — equation + final words
    if (dt >= 550 && dt < 750) {
      const cosmicProg = (dt - 550) / 200;
      // Deep space
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
      // Stars slowly drifting
      for (let s = 0; s < 100; s++) {
        const sx = ((s * 73.7 + s * s * 3.1) + t * 5) % W;
        const sy = (s * 47.3 + s * 11.7) % H;
        ctx.fillStyle = `rgba(255,255,255,${0.15 + Math.sin(t + s) * 0.1})`;
        ctx.fillRect(sx, sy, 1, 1);
      }
      // Scattered constellation dots still visible, slowly fading outward
      for (let cp = 0; cp < 20; cp++) {
        const cpAngle = (cp / 20) * Math.PI * 2;
        const cpDist = 200 + cosmicProg * 50 + Math.sin(t * 0.5 + cp) * 20;
        const cpx = hx + Math.cos(cpAngle) * cpDist;
        const cpy = (hy - 120) + Math.sin(cpAngle) * cpDist * 0.7;
        ctx.fillStyle = `rgba(255,200,0,${0.15 * (1 - cosmicProg * 0.5)})`;
        ctx.beginPath();
        ctx.arc(cpx, cpy, 2, 0, Math.PI * 2);
        ctx.fill();
      }

      // E = mc² appearing letter by letter
      if (cosmicProg < 0.4) {
        const eqText = 'E = mc\u00B2';
        const eqProg = cosmicProg / 0.4;
        const charCount = Math.floor(eqText.length * eqProg);
        ctx.fillStyle = `rgba(255,221,68,${eqProg})`;
        ctx.font = `bold ${40 + Math.sin(t * 2) * 3}px monospace`;
        ctx.textAlign = 'center';
        ctx.shadowColor = '#ffdd44';
        ctx.shadowBlur = 25;
        ctx.fillText(eqText.substring(0, charCount), W/2, H * 0.35);
        ctx.shadowBlur = 0;
      } else {
        // Equation fading
        const fadeProg = Math.min(1, (cosmicProg - 0.4) / 0.15);
        ctx.globalAlpha = 1 - fadeProg;
        ctx.fillStyle = '#ffdd44';
        ctx.font = `bold 40px monospace`;
        ctx.textAlign = 'center';
        ctx.shadowColor = '#ffdd44';
        ctx.shadowBlur = 20;
        ctx.fillText('E = mc\u00B2', W/2, H * 0.35);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }

      // Dialogue appearing after equation
      if (cosmicProg > 0.35) {
        const dlgProg = (cosmicProg - 0.35) / 0.65;
        const dialogues = [
          { at: 0.0, text: '"The universe...' },
          { at: 0.3, text: '...finally balanced."' },
          { at: 0.65, text: '- Stephen Hawking' },
        ];
        for (const dlg of dialogues) {
          if (dlgProg >= dlg.at) {
            const dProg = Math.min(1, (dlgProg - dlg.at) / 0.2);
            const isAttrib = dlg.text.startsWith('-');
            ctx.globalAlpha = Math.sin(Math.min(1, dProg) * Math.PI * 0.5);
            ctx.fillStyle = isAttrib ? '#ffd700' : '#ffffff';
            ctx.font = isAttrib ? 'italic 18px monospace' : `${22 + Math.sin(t)*1}px monospace`;
            ctx.textAlign = 'center';
            ctx.shadowColor = isAttrib ? '#ffd700' : '#ffffff';
            ctx.shadowBlur = 12;
            const yOff = isAttrib ? 0.62 : (dlg.at < 0.2 ? 0.48 : 0.55);
            // Typewriter effect
            const fullLen = dlg.text.length;
            const showLen = Math.floor(fullLen * Math.min(1, dProg * 3));
            ctx.fillText(dlg.text.substring(0, showLen), W/2, H * yOff);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          }
        }
      }

      // Gentle green pulse from center
      const pulseR = 100 + Math.sin(t * 1.5) * 30;
      const pulseGrad = ctx.createRadialGradient(W/2, H * 0.45, 0, W/2, H * 0.45, pulseR);
      pulseGrad.addColorStop(0, `rgba(255,200,0,${0.05 + Math.sin(t*2)*0.02})`);
      pulseGrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = pulseGrad;
      ctx.beginPath();
      ctx.arc(W/2, H * 0.45, pulseR, 0, Math.PI * 2);
      ctx.fill();
    }

    // Phase 6 (750-850): WHITE OUT + "HAWKING DEFEATED"
    if (dt >= 750 && dt < 850) {
      const whiteProg = (dt - 750) / 100;
      if (whiteProg < 0.3) {
        // Flash to white
        const flashP = whiteProg / 0.3;
        ctx.fillStyle = `rgba(255,255,255,${flashP})`;
        ctx.fillRect(0, 0, W, H);
      } else if (whiteProg < 0.7) {
        // Hold white with text
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, W, H);
        const textProg = (whiteProg - 0.3) / 0.4;
        ctx.fillStyle = `rgba(0,0,0,${Math.sin(textProg * Math.PI)})`;
        ctx.font = 'bold 48px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('HAWKING DEFEATED', W/2, H * 0.45);
        ctx.fillStyle = `rgba(180,140,40,${Math.sin(textProg * Math.PI) * 0.7})`;
        ctx.font = '18px monospace';
        ctx.fillText('The mind that defied death... rests at last.', W/2, H * 0.55);
      } else {
        // Fade from white to black
        const fadeP = (whiteProg - 0.7) / 0.3;
        const brightness = Math.floor(255 * (1 - fadeP));
        ctx.fillStyle = `rgb(${brightness},${brightness},${brightness})`;
        ctx.fillRect(0, 0, W, H);
      }
    }

    // Phase 7 (850-900): Victory transition
    if (dt >= 850) {
      // Fade to black, player emerges victorious
      const victProg = (dt - 850) / 50;
      ctx.fillStyle = `rgba(0,0,0,${1 - victProg * 0.5})`;
      ctx.fillRect(0, 0, W, H);
      // Golden text
      ctx.globalAlpha = Math.sin(victProg * Math.PI);
      ctx.fillStyle = '#ffdd44';
      ctx.font = 'bold 36px monospace';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#ffdd44';
      ctx.shadowBlur = 30;
      ctx.fillText('\u2605 FREEDOM \u2605', W/2, H * 0.45);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }

    // Letterbox bars throughout
    const barH = 45;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, barH);
    ctx.fillRect(0, H - barH, W, barH);
    ctx.strokeStyle = '#ffd70044';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(0, barH); ctx.lineTo(W, barH); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, H - barH); ctx.lineTo(W, H - barH); ctx.stroke();

    // Vignette
    const vigGrad = ctx.createRadialGradient(W/2, H/2, H*0.2, W/2, H/2, H*0.9);
    vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
    vigGrad.addColorStop(1, `rgba(0,0,0,${Math.min(0.5, dt / 200)})`);
    ctx.fillStyle = vigGrad;
    ctx.fillRect(0, 0, W, H);

    // SKIP button
    ctx.fillStyle = '#ffffff22';
    ctx.fillRect(W - 110, 8, 100, 28);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 110, 8, 100, 28);
    ctx.fillStyle = '#aaa';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SKIP \u25b6\u25b6', W - 60, 27);
  }

  // ════════════════════════════════════════════════════════════════
  // WIN CUTSCENE — Walking to citizenship office + THE END
  // ════════════════════════════════════════════════════════════════
  if (state === 'winCutscene') {
    const wt = winCutsceneTimer;
    
    // Office position in screen coords (world X minus camera)
    const officeScreenX = winCutsceneOfficeX - cameraX;
    const officeY = GROUND_Y - 200;
    
    // Building body
    ctx.fillStyle = '#4a3c2e';
    ctx.fillRect(officeScreenX, officeY, 180, 200);
    
    // Roof
    ctx.fillStyle = '#2a1c0e';
    ctx.beginPath();
    ctx.moveTo(officeScreenX - 20, officeY);
    ctx.lineTo(officeScreenX + 90, officeY - 60);
    ctx.lineTo(officeScreenX + 200, officeY);
    ctx.closePath();
    ctx.fill();
    
    // Door
    ctx.fillStyle = '#1a140a';
    ctx.fillRect(officeScreenX + 65, officeY + 120, 50, 80);
    // Door handle
    ctx.fillStyle = '#ffdd44';
    ctx.beginPath();
    ctx.arc(officeScreenX + 105, officeY + 160, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Windows (warm glow)
    ctx.fillStyle = '#ffeeaa';
    ctx.fillRect(officeScreenX + 20, officeY + 40, 40, 50);
    ctx.fillRect(officeScreenX + 120, officeY + 40, 40, 50);
    // Window frames
    ctx.strokeStyle = '#2a1c0e';
    ctx.lineWidth = 2;
    ctx.strokeRect(officeScreenX + 20, officeY + 40, 40, 50);
    ctx.strokeRect(officeScreenX + 120, officeY + 40, 40, 50);
    // Cross panes
    ctx.beginPath();
    ctx.moveTo(officeScreenX + 40, officeY + 40); ctx.lineTo(officeScreenX + 40, officeY + 90);
    ctx.moveTo(officeScreenX + 20, officeY + 65); ctx.lineTo(officeScreenX + 60, officeY + 65);
    ctx.moveTo(officeScreenX + 140, officeY + 40); ctx.lineTo(officeScreenX + 140, officeY + 90);
    ctx.moveTo(officeScreenX + 120, officeY + 65); ctx.lineTo(officeScreenX + 160, officeY + 65);
    ctx.stroke();
    
    // Sign board
    ctx.fillStyle = '#1a4480';
    ctx.fillRect(officeScreenX + 25, officeY + 100, 130, 22);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('CITIZENSHIP OFFICE', officeScreenX + 90, officeY + 115);
    
    // American flag on pole
    const flagX = officeScreenX + 170, flagY = officeY - 80;
    ctx.fillStyle = '#654321';
    ctx.fillRect(flagX, flagY, 3, 80); // pole
    // Flag body
    const fW = 32, fH = 20;
    // Stripes
    for (let s = 0; s < 7; s++) {
      ctx.fillStyle = s % 2 === 0 ? '#cc0000' : '#ffffff';
      ctx.fillRect(flagX + 3, flagY + s * (fH / 7), fW, fH / 7);
    }
    // Blue canton
    ctx.fillStyle = '#0044aa';
    ctx.fillRect(flagX + 3, flagY, fW * 0.45, fH * 0.57);
    
    // Phase 2 (300+): Player enters door, fade out
    if (wt >= 300 && wt < 350) {
      // Player fades as they enter
      // (the player is already drawn by main draw — we overlay a fade)
    }
    
    // Phase 3: Fade to black
    if (wt >= 350) {
      const fadeP = Math.min(1, (wt - 350) / 100);
      ctx.fillStyle = `rgba(0,0,0,${fadeP})`;
      ctx.fillRect(0, 0, W, H);
    }
    
    // Phase 4: "THE END" text on black
    if (wt >= 480) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
      
      const textProg = Math.min(1, (wt - 480) / 60);
      ctx.globalAlpha = textProg;
      ctx.fillStyle = '#ffdd44';
      ctx.font = 'bold 56px monospace';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#ffdd44';
      ctx.shadowBlur = 20;
      ctx.fillText('THE END', W/2, H/2 - 20);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      
      // Subtitle
      if (wt >= 540) {
        const subProg = Math.min(1, (wt - 540) / 40);
        ctx.globalAlpha = subProg;
        ctx.fillStyle = '#88ccff';
        ctx.font = '18px monospace';
        ctx.fillText('Thank you for playing', W/2, H/2 + 30);
        ctx.globalAlpha = 1;
      }
      
      // Timer
      if (wt >= 580 && settings.showTimer) {
        const tProg = Math.min(1, (wt - 580) / 40);
        ctx.globalAlpha = tProg * 0.7;
        ctx.fillStyle = '#aaa';
        ctx.font = '14px monospace';
        const mins = Math.floor(gameTimer / 3600);
        const secs = Math.floor((gameTimer % 3600) / 60);
        ctx.fillText(`Time: ${mins}:${secs.toString().padStart(2, '0')}`, W / 2, H / 2 + 60);
        ctx.globalAlpha = 1;
      }
      
      // Subtitle 2
      if (wt >= 620) {
        const credProg = Math.min(1, (wt - 620) / 40);
        ctx.globalAlpha = credProg * 0.6;
        ctx.fillStyle = '#666';
        ctx.font = '12px monospace';
        ctx.fillText('A game about perseverance', W/2, H/2 + 90);
        ctx.globalAlpha = 1;
      }
    }
    
    // Letterbox bars throughout
    const barH = 45;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, barH);
    ctx.fillRect(0, H - barH, W, barH);
    
    // SKIP button
    ctx.fillStyle = '#ffffff22';
    ctx.fillRect(W - 110, 8, 100, 28);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 110, 8, 100, 28);
    ctx.fillStyle = '#aaa';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SKIP \u25b6\u25b6', W - 60, 27);
  }

  // ── Boss intro overlay ──
  if (bossIntroTimer > 60) {
    const introFade = (bossIntroTimer - 60) / 30;
    ctx.fillStyle = `rgba(255,255,255,${introFade})`;
    ctx.fillRect(0, 0, W, H);
  }

  // ── Cinematic letterbox bars during boss intro ──
  if (inBossFight && bossIntroTimer > 0) {
    const barH = 50 * Math.min(1, bossIntroTimer / 30);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, barH);
    ctx.fillRect(0, H - barH, W, barH);
  }

  // ── Vignette during bossfight — sewer darkness ──
  if (inBossFight) {
    const bPhase = boss ? boss.phase : 1;
    const isEpstein = state === 'epsteinfight' || state === 'phonecall';
    const isFusion = state === 'fusioncutscene' || state === 'fusionfight';
    const isSplit = state === 'splitfight';
    const vigGrad = ctx.createRadialGradient(W/2, H/2, H*0.3, W/2, H/2, H*0.8);
    vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
    if (isFusion) {
      vigGrad.addColorStop(0.7, 'rgba(30,10,0,0.35)');
      vigGrad.addColorStop(1, 'rgba(60,10,30,0.6)');
    } else if (isSplit) {
      vigGrad.addColorStop(0.7, 'rgba(10,10,30,0.3)');
      vigGrad.addColorStop(1, 'rgba(20,10,50,0.5)');
    } else if (isEpstein) {
      vigGrad.addColorStop(0.7, 'rgba(20,0,30,0.3)');
      vigGrad.addColorStop(1, 'rgba(40,0,60,0.55)');
    } else {
      vigGrad.addColorStop(0.7, bPhase === 3 ? 'rgba(30,5,0,0.3)' : 'rgba(0,10,5,0.25)');
      vigGrad.addColorStop(1, bPhase === 3 ? 'rgba(60,0,0,0.6)' : 'rgba(0,15,5,0.5)');
    }
    ctx.fillStyle = vigGrad;
    ctx.fillRect(0, 0, W, H);
  }

  // ── Phone Call Cutscene Drawing ──
  if (state === 'phonecall') {
    // Dark overlay
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);

    // Phone ringing effect — pulsing circles
    const pulse = Math.sin(Date.now() / 200) * 0.5 + 0.5;
    const ringColor = `rgba(255,200,0,${pulse * 0.3})`;
    ctx.strokeStyle = ringColor;
    ctx.lineWidth = 3;
    for (let r = 0; r < 3; r++) {
      const ringR = 30 + r * 25 + pulse * 10;
      ctx.beginPath();
      ctx.arc(W/2, H/2 - 60, ringR, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Trump sprite on left holding phone
    const trumpX = W * 0.25 - 60;
    const trumpY = H * 0.3;
    ctx.save();
    ctx.shadowColor = '#ff8800';
    ctx.shadowBlur = 20;
    ctx.drawImage(bossIntroImg, trumpX, trumpY, 120, 160);
    ctx.shadowBlur = 0;
    ctx.restore();
    // Phone icon - drawn with canvas (no emoji)
    ctx.fillStyle = '#333';
    ctx.fillRect(trumpX + 105, trumpY + 30, 20, 35);
    ctx.fillStyle = '#4488ff';
    ctx.fillRect(trumpX + 107, trumpY + 33, 16, 29);
    ctx.strokeStyle = '#88ccff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(trumpX + 115, trumpY + 43, 4, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(trumpX + 108, trumpY + 52);
    ctx.lineTo(trumpX + 122, trumpY + 52);
    ctx.stroke();

    // Epstein portrait on right (shadowed/mystery silhouette)
    const epX = W * 0.75 - 50;
    const epY = H * 0.3;
    const epReveal = 1 - (phonecallTimer / 300);
    ctx.save();
    ctx.globalAlpha = 0.3 + epReveal * 0.7;
    ctx.shadowColor = '#8844ff';
    ctx.shadowBlur = 30 * epReveal;
    ctx.drawImage(epsteinImg, epX, epY, 100, 140);
    ctx.shadowBlur = 0;
    ctx.restore();
    // Cover with shadow until revealed
    if (epReveal < 0.6) {
      ctx.fillStyle = `rgba(0,0,0,${0.8 - epReveal})`;
      ctx.fillRect(epX, epY, 100, 140);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 24px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('?', epX + 50, epY + 80);
    }

    // "CALLING..." text
    const dots = '.'.repeat(1 + Math.floor(Date.now() / 400) % 3);
    ctx.fillStyle = '#ffcc00';
    ctx.font = 'bold 28px monospace';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#ff880088';
    ctx.shadowBlur = 10;
    ctx.fillText(`CALLING${dots}`, W/2, H * 0.25);
    ctx.shadowBlur = 0;

    // Phone line connecting them
    ctx.strokeStyle = `rgba(255,200,0,${0.3 + pulse * 0.3})`;
    ctx.lineWidth = 2;
    ctx.setLineDash([8, 8]);
    ctx.beginPath();
    ctx.moveTo(trumpX + 125, trumpY + 50);
    ctx.lineTo(epX, epY + 70);
    ctx.stroke();
    ctx.setLineDash([]);

    // Dialogue text at bottom
    if (bossDialogue.active && bossDialogue.index < bossDialogue.texts.length) {
      const dText = bossDialogue.texts[bossDialogue.index];
      const boxY = H * 0.72;
      ctx.fillStyle = '#000000cc';
      ctx.fillRect(W * 0.1, boxY, W * 0.8, 80);
      ctx.strokeStyle = '#ffcc0066';
      ctx.lineWidth = 2;
      ctx.strokeRect(W * 0.1, boxY, W * 0.8, 80);
      ctx.fillStyle = '#ffcc00';
      ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'left';
      ctx.fillText('TRUMP:', W * 0.13, boxY + 25);
      ctx.fillStyle = '#fff';
      ctx.font = '16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(dText, W/2, boxY + 55);
    }

    // Letterbox bars
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, 40);
    ctx.fillRect(0, H - 40, W, 40);
    
    // SKIP button
    ctx.fillStyle = '#ffffff33';
    ctx.fillRect(W - 110, 8, 100, 28);
    ctx.strokeStyle = '#ffffff55';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 110, 8, 100, 28);
    ctx.fillStyle = '#ccc';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SKIP ▶▶', W - 60, 27);
  }

  // ── HUD ──
  // Distance indicator
  if (state === 'playing' && bigWall) {
    const dist = Math.max(0, bigWall.x - player.x);
    const pct = Math.min(1, 1 - dist / (levelWidth - 280));

    ctx.fillStyle = '#00000088';
    ctx.fillRect(W / 2 - 150, 12, 300, 20);
    ctx.fillStyle = '#333';
    ctx.fillRect(W / 2 - 148, 14, 296, 16);

    const barGrad = ctx.createLinearGradient(W / 2 - 148, 0, W / 2 + 148, 0);
    barGrad.addColorStop(0, '#44aaff');
    barGrad.addColorStop(1, hawkingPhase2 ? '#ffd700' : '#44ff88');
    ctx.fillStyle = barGrad;
    ctx.fillRect(W / 2 - 148, 14, 296 * pct, 16);

    ctx.shadowColor = '#000';
    ctx.shadowBlur = 3;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 11px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`LA FRONTERA: ${Math.floor(pct * 100)}%`, W / 2, 27);
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';

    // Player HP bar (enhanced)
    const hpW = 200;
    ctx.fillStyle = '#00000088';
    ctx.fillRect(20, 12, hpW + 4, 22);
    ctx.fillStyle = '#222';
    ctx.fillRect(22, 14, hpW, 18);
    const phpPct = player.hp / player.maxHp;
    const phpCol = cbHP(phpPct);
    const hpGrad = ctx.createLinearGradient(22, 14, 22, 32);
    hpGrad.addColorStop(0, phpCol.b);
    hpGrad.addColorStop(0.5, phpCol.b);
    hpGrad.addColorStop(1, '#00000044');
    ctx.fillStyle = hpGrad;
    ctx.fillRect(22, 14, hpW * phpPct, 18);
    // Shimmer
    ctx.fillStyle = '#ffffff18';
    ctx.fillRect(22, 14, hpW * phpPct, 6);
    // Border
    ctx.strokeStyle = '#ffffff33';
    ctx.lineWidth = 1;
    ctx.strokeRect(20, 12, hpW + 4, 22);
    // Text with shadow
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 3;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`HP: ${player.hp}/${player.maxHp}`, 28, 28);
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';

    // Controls reminder
    ctx.fillStyle = '#ffffff55';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(_isTouchDev ? '¡Cuidado! Use on-screen controls' : '← → Move  |  ↑/Space Jump  |  Hold ↑ Climb  |  Click/F Throw  |  ¡Cuidado!', W / 2, H - 10);

    // Boss HP bar on HUD (if boss alive and player near)
    if (boss && !boss.dead) {
      const bossHudW = 250;
      const bHpPct = boss.hp / boss.maxHp;
      ctx.fillStyle = '#00000099';
      ctx.fillRect(W - bossHudW - 30, 12, bossHudW + 10, 26);
      ctx.fillStyle = '#222';
      ctx.fillRect(W - bossHudW - 25, 14, bossHudW, 22);
      ctx.fillStyle = bHpPct > 0.5 ? '#cc2222' : bHpPct > 0.25 ? '#cc6622' : '#ff0000';
      ctx.fillRect(W - bossHudW - 25, 14, bossHudW * bHpPct, 22);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 12px monospace';
      ctx.textAlign = 'right';
      ctx.fillText(`★ TRUMP: ${boss.hp}/${boss.maxHp}`, W - 30, 30);
    }

    // ── Touch Controls (on-screen buttons) ──
    drawTouchButtons();
  }

  // Also show HP bar during bossfight — CINEMATIC HUD
  if (state === 'bossfight') {
    // Player HP — left side with icon
    const hpW = 200;
    ctx.fillStyle = '#00000099';
    ctx.fillRect(15, 8, hpW + 14, 30);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(17, 10, hpW + 10, 26);
    const phpPct = player.hp / player.maxHp;
    const phpCols = cbHP(phpPct);
    const phpGrad = ctx.createLinearGradient(22, 0, 22 + hpW, 0);
    phpGrad.addColorStop(0, phpCols.a);
    phpGrad.addColorStop(1, phpCols.b);
    ctx.fillStyle = phpGrad;
    ctx.fillRect(22, 14, hpW * phpPct, 18);
    // HP shimmer
    ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/200)*0.1+0.1})`;
    ctx.fillRect(22, 14, hpW * phpPct * 0.5, 6);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(22, 14, hpW, 18);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`❤ ${player.hp}/${player.maxHp}`, 28, 29);

    // BOSS HP — full width cinematic bar below player HP
    if (boss && !boss.dead) {
      const bossHudW = Math.min(500, W * 0.6, W - 260);
      const bHpPct = boss.hp / boss.maxHp;
      const barX = Math.max(240, W/2 - bossHudW/2);
      const bossHudY = 44;

      // Background
      ctx.fillStyle = '#000000cc';
      ctx.fillRect(barX - 5, bossHudY, bossHudW + 10, 38);

      // Boss name + phase
      const phaseNames = { 1: 'TRUMP', 2: '★ TRUMP - ENRAGED ★', 3: '★★ TRUMP - FINAL FORM ★★' };
      ctx.fillStyle = boss.phase === 3 ? '#ff2222' : boss.phase === 2 ? '#ff8844' : '#ffcc44';
      ctx.font = `bold ${boss.phase === 3 ? 13 : 12}px monospace`;
      ctx.textAlign = 'center';
      ctx.shadowColor = boss.phase === 3 ? '#ff0000' : '#ff880088';
      ctx.shadowBlur = boss.phase * 4;
      ctx.fillText(phaseNames[boss.phase], W/2, bossHudY + 13);
      ctx.shadowBlur = 0;

      // HP bar
      ctx.fillStyle = '#1a0a0a';
      ctx.fillRect(barX, bossHudY + 17, bossHudW, 16);
      const bossGrad = ctx.createLinearGradient(barX, 0, barX + bossHudW, 0);
      if (bHpPct > 0.6) { bossGrad.addColorStop(0, '#881111'); bossGrad.addColorStop(1, '#cc3333'); }
      else if (bHpPct > 0.25) { bossGrad.addColorStop(0, '#883300'); bossGrad.addColorStop(1, '#ee6600'); }
      else { bossGrad.addColorStop(0, '#990000'); bossGrad.addColorStop(1, '#ff2200'); }
      ctx.fillStyle = bossGrad;
      ctx.fillRect(barX, bossHudY + 17, bossHudW * bHpPct, 16);
      // Shimmer
      ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/150)*0.12+0.08})`;
      ctx.fillRect(barX, bossHudY + 17, bossHudW * bHpPct * 0.4, 5);
      // Phase markers
      ctx.fillStyle = '#ffffff66';
      ctx.fillRect(barX + bossHudW * 0.6, bossHudY + 17, 2, 16);
      ctx.fillRect(barX + bossHudW * 0.25, bossHudY + 17, 2, 16);
      // Border
      ctx.strokeStyle = boss.phase === 3 ? '#ff444488' : '#ff880044';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, bossHudY + 17, bossHudW, 16);
      // HP text
      ctx.fillStyle = '#ffffffcc';
      ctx.font = 'bold 10px monospace';
      ctx.fillText(`${boss.hp} / ${boss.maxHp}`, W/2, bossHudY + 29);
    }

    // Phase indicator text
    if (boss && !boss.dead && boss.phase > 1) {
      ctx.fillStyle = boss.phase === 3 ? '#ff000088' : '#ff660066';
      ctx.font = 'bold 16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`PHASE ${boss.phase}`, W/2, 95);
    }

    // Touch controls during bossfight
    drawTouchButtons();

    ctx.fillStyle = '#ffffff55';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(_isTouchDev ? 'Defeat Trump to cross!' : 'Defeat Trump to cross!  |  Click/F Throw  |  \u2190 \u2192 Move  |  \u2191/Space Jump', W / 2, H - 10);
  }

  // ── Epstein Fight HUD ──
  if (state === 'epsteinfight') {
    // Player HP — left side
    const hpW = 200;
    ctx.fillStyle = '#00000099';
    ctx.fillRect(15, 8, hpW + 14, 30);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(17, 10, hpW + 10, 26);
    const phpPct2 = player.hp / player.maxHp;
    const phpGrad2 = ctx.createLinearGradient(22, 0, 22 + hpW, 0);
    const phpCols2 = cbHP(phpPct2);
    phpGrad2.addColorStop(0, phpCols2.a);
    phpGrad2.addColorStop(1, phpCols2.b);
    ctx.fillStyle = phpGrad2;
    ctx.fillRect(22, 14, hpW * phpPct2, 18);
    ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/200)*0.1+0.1})`;
    ctx.fillRect(22, 14, hpW * phpPct2 * 0.5, 6);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(22, 14, hpW, 18);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`❤ ${player.hp}/${player.maxHp}`, 28, 29);

    // EPSTEIN HP — cinematic bar at top center (purple themed)
    if (epstein && !epstein.dead) {
      const eHudW = Math.min(500, W * 0.5, W - 260);
      const eHpPct = epstein.hp / epstein.maxHp;
      const barX = Math.max(240, W/2 - eHudW/2);

      ctx.fillStyle = '#000000cc';
      ctx.fillRect(barX - 5, 5, eHudW + 10, 38);

      // Boss name
      const ePhaseNames = { 1: 'EPSTEIN', 2: '★ EPSTEIN - UNHINGED ★' };
      ctx.fillStyle = epstein.phase === 2 ? '#ff44ff' : '#aa88ff';
      ctx.font = `bold ${epstein.phase === 2 ? 13 : 12}px monospace`;
      ctx.textAlign = 'center';
      ctx.shadowColor = '#8844ff';
      ctx.shadowBlur = epstein.phase * 6;
      ctx.fillText(ePhaseNames[epstein.phase], W/2, 18);
      ctx.shadowBlur = 0;

      // HP bar
      ctx.fillStyle = '#0a0a1a';
      ctx.fillRect(barX, 22, eHudW, 16);
      const eGrad = ctx.createLinearGradient(barX, 0, barX + eHudW, 0);
      if (eHpPct > 0.5) { eGrad.addColorStop(0, '#442288'); eGrad.addColorStop(1, '#8844ff'); }
      else if (eHpPct > 0.25) { eGrad.addColorStop(0, '#662288'); eGrad.addColorStop(1, '#cc44ff'); }
      else { eGrad.addColorStop(0, '#880044'); eGrad.addColorStop(1, '#ff22ff'); }
      ctx.fillStyle = eGrad;
      ctx.fillRect(barX, 22, eHudW * eHpPct, 16);
      // Shimmer
      ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/150)*0.12+0.08})`;
      ctx.fillRect(barX, 22, eHudW * eHpPct * 0.4, 5);
      // Phase marker
      ctx.fillStyle = '#ffffff66';
      ctx.fillRect(barX + eHudW * 0.4, 22, 2, 16);
      // Border
      ctx.strokeStyle = epstein.phase === 2 ? '#ff44ff88' : '#8844ff44';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, 22, eHudW, 16);
      // HP text
      ctx.fillStyle = '#ffffffcc';
      ctx.font = 'bold 10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`${epstein.hp} / ${epstein.maxHp}`, W/2, 34);
    }

    // Phase indicator
    if (epstein && !epstein.dead && epstein.phase === 2) {
      ctx.fillStyle = '#ff44ff88';
      ctx.font = 'bold 16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('PHASE 2', W/2, 56);
    }

    // Touch controls during epsteinfight
    drawTouchButtons();

    ctx.fillStyle = '#ffffff55';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(_isTouchDev ? 'Defeat Epstein!' : 'Defeat Epstein!  |  Click/F Throw  |  \u2190 \u2192 Move  |  \u2191/Space Jump', W / 2, H - 10);
  }

  // ── Fusion Cutscene Drawing ──
  if (state === 'fusioncutscene') {
    // Dark overlay
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0, 0, W, H);

    const prog = 1 - fusionCutsceneTimer / 360;

    // Energy lines converging to center
    const pulse = Math.sin(Date.now() / 150) * 0.5 + 0.5;
    ctx.strokeStyle = `rgba(255,100,0,${0.2 + pulse * 0.3})`;
    ctx.lineWidth = 2;
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2 + Date.now() / 800;
      const outerR = 300 - prog * 200;
      const innerR = 20 + prog * 30;
      ctx.beginPath();
      ctx.moveTo(W/2 + Math.cos(angle) * outerR, H/2 + Math.sin(angle) * outerR);
      ctx.lineTo(W/2 + Math.cos(angle) * innerR, H/2 + Math.sin(angle) * innerR);
      ctx.stroke();
    }
    // Purple lines too
    ctx.strokeStyle = `rgba(136,68,255,${0.2 + pulse * 0.3})`;
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2 + Date.now() / 800 + Math.PI / 12;
      const outerR = 280 - prog * 180;
      const innerR = 25 + prog * 35;
      ctx.beginPath();
      ctx.moveTo(W/2 + Math.cos(angle) * outerR, H/2 + Math.sin(angle) * outerR);
      ctx.lineTo(W/2 + Math.cos(angle) * innerR, H/2 + Math.sin(angle) * innerR);
      ctx.stroke();
    }

    // Draw Trump and Epstein portraits converging and overlapping
    const portraitSize = Math.min(W * 0.18, 140);
    const separation = (1 - prog) * 180; // Start far apart, merge to center
    const shakeX = prog > 0.7 ? (Math.random() - 0.5) * 8 : 0;
    const shakeY = prog > 0.7 ? (Math.random() - 0.5) * 8 : 0;
    
    // Use same height for both portraits so they match visually
    const portraitH = portraitSize * 1.3;
    
    // Trump portrait (coming from left)
    ctx.save();
    ctx.globalAlpha = 0.7 + prog * 0.3;
    ctx.shadowColor = '#ff4400';
    ctx.shadowBlur = 20 + prog * 30;
    ctx.drawImage(bossIntroImg, W/2 - portraitSize - separation + shakeX, H/2 - portraitH/2 + shakeY, portraitSize, portraitH);
    ctx.restore();
    
    // Epstein portrait (coming from right)
    ctx.save();
    ctx.globalAlpha = 0.7 + prog * 0.3;
    ctx.shadowColor = '#8844ff';
    ctx.shadowBlur = 20 + prog * 30;
    ctx.drawImage(epsteinImg, W/2 + separation + shakeX, H/2 - portraitH/2 + shakeY, portraitSize, portraitH);
    ctx.restore();

    // Center merge glow (intensifies as they get close)
    const glowR = 30 + prog * 120;
    const glowGrad = ctx.createRadialGradient(W/2, H/2, 5, W/2, H/2, glowR);
    glowGrad.addColorStop(0, `rgba(255,200,100,${prog * 0.7})`);
    glowGrad.addColorStop(0.4, `rgba(255,100,50,${prog * 0.5})`);
    glowGrad.addColorStop(0.7, `rgba(136,68,255,${prog * 0.3})`);
    glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.arc(W/2, H/2, glowR, 0, Math.PI * 2);
    ctx.fill();

    // Lightning bolts between them in final phase
    if (prog > 0.5) {
      ctx.strokeStyle = `rgba(255,255,100,${(prog - 0.5) * 2})`;
      ctx.lineWidth = 2;
      for (let b = 0; b < 3; b++) {
        ctx.beginPath();
        let lx = W/2 - separation - 20, ly = H/2 + (b - 1) * 30;
        ctx.moveTo(lx, ly);
        for (let s = 0; s < 4; s++) {
          lx += separation / 2;
          ly += (Math.random() - 0.5) * 40;
          ctx.lineTo(lx, ly);
        }
        ctx.stroke();
      }
    }

    // Text progression
    const textAlpha = Math.min(1, prog * 2);
    ctx.fillStyle = `rgba(255,200,100,${textAlpha})`;
    ctx.font = `bold ${Math.min(36, W * 0.05)}px monospace`;
    ctx.textAlign = 'center';
    ctx.shadowColor = '#ff4400';
    ctx.shadowBlur = 20;
    if (prog < 0.25) ctx.fillText('What is happening...', W/2, H * 0.15);
    else if (prog < 0.5) ctx.fillText('They\'re... merging?!', W/2, H * 0.15);
    else if (prog < 0.75) ctx.fillText('IMPOSSIBLE!', W/2, H * 0.15);
    else ctx.fillText('\u2605 FUSION COMPLETE \u2605', W/2, H * 0.15);
    ctx.shadowBlur = 0;

    // Letterbox bars
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, 55);
    ctx.fillRect(0, H - 55, W, 55);
    
    // SKIP button
    ctx.fillStyle = '#ffffff33';
    ctx.fillRect(W - 110, 12, 100, 28);
    ctx.strokeStyle = '#ffffff55';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 110, 12, 100, 28);
    ctx.fillStyle = '#ccc';
    ctx.font = 'bold 12px monospace';
    ctx.fillText('SKIP \u25ba\u25ba', W - 60, 31);
  }

  // ── Fusion Fight HUD ──
  if (state === 'fusionfight') {
    // Player HP
    const hpW = 200;
    ctx.fillStyle = '#00000099';
    ctx.fillRect(15, 8, hpW + 14, 30);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(17, 10, hpW + 10, 26);
    const phpPctF = player.hp / player.maxHp;
    const phpGradF = ctx.createLinearGradient(22, 0, 22 + hpW, 0);
    const phpColsF = cbHP(phpPctF);
    phpGradF.addColorStop(0, phpColsF.a);
    phpGradF.addColorStop(1, phpColsF.b);
    ctx.fillStyle = phpGradF;
    ctx.fillRect(22, 14, hpW * phpPctF, 18);
    ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/200)*0.1+0.1})`;
    ctx.fillRect(22, 14, hpW * phpPctF * 0.5, 6);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(22, 14, hpW, 18);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`\u2764 ${player.hp}/${player.maxHp}`, 28, 29);

    // TRUMPSTEIN HP — dual color bar
    if (fusionBoss && !fusionBoss.dead) {
      const fHudW = Math.min(550, W * 0.55, W - 260);
      const fHpPct = fusionBoss.hp / fusionBoss.maxHp;
      const barX = Math.max(240, W/2 - fHudW/2);

      ctx.fillStyle = '#000000cc';
      ctx.fillRect(barX - 5, 5, fHudW + 10, 40);

      // Boss name
      const fName = fusionBoss.phase === 2 ? '\u2605\u2605 TRUMPSTEIN - UNLEASHED \u2605\u2605' : '\u2605 TRUMPSTEIN \u2605';
      ctx.fillStyle = fusionBoss.phase === 2 ? '#ff4400' : '#ff8844';
      ctx.font = `bold ${fusionBoss.phase === 2 ? 14 : 13}px monospace`;
      ctx.textAlign = 'center';
      ctx.shadowColor = '#ff4400';
      ctx.shadowBlur = fusionBoss.phase * 8;
      ctx.fillText(fName, W/2, 19);
      ctx.shadowBlur = 0;

      // Dual-colored HP bar (red → purple gradient)
      ctx.fillStyle = '#1a0a0a';
      ctx.fillRect(barX, 24, fHudW, 16);
      const fGrad = ctx.createLinearGradient(barX, 0, barX + fHudW, 0);
      fGrad.addColorStop(0, '#cc2200');
      fGrad.addColorStop(0.5, '#ff6644');
      fGrad.addColorStop(1, '#8844ff');
      ctx.fillStyle = fGrad;
      ctx.fillRect(barX, 24, fHudW * fHpPct, 16);
      ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/150)*0.12+0.08})`;
      ctx.fillRect(barX, 24, fHudW * fHpPct * 0.4, 5);
      ctx.fillStyle = '#ffffff66';
      ctx.fillRect(barX + fHudW * 0.4, 24, 2, 16);
      ctx.strokeStyle = fusionBoss.phase === 2 ? '#ff440088' : '#ff884444';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, 24, fHudW, 16);
      ctx.fillStyle = '#ffffffcc';
      ctx.font = 'bold 10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`${fusionBoss.hp} / ${fusionBoss.maxHp}`, W/2, 36);
    }

    if (fusionBoss && !fusionBoss.dead && fusionBoss.phase === 2) {
      ctx.fillStyle = '#ff440088';
      ctx.font = 'bold 16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('PHASE 2', W/2, 58);
    }

    // Touch controls
    drawTouchButtons();

    ctx.fillStyle = '#ffffff55';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(_isTouchDev ? 'Defeat TRUMPSTEIN!' : 'Defeat TRUMPSTEIN!  |  Click/F Throw  |  \u2190 \u2192 Move  |  \u2191/Space Jump', W / 2, H - 10);
  }

  // ── Split Fight HUD ──
  if (state === 'splitfight') {
    // === EPIC SPLIT BOSS CINEMATIC ===
    if (bossIntroTimer > 0) {
      const introT = 1800;
      const prog = 1 - bossIntroTimer / introT;
      const t = Date.now() / 1000;
      
      // Full black background
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
      
      // === GLOBAL CINEMATIC EFFECTS ===
      // Dramatic slow zoom that builds throughout entire cinematic
      const globalZoom = 1 + prog * 0.04;
      ctx.save();
      ctx.translate(W/2, H/2);
      ctx.scale(globalZoom, globalZoom);
      ctx.translate(-W/2, -H/2);
      
      // Chromatic aberration effect during scene transitions
      const scenes_t = [0.03, 0.055, 0.14, 0.24, 0.34, 0.44, 0.59];
      let chromatic = 0;
      for (const st of scenes_t) {
        const d = Math.abs(prog - st);
        if (d < 0.01) chromatic = Math.max(chromatic, (0.01 - d) / 0.01);
      }
      
      // Dramatic bass-drop pulse at each transition
      let bassDrop = 0;
      for (const st of scenes_t) {
        const d = prog - st;
        if (d > 0 && d < 0.015) bassDrop = Math.max(bassDrop, 1 - d / 0.015);
      }
      if (bassDrop > 0) {
        // Radial shockwave from center
        const shockR = (1 - bassDrop) * Math.max(W, H);
        ctx.strokeStyle = `rgba(255,255,255,${bassDrop * 0.4})`;
        ctx.lineWidth = 3 + bassDrop * 8;
        ctx.beginPath();
        ctx.arc(W/2, H/2, shockR, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      // Cinematic letterbox bars
      const barH = 50;
      
      // ═══ COLD OPEN (0-0.03): Dramatic fade from black ═══
      if (prog < 0.03) {
        const sp = prog / 0.03;
        // Pure black with slowly emerging text
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, W, H);
        
        // Slow fade-in of ominous location text
        if (sp > 0.2) {
          const tAlpha = Math.min(1, (sp - 0.2) / 0.3);
          ctx.globalAlpha = tAlpha * 0.6;
          ctx.fillStyle = '#888';
          ctx.font = `${Math.min(11, W*0.015)}px monospace`;
          ctx.textAlign = 'center';
          ctx.fillText('S E C U R E   L I N E   E S T A B L I S H E D', W/2, H/2 - 20);
          ctx.globalAlpha = 1;
        }
        if (sp > 0.5) {
          const tAlpha2 = Math.min(1, (sp - 0.5) / 0.3);
          ctx.globalAlpha = tAlpha2 * 0.4;
          ctx.fillStyle = '#ff4400';
          ctx.font = `bold ${Math.min(14, W*0.02)}px monospace`;
          ctx.fillText('C L A S S I F I E D', W/2, H/2 + 10);
          ctx.globalAlpha = 1;
          // Scanline over text
          const scanY = H/2 - 30 + ((t * 60) % 60);
          ctx.fillStyle = 'rgba(255,68,0,0.03)';
          ctx.fillRect(0, scanY, W, 2);
        }
        // Deep pulse
        if (sp > 0.7) {
          const pulseA = Math.sin((sp - 0.7) / 0.3 * Math.PI) * 0.08;
          ctx.fillStyle = `rgba(255,0,0,${pulseA})`;
          ctx.fillRect(0, 0, W, H);
        }
      }
      
      // ═══ SCENE 1 (0.03-0.055): Phone screen UI ═══
      if (prog >= 0.03 && prog < 0.055) {
        const sp = (prog - 0.03) / 0.025;
        // Dark table surface background
        const tableGrad = ctx.createRadialGradient(W/2, H/2, 50, W/2, H/2, H);
        tableGrad.addColorStop(0, '#0a0612');
        tableGrad.addColorStop(1, '#000000');
        ctx.fillStyle = tableGrad;
        ctx.fillRect(0, 0, W, H);
        // Wood grain texture on table
        ctx.strokeStyle = '#0f0a1808';
        ctx.lineWidth = 1;
        for (let wg = 0; wg < 25; wg++) {
          const wy = H * (wg / 25) + Math.sin(wg * 3.7) * 8;
          ctx.beginPath(); ctx.moveTo(0, wy); ctx.lineTo(W, wy + Math.sin(wg)*5); ctx.stroke();
        }
        // Ambient purple light from phone illuminating the dark
        const ambGlow = ctx.createRadialGradient(W/2, H/2, 30, W/2, H/2, 300);
        ambGlow.addColorStop(0, 'rgba(136,68,255,0.08)');
        ambGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = ambGlow;
        ctx.fillRect(0, 0, W, H);
        // Keys / wallet / misc items on table
        ctx.fillStyle = '#121218';
        ctx.fillRect(W*0.28, H*0.6, 35, 15); ctx.fillRect(W*0.68, H*0.55, 50, 25);
        ctx.fillStyle = '#1a1620';
        ctx.fillRect(W*0.72, H*0.42, 20, 30);
        // Phone screen mockup - bigger, more detailed
        const phoneW = 200, phoneH = 360;
        const phoneX = W/2 - phoneW/2, phoneY = H/2 - phoneH/2;
        ctx.globalAlpha = Math.min(1, sp * 3);
        // Phone shadow on table
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath();
        ctx.roundRect(phoneX - 4, phoneY - 8, phoneW + 20, phoneH + 36, 20);
        ctx.fill();
        // Phone body with bezel
        ctx.fillStyle = '#0a0a0a';
        ctx.beginPath();
        ctx.roundRect(phoneX - 10, phoneY - 18, phoneW + 20, phoneH + 36, 20);
        ctx.fill();
        // Camera notch
        ctx.fillStyle = '#060606';
        ctx.beginPath();
        ctx.roundRect(phoneX + phoneW/2 - 40, phoneY - 15, 80, 22, 12);
        ctx.fill();
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.arc(phoneX + phoneW/2, phoneY - 5, 4, 0, Math.PI*2); ctx.fill();
        // Screen
        const scrGrad = ctx.createLinearGradient(phoneX, phoneY, phoneX, phoneY + phoneH);
        scrGrad.addColorStop(0, '#1a0a2e');
        scrGrad.addColorStop(0.4, '#120828');
        scrGrad.addColorStop(1, '#0a0418');
        ctx.fillStyle = scrGrad;
        ctx.beginPath();
        ctx.roundRect(phoneX, phoneY, phoneW, phoneH, 4);
        ctx.fill();
        // Status bar with more detail
        ctx.fillStyle = '#ffffff15';
        ctx.fillRect(phoneX, phoneY, phoneW, 20);
        ctx.fillStyle = '#888';
        ctx.font = '9px monospace';
        ctx.textAlign = 'left';
        ctx.fillText('9:41 PM', phoneX + 10, phoneY + 14);
        ctx.textAlign = 'right';
        ctx.fillText('5G ■■■ 🔋87%', phoneX + phoneW - 10, phoneY + 14);
        // Group call UI
        ctx.textAlign = 'center';
        const ringPulse = Math.sin(sp * Math.PI * 8) * 0.5 + 0.5;
        // Triple pulsing rings around caller
        for (let rr = 0; rr < 4; rr++) {
          ctx.strokeStyle = `rgba(136,68,255,${(0.4 - rr*0.1) + ringPulse * 0.3})`;
          ctx.lineWidth = 3 - rr*0.5;
          ctx.beginPath();
          ctx.arc(W/2, phoneY + 120, 35 + ringPulse * 12 + rr * 18, 0, Math.PI*2);
          ctx.stroke();
        }
        // Caller image with border
        ctx.save();
        ctx.shadowColor = '#8844ff';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(W/2, phoneY + 120, 36, 0, Math.PI*2);
        ctx.fillStyle = '#8844ff';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(W/2, phoneY + 120, 33, 0, Math.PI*2);
        ctx.clip();
        ctx.drawImage(epsteinImg, W/2 - 33, phoneY + 87, 66, 66);
        ctx.restore();
        // Participant thumbnails at top
        const thumbNames = ['T','E','M','C','H'];
        const thumbCols = ['#ff4400','#8844ff','#4488ff','#cc2222','#44ff88'];
        for (let th = 0; th < 5; th++) {
          const thx = phoneX + 30 + th * 35;
          ctx.fillStyle = thumbCols[th] + '44';
          ctx.beginPath(); ctx.arc(thx, phoneY + 45, 10, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 8px monospace';
          ctx.fillText(thumbNames[th], thx, phoneY + 48);
        }
        // Call info
        ctx.fillStyle = '#cc88ff';
        ctx.font = 'bold 16px monospace';
        ctx.fillText('EPSTEIN', W/2, phoneY + 180);
        ctx.fillStyle = '#999';
        ctx.font = '11px monospace';
        ctx.fillText('Group Call • 5 members', W/2, phoneY + 198);
        ctx.fillStyle = '#666';
        ctx.font = '9px monospace';
        ctx.fillText('End-to-End Encrypted', W/2, phoneY + 215);
        // Pulsing answer text
        ctx.fillStyle = `rgba(136,68,255,${0.6 + ringPulse * 0.4})`;
        ctx.font = 'bold 13px monospace';
        ctx.fillText(sp > 0.5 ? '● CONNECTING...' : '● INCOMING CALL', W/2, phoneY + 260);
        // Signal strength animation
        if (sp > 0.5) {
          for (let sg = 0; sg < 4; sg++) {
            ctx.fillStyle = `rgba(136,68,255,${Math.sin(t*6 + sg)*0.3 + 0.5})`;
            ctx.fillRect(phoneX + 30 + sg*12, phoneY + 270, 8, 4);
          }
        }
        // Accept / Decline buttons — bigger, more detailed
        ctx.fillStyle = '#22cc44';
        ctx.shadowColor = '#22cc44';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(W/2 - 45, phoneY + 310, 20, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowColor = '#cc2222';
        ctx.fillStyle = '#cc2222';
        ctx.beginPath();
        ctx.arc(W/2 + 45, phoneY + 310, 20, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#fff';
        ctx.font = '12px monospace';
        ctx.fillText('\u260E', W/2 - 45, phoneY + 314);
        ctx.fillText('\u2716', W/2 + 45, phoneY + 314);
        ctx.fillStyle = '#aaa';
        ctx.font = '8px monospace';
        ctx.fillText('Accept', W/2 - 45, phoneY + 335);
        ctx.fillText('Decline', W/2 + 45, phoneY + 335);
        ctx.globalAlpha = 1;
        // Outer ripple effects — more rings
        for (let or2 = 0; or2 < 3; or2++) {
          ctx.strokeStyle = `rgba(136,68,255,${ringPulse * 0.12 / (or2+1)})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(W/2, H/2, 180 + ringPulse * 50 + or2 * 60, 0, Math.PI*2);
          ctx.stroke();
        }
        // Vibration effect on entire phone
        if (sp < 0.5 && Math.sin(t*25) > 0.8) {
          ctx.translate(Math.sin(t*40)*2, 0);
        }
      }
      
      // ═══ SCENE 2 (0.055-0.14): Epstein initiating the call ═══
      if (prog >= 0.055 && prog < 0.14) {
        const sp = (prog - 0.055) / 0.085;
        ctx.save();
        // Dark room with purple ambient
        const ambGrad = ctx.createRadialGradient(W/2, H*0.45, 50, W/2, H*0.45, H);
        ambGrad.addColorStop(0, '#1a0a2a');
        ambGrad.addColorStop(0.5, '#0d0518');
        ambGrad.addColorStop(1, '#000000');
        ctx.fillStyle = ambGrad;
        ctx.fillRect(0, 0, W, H);
        
        // Concrete/brick wall texture behind
        ctx.fillStyle = '#0e0818';
        for (let bk = 0; bk < 8; bk++) {
          for (let bk2 = 0; bk2 < 15; bk2++) {
            const bxo = (bk % 2) * 45;
            ctx.fillRect(bk2 * 90 + bxo, bk * 45, 86, 42);
          }
        }
        // Dark curtains on sides
        for (let dc = 0; dc < 8; dc++) {
          ctx.fillStyle = `rgba(20,8,35,${0.3 + dc*0.02})`;
          ctx.fillRect(dc * 8, 0, 10, H);
          ctx.fillRect(W - dc * 8 - 10, 0, 10, H);
        }
        // Ceiling fan shadow rotating
        ctx.globalAlpha = 0.04;
        ctx.save();
        ctx.translate(W*0.3, H*0.1);
        ctx.rotate(t * 1.5);
        for (let fb = 0; fb < 4; fb++) {
          ctx.fillStyle = '#000';
          ctx.fillRect(-5, -60, 10, 120);
          ctx.rotate(Math.PI/2);
        }
        ctx.restore();
        ctx.globalAlpha = 1;
        
        // Floating dust particles — many more
        for (let dp = 0; dp < 40; dp++) {
          const dpx = (dp * 137.5 + t * 12) % W;
          const dpy = (dp * 89.3 + Math.sin(t*0.7 + dp) * 40) % H;
          const dpSize = Math.max(0.1, 0.5 + Math.sin(dp*2.3) * 0.8);
          ctx.fillStyle = `rgba(136,68,255,${0.06 + Math.sin(t*2+dp)*0.06})`;
          ctx.beginPath();
          ctx.arc(dpx, dpy, dpSize, 0, Math.PI*2);
          ctx.fill();
        }
        
        // Desk/table in foreground
        ctx.fillStyle = '#0a0614';
        ctx.fillRect(W*0.15, H*0.62, W*0.7, H*0.06);
        ctx.fillStyle = '#08050f';
        ctx.fillRect(W*0.18, H*0.68, 15, H*0.2);
        ctx.fillRect(W*0.72, H*0.68, 15, H*0.2);
        // Papers scattered on desk
        for (let pp = 0; pp < 4; pp++) {
          ctx.save();
          ctx.translate(W*0.25 + pp*80, H*0.61);
          ctx.rotate((pp-2)*0.08);
          ctx.fillStyle = '#1a1428';
          ctx.fillRect(0, 0, 30, 40);
          ctx.restore();
        }
        // Coffee mug
        ctx.fillStyle = '#1a1225';
        ctx.fillRect(W*0.7, H*0.58, 18, 22);
        ctx.strokeStyle = '#221830';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(W*0.7+24, H*0.58+11, 8, -Math.PI/2, Math.PI/2); ctx.stroke();
        
        // Epstein portrait — large, dramatic entrance
        const eSize = Math.min(W * 0.28, 200);
        const ex = W * 0.5, ey = H * 0.08;
        const enterSlide = Math.min(1, sp * 2.5);
        const easeEnter = 1 - Math.pow(1 - enterSlide, 3);
        ctx.globalAlpha = easeEnter;
        // Double shadow for depth
        ctx.shadowColor = '#8844ff';
        ctx.shadowBlur = 60 + Math.sin(t*3)*15;
        ctx.drawImage(epsteinImg, ex - eSize/2, ey + (1-easeEnter)*80, eSize, imgH(epsteinImg, eSize));
        ctx.shadowBlur = 0;
        
        // Phone screen glow illuminating face from below
        const phoneGlow = ctx.createRadialGradient(ex, ey + eSize * 1.1, 5, ex, ey + eSize * 1.1, 80);
        phoneGlow.addColorStop(0, `rgba(136,68,255,${0.5 + Math.sin(t*4)*0.15})`);
        phoneGlow.addColorStop(0.5, `rgba(136,68,255,0.1)`);
        phoneGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = phoneGlow;
        ctx.fillRect(ex - 80, ey + eSize * 0.7, 160, 120);
        // Phone rectangle with screen detail
        ctx.fillStyle = '#222';
        ctx.beginPath(); ctx.roundRect(ex - 20, ey + eSize * 0.96, 40, 56, 4); ctx.fill();
        ctx.fillStyle = `rgba(136,68,255,${0.5 + Math.sin(t*5)*0.2})`;
        ctx.fillRect(ex - 17, ey + eSize * 0.99, 34, 42);
        // Contact list on phone screen
        ctx.fillStyle = '#eee';
        ctx.font = '5px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GROUP', ex, ey + eSize * 1.02 + 8);
        ctx.fillText('CALL', ex, ey + eSize * 1.02 + 16);
        ctx.fillStyle = '#44ff88';
        ctx.fillText('● LIVE', ex, ey + eSize * 1.02 + 26);
        
        // Purple light rays from behind — more, animated
        if (sp > 0.2) {
          ctx.globalAlpha = Math.min(0.2, (sp - 0.2) * 0.3);
          for (let ray = 0; ray < 12; ray++) {
            const angle = (ray / 12) * Math.PI * 2 + t * 0.2;
            const rayWidth = 2 + Math.sin(t*2 + ray) * 2;
            ctx.strokeStyle = '#8844ff';
            ctx.lineWidth = rayWidth;
            ctx.beginPath();
            ctx.moveTo(ex, ey + eSize * 0.6);
            ctx.lineTo(ex + Math.cos(angle) * 600, ey + eSize * 0.6 + Math.sin(angle) * 600);
            ctx.stroke();
          }
        }
        
        // Location bar
        ctx.globalAlpha = Math.min(0.8, sp * 3);
        ctx.fillStyle = '#0a0518cc';
        ctx.fillRect(W*0.25, H*0.04, W*0.5, 28);
        ctx.strokeStyle = '#8844ff44';
        ctx.lineWidth = 1;
        ctx.strokeRect(W*0.25, H*0.04, W*0.5, 28);
        ctx.fillStyle = '#8866cc';
        ctx.font = `bold ${Math.min(12, W*0.017)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('UNDISCLOSED SAFEHOUSE - LOCATION UNKNOWN', W/2, H*0.04 + 18);
        ctx.globalAlpha = 1;
        
        // Dialogue with typewriter-style reveal
        const lines2 = ['"They separated us..."', '"But we\'re not done yet."', '"Everyone. It\'s time."'];
        const lineIdx = Math.min(2, Math.floor(sp * 3));
        const lineLocalProg = sp * 3 - lineIdx;
        const lineAlpha = Math.min(1, lineLocalProg * 4);
        ctx.globalAlpha = lineAlpha;
        ctx.fillStyle = '#cc88ff';
        ctx.font = `italic ${Math.min(24, W*0.033)}px monospace`;
        ctx.textAlign = 'center';
        ctx.shadowColor = '#8844ff';
        ctx.shadowBlur = 10;
        const fullLine = lines2[lineIdx];
        const charsToShow = Math.floor(fullLine.length * Math.min(1, lineLocalProg * 2.5));
        ctx.fillText(fullLine.substring(0, charsToShow), W/2, H * 0.82);
        ctx.shadowBlur = 0;
        // Blinking cursor
        if (charsToShow < fullLine.length && Math.sin(t*10) > 0) {
          const measured = ctx.measureText(fullLine.substring(0, charsToShow));
          ctx.fillRect(W/2 + measured.width/2 + 2, H*0.82 - 16, 2, 20);
        }
        // Subtle vignette
        ctx.globalAlpha = 0.5;
        const vig = ctx.createRadialGradient(W/2, H/2, H*0.25, W/2, H/2, H*0.75);
        vig.addColorStop(0, 'rgba(0,0,0,0)');
        vig.addColorStop(1, 'rgba(0,0,0,0.8)');
        ctx.fillStyle = vig;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
        ctx.restore();
      }
      
      // ═══ SCENE 3 (0.14-0.24): Trump at his golden tower ═══
      if (prog >= 0.14 && prog < 0.24) {
        const sp = (prog - 0.14) / 0.1;
        ctx.save();
        // Gold background — Trump tower penthouse
        const goldGrad = ctx.createLinearGradient(0, 0, W, H);
        goldGrad.addColorStop(0, '#2a1a00');
        goldGrad.addColorStop(0.3, '#3a2a10');
        goldGrad.addColorStop(0.5, '#4a3518');
        goldGrad.addColorStop(0.7, '#3a2a10');
        goldGrad.addColorStop(1, '#1a0a00');
        ctx.fillStyle = goldGrad;
        ctx.fillRect(0, 0, W, H);
        
        // Marble/ornate wall pattern
        ctx.fillStyle = '#ffffff03';
        for (let mx = 0; mx < W; mx += 60) {
          for (let my = 0; my < H*0.65; my += 80) {
            ctx.fillRect(mx, my, 58, 78);
            ctx.strokeStyle = '#ffcc4408';
            ctx.lineWidth = 1;
            ctx.strokeRect(mx, my, 58, 78);
          }
        }
        
        // Gold decorative columns — thicker, more ornate
        for (let i = 0; i < 8; i++) {
          const cx2 = W * 0.05 + W * 0.9 * (i/7);
          // Column body
          ctx.fillStyle = '#ffcc4410';
          ctx.fillRect(cx2 - 10, 0, 20, H);
          ctx.strokeStyle = '#ffcc4418';
          ctx.lineWidth = 1;
          ctx.strokeRect(cx2 - 10, 0, 20, H);
          // Ornate column caps (top & bottom)
          ctx.fillStyle = '#ffcc4418';
          ctx.fillRect(cx2 - 18, 0, 36, 28);
          ctx.fillRect(cx2 - 18, H*0.63, 36, 10);
          // Column scrollwork
          ctx.fillStyle = '#ffcc4410';
          ctx.beginPath();
          ctx.arc(cx2, 14, 10, 0, Math.PI*2);
          ctx.fill();
        }
        
        // Marble floor with reflection
        ctx.fillStyle = '#1a1208';
        ctx.fillRect(0, H*0.65, W, H*0.35);
        // Checker pattern marble
        for (let fx = 0; fx < W; fx += 60) {
          for (let fy = 0; fy < H*0.35; fy += 60) {
            ctx.fillStyle = (Math.floor(fx/60) + Math.floor(fy/60)) % 2 === 0 ? '#1e1610' : '#16100a';
            ctx.fillRect(fx, H*0.65 + fy, 60, 60);
          }
        }
        ctx.fillStyle = '#ffffff04';
        ctx.fillRect(0, H*0.65, W, H*0.35);
        
        // Grand chandelier — detailed
        const chanX = W*0.5, chanY = H*0.02;
        // Chain
        ctx.strokeStyle = '#ffcc4433';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(chanX, 0); ctx.lineTo(chanX, chanY + 15); ctx.stroke();
        // Chandelier body
        ctx.fillStyle = '#ffcc4420';
        ctx.beginPath(); ctx.ellipse(chanX, chanY + 20, 60, 12, 0, 0, Math.PI*2); ctx.fill();
        // Crystal drops
        for (let cr = 0; cr < 8; cr++) {
          const crx = chanX - 50 + cr * 14;
          const cry = chanY + 25 + Math.sin(cr*1.5)*5;
          ctx.strokeStyle = '#ffcc4422';
          ctx.beginPath(); ctx.moveTo(crx, chanY + 20); ctx.lineTo(crx, cry + 15); ctx.stroke();
          ctx.fillStyle = `rgba(255,220,100,${0.1 + Math.sin(t*2+cr)*0.05})`;
          ctx.beginPath(); ctx.arc(crx, cry + 18, 3, 0, Math.PI*2); ctx.fill();
        }
        // Chandelier glow
        const chanGlow = ctx.createRadialGradient(chanX, chanY + 20, 10, chanX, chanY + 20, 200);
        chanGlow.addColorStop(0, 'rgba(255,204,68,0.12)');
        chanGlow.addColorStop(0.5, 'rgba(255,180,40,0.04)');
        chanGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = chanGlow;
        ctx.fillRect(0, 0, W, H*0.4);
        
        // Window with night NYC skyline behind
        ctx.fillStyle = '#0a0808';
        ctx.fillRect(W*0.72, H*0.12, W*0.22, H*0.35);
        ctx.strokeStyle = '#ffcc4422';
        ctx.lineWidth = 3;
        ctx.strokeRect(W*0.72, H*0.12, W*0.22, H*0.35);
        // Window cross
        ctx.strokeStyle = '#ffcc4415';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(W*0.83, H*0.12); ctx.lineTo(W*0.83, H*0.47); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.72, H*0.30); ctx.lineTo(W*0.94, H*0.30); ctx.stroke();
        // Tiny city buildings through window
        ctx.fillStyle = '#080808';
        for (let bld = 0; bld < 12; bld++) {
          const bx = W*0.73 + bld*14;
          const bh = 20 + Math.sin(bld*2.3)*15 + bld*3;
          ctx.fillRect(bx, H*0.47 - bh, 11, bh);
          // Window lights
          for (let wl = 0; wl < bh/8; wl++) {
            if (Math.sin(bld*7+wl*3+t*0.5) > 0.3) {
              ctx.fillStyle = '#ffdd8822';
              ctx.fillRect(bx+2, H*0.47-bh+wl*8+2, 3, 3);
            }
            ctx.fillStyle = '#080808';
          }
        }
        
        // Location title bar with gold border
        ctx.fillStyle = '#0a0500dd';
        ctx.fillRect(W*0.2, H*0.06, W*0.6, 32);
        ctx.strokeStyle = '#ffcc4466';
        ctx.lineWidth = 1;
        ctx.strokeRect(W*0.2, H*0.06, W*0.6, 32);
        ctx.fillStyle = '#ffdd88';
        ctx.font = `bold ${Math.min(14, W*0.019)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('\u2605 TRUMP TOWER - 58TH FLOOR PENTHOUSE \u2605', W/2, H*0.06 + 21);
        
        // Trump portrait with dramatic entrance
        const tSize = Math.min(W * 0.26, 180);
        const tx = W * 0.3;
        const tEnter = Math.min(1, sp * 2.5);
        const tEase = 1 - Math.pow(1 - tEnter, 3);
        ctx.globalAlpha = tEase;
        ctx.shadowColor = '#ff4400';
        ctx.shadowBlur = 50 + Math.sin(t*2)*15;
        ctx.drawImage(bossIntroImg, tx - tSize/2, H * 0.16 + (1-tEase)*60, tSize, imgH(bossIntroImg, tSize));
        ctx.shadowBlur = 0;
        
        // Ornate gold desk — larger, with more items
        ctx.fillStyle = '#3a2810';
        ctx.fillRect(W*0.52, H*0.48, W*0.38, H*0.14);
        ctx.strokeStyle = '#ffcc4433';
        ctx.lineWidth = 2;
        ctx.strokeRect(W*0.52, H*0.48, W*0.38, H*0.14);
        // Gold inlay on desk edge
        ctx.fillStyle = '#ffcc4418';
        ctx.fillRect(W*0.52, H*0.48, W*0.38, 3);
        // Desk legs
        ctx.fillStyle = '#2a1a08';
        ctx.fillRect(W*0.54, H*0.62, 12, H*0.12);
        ctx.fillRect(W*0.87, H*0.62, 12, H*0.12);
        // Desk items
        ctx.fillStyle = '#2a1a08';
        ctx.fillRect(W*0.86, H*0.44, 22, 35); // pen holder
        ctx.fillStyle = '#332208';
        ctx.fillRect(W*0.86, H*0.44, 22, 5); // pen holder rim
        // Gold nameplate — bigger
        ctx.fillStyle = '#ffcc4430';
        ctx.fillRect(W*0.55, H*0.50, 70, 12);
        ctx.fillStyle = '#ffdd88';
        ctx.font = 'bold 7px monospace';
        ctx.fillText('PRESIDENT', W*0.59, H*0.50 + 9);
        // Globe on desk
        ctx.strokeStyle = '#ffcc4415';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(W*0.82, H*0.46, 14, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.ellipse(W*0.82, H*0.46, 14, 5, 0.3, 0, Math.PI*2); ctx.stroke();
        // American flag in corner
        ctx.fillStyle = '#cc222244';
        ctx.fillRect(W*0.08, H*0.12, 28, 18);
        ctx.fillStyle = '#112266';
        ctx.fillRect(W*0.08, H*0.12, 12, 10);
        ctx.strokeStyle = '#44220088';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(W*0.08, H*0.12); ctx.lineTo(W*0.08, H*0.45); ctx.stroke();
        
        // Phone buzzing on gold desk
        const phoneX = W * 0.68;
        const phoneY = H * 0.46;
        const buzz = Math.sin(t * 25) * (sp < 0.5 ? 4 : 0);
        ctx.fillStyle = '#222';
        ctx.beginPath(); ctx.roundRect(phoneX - 14 + buzz, phoneY, 28, 46, 4); ctx.fill();
        ctx.fillStyle = `rgba(136,68,255,${0.5 + Math.sin(t*6)*0.3})`;
        ctx.fillRect(phoneX - 12 + buzz, phoneY + 3, 24, 34);
        ctx.fillStyle = '#fff';
        ctx.font = '6px monospace';
        ctx.fillText('CALL', phoneX + buzz, phoneY + 22);
        // Phone vibration rings
        if (sp < 0.5) {
          for (let vr = 1; vr <= 4; vr++) {
            ctx.strokeStyle = `rgba(136,68,255,${0.3/vr})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(phoneX + buzz, phoneY + 20, 20 + vr*10 + Math.sin(t*8)*4, 0, Math.PI*2);
            ctx.stroke();
          }
        }
        
        // Dialogue
        const phase = sp > 0.5;
        ctx.textAlign = 'center';
        if (!phase) {
          ctx.fillStyle = '#ffcc88';
          ctx.font = `italic ${Math.min(18, W*0.025)}px monospace`;
          ctx.fillText('*phone buzzes on the gold desk*', W/2, H * 0.8);
        } else {
          ctx.fillStyle = '#ff4400';
          ctx.font = `bold italic ${Math.min(22, W*0.03)}px monospace`;
          ctx.shadowColor = '#ff4400';
          ctx.shadowBlur = 20;
          const line = '"I never left. Let\'s finish this."';
          const chars = Math.floor(line.length * Math.min(1, (sp-0.5)*4));
          ctx.fillText(line.substring(0, chars), W/2, H * 0.8);
          ctx.shadowBlur = 0;
          // Blinking cursor
          if (chars < line.length && Math.sin(t*10) > 0) {
            const m3 = ctx.measureText(line.substring(0, chars));
            ctx.fillRect(W/2 + m3.width/2 + 2, H*0.8 - 16, 2, 20);
          }
        }
        // Vignette
        ctx.globalAlpha = 0.5;
        const tVig = ctx.createRadialGradient(W/2, H/2, H*0.25, W/2, H/2, H*0.75);
        tVig.addColorStop(0, 'rgba(0,0,0,0)');
        tVig.addColorStop(1, 'rgba(0,0,0,0.6)');
        ctx.fillStyle = tVig;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
        ctx.restore();
      }
      
      // ═══ SCENE 4 (0.24-0.34): Musk at SpaceX lab ═══
      if (prog >= 0.24 && prog < 0.34) {
        const sp = (prog - 0.24) / 0.1;
        ctx.save();
        // Tech lab background — blue-tinted
        const techGrad = ctx.createLinearGradient(0, 0, W, H);
        techGrad.addColorStop(0, '#000a1a');
        techGrad.addColorStop(0.3, '#001133');
        techGrad.addColorStop(0.7, '#001540');
        techGrad.addColorStop(1, '#000a1a');
        ctx.fillStyle = techGrad;
        ctx.fillRect(0, 0, W, H);
        
        // Metal panel walls with rivets
        ctx.strokeStyle = '#4488ff08';
        ctx.lineWidth = 1;
        for (let pnl = 0; pnl < 6; pnl++) {
          const px = pnl * W/6;
          ctx.strokeRect(px + 5, 5, W/6 - 10, H - 10);
          // Corner rivets
          ctx.fillStyle = '#4488ff10';
          ctx.beginPath(); ctx.arc(px + 12, 12, 3, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(px + W/6 - 7, 12, 3, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(px + 12, H - 12, 3, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(px + W/6 - 7, H - 12, 3, 0, Math.PI*2); ctx.fill();
        }
        
        // Holographic grid lines — with perspective
        ctx.strokeStyle = '#4488ff0a';
        ctx.lineWidth = 1;
        for (let i = 0; i < 30; i++) {
          ctx.beginPath();
          ctx.moveTo(0, H * (i/30));
          ctx.lineTo(W, H * (i/30));
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(W * (i/30), 0);
          ctx.lineTo(W * (i/30), H);
          ctx.stroke();
        }
        // Animated data streams on grid
        for (let ds = 0; ds < 8; ds++) {
          const dsx = (ds * W/8 + t * 30) % W;
          ctx.fillStyle = `rgba(68,136,255,${0.08 + Math.sin(t+ds)*0.04})`;
          ctx.fillRect(dsx, 0, 2, H);
        }
        
        // Floor — tech lab metal
        ctx.fillStyle = '#060e1a';
        ctx.fillRect(0, H*0.7, W, H*0.3);
        ctx.strokeStyle = '#4488ff08';
        for (let fl = 0; fl < W; fl += 80) {
          ctx.beginPath(); ctx.moveTo(fl, H*0.7); ctx.lineTo(fl, H); ctx.stroke();
        }
        // Floor LED strip
        ctx.fillStyle = `rgba(68,136,255,${0.15 + Math.sin(t*2)*0.1})`;
        ctx.fillRect(0, H*0.7, W, 2);
        
        // Location text with tech border
        ctx.fillStyle = '#001a33dd';
        ctx.fillRect(W*0.25, H*0.05, W*0.5, 30);
        ctx.strokeStyle = '#4488ff66';
        ctx.lineWidth = 1;
        ctx.strokeRect(W*0.25, H*0.05, W*0.5, 30);
        // Moving scan line on location bar
        const scanX = (t * 60) % (W*0.5);
        ctx.fillStyle = '#4488ff22';
        ctx.fillRect(W*0.25 + scanX, H*0.05, 30, 30);
        ctx.fillStyle = '#88ccff';
        ctx.font = `bold ${Math.min(14, W*0.02)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('SPACEX HQ - CLASSIFIED LABORATORY LVL.7', W/2, H*0.05 + 20);
        
        // Main holographic display — bigger, more detailed
        ctx.fillStyle = '#001020';
        ctx.fillRect(W*0.05, H*0.15, W*0.35, H*0.48);
        ctx.strokeStyle = '#4488ff55';
        ctx.lineWidth = 2;
        ctx.strokeRect(W*0.05, H*0.15, W*0.35, H*0.48);
        // Screen header bar
        ctx.fillStyle = '#4488ff22';
        ctx.fillRect(W*0.05, H*0.15, W*0.35, 18);
        ctx.fillStyle = '#4488ff';
        ctx.font = '8px monospace';
        ctx.textAlign = 'left';
        ctx.fillText('■ NEURALINK COMBAT SYS v4.2.0', W*0.07, H*0.15 + 12);
        // Screen power indicator
        ctx.fillStyle = '#44ff88';
        ctx.beginPath(); ctx.arc(W*0.38, H*0.15 + 9, 3, 0, Math.PI*2); ctx.fill();
        // Scrolling code on screen
        ctx.fillStyle = '#4488ff';
        ctx.font = '8px monospace';
        const codeLines = ['>> NEURAL_LINK_v','>> COMBAT_AI_mod.','>> WEAPONS_SYS.','>> SHIELD_GEN.','>> TARGET_ACQ.','>> MOBILITY.','>> PROJECTILE.','>> HOMING_v','>> BURST_FIRE.','>> DASH_PROTO.','>> UPLOAD_ALL.','>> STATUS:'];
        for (let l = 0; l < 12; l++) {
          ctx.globalAlpha = 0.3 + Math.sin(l + t*3) * 0.2;
          ctx.textAlign = 'left';
          const codeTxt = codeLines[l] + (l+1) + '.INIT()';
          ctx.fillText(codeTxt, W*0.07, H*0.19 + l * 16);
          // Progress bars next to each line
          const prog2 = Math.min(1, (sp * 2 + Math.sin(l + t*2) * 0.3));
          ctx.fillStyle = '#4488ff22';
          ctx.fillRect(W*0.28, H*0.185 + l * 16, 50, 8);
          ctx.fillStyle = l === 11 ? '#44ff88' : '#4488ff';
          ctx.fillRect(W*0.28, H*0.185 + l * 16, 50 * prog2, 8);
          ctx.fillStyle = '#4488ff';
        }
        ctx.globalAlpha = 1;
        
        // Secondary monitor — smaller
        ctx.fillStyle = '#001020';
        ctx.fillRect(W*0.05, H*0.66, W*0.17, H*0.14);
        ctx.strokeStyle = '#4488ff33';
        ctx.lineWidth = 1;
        ctx.strokeRect(W*0.05, H*0.66, W*0.17, H*0.14);
        // Waveform on secondary
        ctx.strokeStyle = '#44ff8844';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let wf = 0; wf < 60; wf++) {
          const wx = W*0.05 + wf * (W*0.17/60);
          const wy = H*0.73 + Math.sin(wf*0.5 + t*4) * 15;
          wf === 0 ? ctx.moveTo(wx, wy) : ctx.lineTo(wx, wy);
        }
        ctx.stroke();
        
        // Musk — larger, with control panel glow
        const mSize = Math.min(W * 0.24, 170);
        ctx.globalAlpha = Math.min(1, sp * 2);
        ctx.shadowColor = '#4488ff';
        ctx.shadowBlur = 40;
        ctx.drawImage(muskImg, W * 0.65 - mSize/2, H * 0.15, mSize, imgH(muskImg, mSize));
        ctx.shadowBlur = 0;
        
        // Robot arm behind Musk — articulated
        if (sp > 0.2) {
          ctx.strokeStyle = '#4488ff44';
          ctx.lineWidth = 4;
          const armAngle = Math.sin(t*0.8) * 0.3;
          ctx.save();
          ctx.translate(W*0.85, H*0.12);
          ctx.rotate(armAngle);
          ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 80); ctx.stroke();
          ctx.translate(0, 80);
          ctx.rotate(armAngle * 1.5);
          ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 60); ctx.stroke();
          // Claw
          ctx.beginPath(); ctx.moveTo(-8, 60); ctx.lineTo(0, 70); ctx.lineTo(8, 60); ctx.stroke();
          // Joint circles
          ctx.fillStyle = '#4488ff33';
          ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI*2); ctx.fill();
          ctx.restore();
          // Arm base mount
          ctx.fillStyle = '#4488ff22';
          ctx.fillRect(W*0.83, H*0.1, 25, 12);
        }
        
        // Holographic Tesla Roadster floating (easter egg)
        ctx.globalAlpha = 0.06 + Math.sin(t)*0.03;
        ctx.fillStyle = '#4488ff';
        ctx.fillRect(W*0.78, H*0.52 + Math.sin(t*1.5)*8, 40, 18);
        ctx.fillRect(W*0.82, H*0.48 + Math.sin(t*1.5)*8, 25, 12);
        // Wheels
        ctx.beginPath(); ctx.arc(W*0.82, H*0.71 + Math.sin(t*1.5)*8, 5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(W*0.815, H*0.71 + Math.sin(t*1.5)*8, 5, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
        
        // Phone notification
        const phase = sp > 0.5;
        ctx.textAlign = 'center';
        if (!phase) {
          ctx.fillStyle = '#88ccff';
          ctx.font = `italic ${Math.min(18, W*0.025)}px monospace`;
          ctx.fillText('*encrypted transmission received*', W/2, H * 0.8);
          // Notification popup — more detailed
          ctx.fillStyle = '#001a33ee';
          ctx.fillRect(W*0.3, H*0.84, W*0.4, 48);
          ctx.strokeStyle = '#4488ff44';
          ctx.strokeRect(W*0.3, H*0.84, W*0.4, 48);
          // Warning icon
          ctx.fillStyle = '#ff8844';
          ctx.font = 'bold 14px monospace';
          ctx.fillText('⚠', W*0.33, H*0.84 + 20);
          ctx.fillStyle = '#4488ff';
          ctx.font = '9px monospace';
          ctx.fillText('FROM: [REDACTED] | PRIORITY: OMEGA', W/2, H*0.84 + 16);
          ctx.fillStyle = '#88ccff';
          ctx.fillText('CABAL_REGROUP.exe — DECRYPT & EXECUTE?', W/2, H*0.84 + 30);
          ctx.fillStyle = '#44ff88';
          ctx.font = '8px monospace';
          ctx.fillText('[Y] CONFIRM    [N] DENY', W/2, H*0.84 + 42);
        } else {
          ctx.fillStyle = '#4488ff';
          ctx.font = `bold italic ${Math.min(22, W*0.03)}px monospace`;
          ctx.shadowColor = '#4488ff';
          ctx.shadowBlur = 20;
          const line = '"Finally. Uploading combat protocols."';
          const chars = Math.floor(line.length * Math.min(1, (sp-0.5)*4));
          ctx.fillText(line.substring(0, chars), W/2, H * 0.82);
          ctx.shadowBlur = 0;
          if (chars < line.length && Math.sin(t*10) > 0) {
            const m4 = ctx.measureText(line.substring(0, chars));
            ctx.fillRect(W/2 + m4.width/2 + 2, H*0.82 - 16, 2, 20);
          }
        }
        // CRT scanline overlay
        ctx.globalAlpha = 0.04;
        for (let sl = 0; sl < H; sl += 3) {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, sl, W, 1);
        }
        ctx.globalAlpha = 1;
        // Blue LED ambient strips on ceiling
        ctx.fillStyle = `rgba(68,136,255,${0.06 + Math.sin(t*1.5)*0.03})`;
        ctx.fillRect(0, 0, W, 4);
        ctx.fillRect(0, H*0.7 - 3, W, 3);
        // Vignette
        ctx.globalAlpha = 0.4;
        const mVig = ctx.createRadialGradient(W/2, H/2, H*0.25, W/2, H/2, H*0.8);
        mVig.addColorStop(0, 'rgba(0,0,0,0)');
        mVig.addColorStop(1, 'rgba(0,0,0,0.7)');
        ctx.fillStyle = mVig;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
        ctx.restore();
      }
      
      // ═══ SCENE 5 (0.34-0.44): Clinton in political office ═══
      if (prog >= 0.34 && prog < 0.44) {
        const sp = (prog - 0.34) / 0.1;
        ctx.save();
        // Dark red office — richer gradient
        const offGrad = ctx.createRadialGradient(W*0.4, H*0.4, 100, W*0.4, H*0.4, H);
        offGrad.addColorStop(0, '#2a0a0a');
        offGrad.addColorStop(0.5, '#1a0505');
        offGrad.addColorStop(1, '#0a0202');
        ctx.fillStyle = offGrad;
        ctx.fillRect(0, 0, W, H);
        
        // Wood paneling — detailed with grain
        for (let wp = 0; wp < 14; wp++) {
          const wpx = W * (wp/14);
          const wpw = W/14;
          ctx.fillStyle = wp % 2 === 0 ? '#1a0808' : '#180707';
          ctx.fillRect(wpx, 0, wpw, H*0.68);
          ctx.strokeStyle = '#33111120';
          ctx.lineWidth = 1;
          ctx.strokeRect(wpx, 0, wpw, H*0.68);
          // Wood grain lines
          for (let wgl = 0; wgl < 8; wgl++) {
            ctx.strokeStyle = '#ffffff03';
            ctx.beginPath();
            ctx.moveTo(wpx + 3, wgl * H*0.085);
            ctx.lineTo(wpx + wpw - 3, wgl * H*0.085 + Math.sin(wp+wgl)*3);
            ctx.stroke();
          }
        }
        
        // Bookshelves on back wall — detailed books
        for (let shelf = 0; shelf < 3; shelf++) {
          const shelfY = H*0.12 + shelf * H*0.18;
          // Shelf board
          ctx.fillStyle = '#2a1212';
          ctx.fillRect(W*0.7, shelfY + H*0.14, W*0.26, 4);
          // Individual books
          for (let bk = 0; bk < 10; bk++) {
            const bookCol = ['#331818','#222833','#2a2218','#1a2a28','#2a1a2a','#282218','#1a1830','#301818','#182a1a','#221a2a'][bk];
            const bookH = 25 + Math.sin(bk*3.7+shelf) * 8;
            ctx.fillStyle = bookCol;
            ctx.fillRect(W*0.71 + bk*22, shelfY + H*0.14 - bookH, 18, bookH);
            // Book spine line
            ctx.fillStyle = '#ffffff08';
            ctx.fillRect(W*0.71 + bk*22 + 8, shelfY + H*0.14 - bookH + 3, 1, bookH - 6);
          }
        }
        
        // Carpet floor — dark red
        ctx.fillStyle = '#1a0808';
        ctx.fillRect(0, H*0.68, W, H*0.32);
        // Carpet pattern
        ctx.strokeStyle = '#cc222208';
        ctx.lineWidth = 1;
        for (let cp = 0; cp < W; cp += 30) {
          for (let cp2 = 0; cp2 < H*0.32; cp2 += 30) {
            ctx.strokeRect(cp, H*0.68 + cp2, 28, 28);
          }
        }
        
        // Fireplace on right wall — with flickering fire
        ctx.fillStyle = '#1a0a0a';
        ctx.fillRect(W*0.02, H*0.28, W*0.14, H*0.35);
        ctx.fillStyle = '#120606';
        ctx.fillRect(W*0.04, H*0.32, W*0.1, H*0.25);
        // Mantle
        ctx.fillStyle = '#2a1414';
        ctx.fillRect(W*0.01, H*0.26, W*0.16, H*0.03);
        // Fire glow
        const fireGlow = ctx.createRadialGradient(W*0.09, H*0.5, 5, W*0.09, H*0.5, 80);
        fireGlow.addColorStop(0, `rgba(255,100,30,${0.12 + Math.sin(t*6)*0.06})`);
        fireGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = fireGlow;
        ctx.fillRect(0, H*0.3, W*0.25, H*0.4);
        // Flames
        for (let fl = 0; fl < 5; fl++) {
          const flx = W*0.05 + fl * W*0.02;
          const flh = 15 + Math.sin(t*8 + fl*2) * 10;
          ctx.fillStyle = `rgba(255,${80+fl*20},0,${0.3 + Math.sin(t*10+fl)*0.15})`;
          ctx.beginPath();
          ctx.moveTo(flx, H*0.57);
          ctx.quadraticCurveTo(flx + 4, H*0.57 - flh, flx + 8, H*0.57);
          ctx.fill();
        }
        // Clock on mantle
        ctx.fillStyle = '#2a1818';
        ctx.beginPath(); ctx.arc(W*0.09, H*0.24, 12, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#ffcc4422';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(W*0.09, H*0.24, 12, 0, Math.PI*2); ctx.stroke();
        // Clock hands
        ctx.strokeStyle = '#ffcc4444';
        ctx.beginPath(); ctx.moveTo(W*0.09, H*0.24); ctx.lineTo(W*0.09, H*0.24-8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.09, H*0.24); ctx.lineTo(W*0.09+5, H*0.24+2); ctx.stroke();
        
        // Location bar
        ctx.fillStyle = '#cc222240';
        ctx.fillRect(W*0.25, H*0.05, W*0.5, 30);
        ctx.strokeStyle = '#cc222266';
        ctx.lineWidth = 1;
        ctx.strokeRect(W*0.25, H*0.05, W*0.5, 30);
        ctx.fillStyle = '#ff6666';
        ctx.font = `bold ${Math.min(14, W*0.02)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('UNDISCLOSED LOCATION - WASHINGTON, D.C.', W/2, H*0.05 + 20);
        
        // Clinton portrait — larger
        const cSize = Math.min(W * 0.25, 175);
        ctx.globalAlpha = Math.min(1, sp * 2);
        ctx.shadowColor = '#cc2222';
        ctx.shadowBlur = 40;
        ctx.drawImage(clintonImg, W * 0.38 - cSize/2, H * 0.15, cSize, imgH(clintonImg, cSize));
        ctx.shadowBlur = 0;
        
        // Mahogany desk — bigger, more items
        ctx.fillStyle = '#2a1515';
        ctx.fillRect(W*0.52, H*0.4, W*0.4, H*0.22);
        ctx.strokeStyle = '#cc222220';
        ctx.lineWidth = 2;
        ctx.strokeRect(W*0.52, H*0.4, W*0.4, H*0.22);
        // Desk legs
        ctx.fillStyle = '#221010';
        ctx.fillRect(W*0.54, H*0.62, 10, H*0.1);
        ctx.fillRect(W*0.89, H*0.62, 10, H*0.1);
        // Desk lamp
        ctx.fillStyle = '#1a0a0a';
        ctx.fillRect(W*0.86, H*0.28, 6, H*0.12);
        ctx.fillStyle = '#2a1818';
        ctx.beginPath(); ctx.moveTo(W*0.82, H*0.28); ctx.lineTo(W*0.93, H*0.28); ctx.lineTo(W*0.89, H*0.22); ctx.closePath(); ctx.fill();
        // Lamp glow
        const lampGlow = ctx.createRadialGradient(W*0.89, H*0.35, 5, W*0.89, H*0.35, 80);
        lampGlow.addColorStop(0, 'rgba(255,200,100,0.08)');
        lampGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = lampGlow;
        ctx.fillRect(W*0.78, H*0.25, W*0.2, H*0.3);
        
        // Scattered classified papers — more detailed
        for (let d = 0; d < 7; d++) {
          ctx.save();
          ctx.translate(W*0.56 + d*35, H*0.42 + Math.sin(d*2.3)*8);
          ctx.rotate((d-3)*0.08);
          ctx.fillStyle = '#f0e8d0';
          ctx.fillRect(0, 0, 28, 38);
          // Red stamp
          ctx.fillStyle = '#cc222288';
          ctx.font = 'bold 5px monospace';
          ctx.textAlign = 'center';
          ctx.fillText('TOP', 14, 13);
          ctx.fillText('SECRET', 14, 20);
          // Redacted lines
          ctx.fillStyle = '#222';
          for (let rl = 0; rl < 3; rl++) {
            ctx.fillRect(4, 25 + rl*4, 20, 2);
          }
          ctx.restore();
        }
        
        // Wine glass — more detailed with liquid
        ctx.strokeStyle = '#88333344';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(W*0.58, H*0.44);
        ctx.quadraticCurveTo(W*0.583, H*0.38, W*0.585, H*0.34);
        ctx.stroke();
        // Glass bowl
        ctx.strokeStyle = '#88333330';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(W*0.585, H*0.32, 10, 14, 0, 0, Math.PI*2);
        ctx.stroke();
        // Wine liquid
        ctx.fillStyle = '#661818';
        ctx.beginPath();
        ctx.ellipse(W*0.585, H*0.34, 8, 5, 0, 0, Math.PI);
        ctx.fill();
        // Glass base
        ctx.fillStyle = '#88333330';
        ctx.fillRect(W*0.575, H*0.44, 12, 3);
        
        // Framed photo on desk (family photo placeholder)
        ctx.fillStyle = '#2a1818';
        ctx.fillRect(W*0.84, H*0.36, 22, 28);
        ctx.fillStyle = '#1a1010';
        ctx.fillRect(W*0.845, H*0.365, 18, 22);
        
        const phase = sp > 0.5;
        ctx.textAlign = 'center';
        if (!phase) {
          ctx.fillStyle = '#ff8888';
          ctx.font = `italic ${Math.min(18, W*0.025)}px monospace`;
          ctx.fillText('*a familiar number appears*', W/2, H * 0.8);
          // Desk phone — more detailed
          ctx.fillStyle = '#1a0a0a';
          ctx.fillRect(W*0.76, H*0.43, 35, 22);
          // Handset
          ctx.fillStyle = '#120808';
          ctx.fillRect(W*0.765, H*0.41, 30, 8);
          const phonePulse = Math.sin(t*8) * 0.3 + 0.5;
          // Blinking light
          ctx.fillStyle = `rgba(204,34,34,${phonePulse})`;
          ctx.beginPath(); ctx.arc(W*0.78, H*0.45, 3, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = '#fff';
          ctx.font = '4px monospace';
          ctx.fillText('LINE 1', W*0.78, H*0.455 + 8);
        } else {
          ctx.fillStyle = '#cc2222';
          ctx.font = `bold italic ${Math.min(22, W*0.03)}px monospace`;
          ctx.shadowColor = '#cc2222';
          ctx.shadowBlur = 20;
          const line = '"Some things never stay buried."';
          const chars = Math.floor(line.length * Math.min(1, (sp-0.5)*4));
          ctx.fillText(line.substring(0, chars), W/2, H * 0.82);
          ctx.shadowBlur = 0;
          if (chars < line.length && Math.sin(t*10) > 0) {
            const m5 = ctx.measureText(line.substring(0, chars));
            ctx.fillRect(W/2 + m5.width/2 + 2, H*0.82 - 16, 2, 20);
          }
        }
        // Vignette — heavier, moodier
        ctx.globalAlpha = 0.55;
        const cVig = ctx.createRadialGradient(W*0.4, H*0.4, H*0.2, W*0.4, H*0.4, H*0.8);
        cVig.addColorStop(0, 'rgba(0,0,0,0)');
        cVig.addColorStop(1, 'rgba(0,0,0,0.8)');
        ctx.fillStyle = cVig;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
        ctx.restore();
      }
      
      // ═══ SCENE 6 (0.44-0.59): HAWKING — THE GRAVE ═══
      if (prog >= 0.44 && prog < 0.59) {
        const sp = (prog - 0.44) / 0.15;
        ctx.save();
        
        // Dark, cold graveyard atmosphere
        const graveGrad = ctx.createLinearGradient(0, 0, 0, H);
        graveGrad.addColorStop(0, '#020208');
        graveGrad.addColorStop(0.3, '#060612');
        graveGrad.addColorStop(0.7, '#0a0a18');
        graveGrad.addColorStop(1, '#0e0e14');
        ctx.fillStyle = graveGrad;
        ctx.fillRect(0, 0, W, H);
        
        // Stars — more varied, with shooting star
        for (let star = 0; star < 60; star++) {
          const sx = (star * 97.3) % W;
          const sy = (star * 53.7) % (H * 0.45);
          const twinkle = Math.sin(t*2 + star*1.7) * 0.3 + 0.5;
          const starSize = (star % 3 === 0) ? 2 : 1;
          ctx.fillStyle = `rgba(200,200,220,${twinkle * (star % 5 === 0 ? 0.5 : 0.25)})`;
          ctx.fillRect(sx, sy, starSize, starSize);
          // Tiny cross shape for bright stars
          if (star % 7 === 0) {
            ctx.fillRect(sx - 1, sy, 3, 1);
            ctx.fillRect(sx, sy - 1, 1, 3);
          }
        }
        // Shooting star (periodic)
        const shootStar = (t * 0.3) % 3;
        if (shootStar < 0.5) {
          const ssX = W * 0.9 - shootStar * W * 0.6;
          const ssY = H * 0.05 + shootStar * H * 0.15;
          ctx.strokeStyle = `rgba(220,220,255,${(0.5 - shootStar) * 1.5})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(ssX, ssY);
          ctx.lineTo(ssX + 40, ssY - 8);
          ctx.stroke();
        }
        
        // Dark cloud banks drifting across sky
        for (let cl = 0; cl < 4; cl++) {
          const cx3 = (cl * 400 + t * (8 + cl*3)) % (W + 300) - 150;
          const cy3 = H * 0.08 + cl * 40;
          ctx.fillStyle = `rgba(10,10,20,${0.3 + cl*0.05})`;
          ctx.beginPath();
          ctx.ellipse(cx3, cy3, 120 + cl*20, 25 + cl*5, 0, 0, Math.PI*2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(cx3 + 60, cy3 - 10, 80, 20, 0, 0, Math.PI*2);
          ctx.fill();
        }
        
        // Moon with halo
        const moonX = W * 0.82, moonY = H * 0.1;
        // Outer halo
        const moonHalo = ctx.createRadialGradient(moonX, moonY, 30, moonX, moonY, 120);
        moonHalo.addColorStop(0, 'rgba(180,180,200,0.08)');
        moonHalo.addColorStop(0.5, 'rgba(100,100,140,0.03)');
        moonHalo.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = moonHalo;
        ctx.fillRect(moonX - 120, moonY - 120, 240, 240);
        // Moon body
        ctx.fillStyle = '#445';
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(moonX, moonY, 35, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#556';
        ctx.globalAlpha = 0.25;
        ctx.beginPath();
        ctx.arc(moonX - 3, moonY - 2, 32, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
        
        // Moonlight beam onto grave
        ctx.globalAlpha = 0.04;
        ctx.fillStyle = '#aabbcc';
        ctx.beginPath();
        ctx.moveTo(moonX - 20, moonY + 35);
        ctx.lineTo(W/2 - 80, H * 0.7);
        ctx.lineTo(W/2 + 80, H * 0.7);
        ctx.lineTo(moonX + 20, moonY + 35);
        ctx.fill();
        ctx.globalAlpha = 1;
        
        // Rain effect
        ctx.strokeStyle = 'rgba(150,160,180,0.15)';
        ctx.lineWidth = 1;
        for (let rain = 0; rain < 60; rain++) {
          const rx = (rain * 43.7 + t * 80) % (W + 100) - 50;
          const ry = (rain * 67.3 + t * 250) % (H + 50) - 25;
          ctx.beginPath();
          ctx.moveTo(rx, ry);
          ctx.lineTo(rx - 2, ry + 12);
          ctx.stroke();
        }
        
        // Fog near ground — thicker, more layers
        const fogY = H * 0.62;
        for (let fg = 0; fg < 10; fg++) {
          const fgx = (fg * W/10 + Math.sin(t*0.3 + fg) * 50) % W;
          const fogGrad = ctx.createRadialGradient(fgx, fogY + 20, 10, fgx, fogY + 20, 120 + fg*15);
          fogGrad.addColorStop(0, `rgba(15,15,25,${0.15 + Math.sin(t*0.5+fg)*0.05})`);
          fogGrad.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = fogGrad;
          ctx.fillRect(fgx - 140, fogY - 40, 280, 120);
        }
        // Low-lying mist tendrils
        ctx.globalAlpha = 0.06;
        for (let mt = 0; mt < 15; mt++) {
          const mtx = (mt * 97 + t * 12) % W;
          const mty = fogY + 30 + Math.sin(t*0.8+mt)*15;
          ctx.fillStyle = '#aabbcc';
          ctx.beginPath();
          ctx.ellipse(mtx, mty, 50 + mt*5, 4, 0, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
        
        // Ground line with grass tufts
        const groundY = H * 0.7;
        ctx.fillStyle = '#121218';
        ctx.fillRect(0, groundY, W, H - groundY);
        // Dirt path
        ctx.fillStyle = '#18181e';
        ctx.fillRect(W*0.35, groundY, W*0.3, H - groundY);
        // Grass tufts along ground line
        ctx.strokeStyle = '#1a2a1a';
        ctx.lineWidth = 1;
        for (let gs = 0; gs < 40; gs++) {
          const gsx = gs * W/40 + Math.sin(gs*4)*5;
          for (let gb = 0; gb < 3; gb++) {
            ctx.beginPath();
            ctx.moveTo(gsx + gb*3, groundY);
            ctx.lineTo(gsx + gb*3 + Math.sin(t+gs+gb)*2, groundY - 4 - Math.random()*4);
            ctx.stroke();
          }
        }
        // Dirt texture
        ctx.fillStyle = '#ffffff02';
        for (let dt = 0; dt < 50; dt++) {
          ctx.fillRect((dt * 73) % W, groundY + (dt * 37) % (H*0.3), 1, 1);
        }
        
        // Dead tree on left side
        ctx.strokeStyle = '#1a1a22';
        ctx.lineWidth = 6;
        ctx.beginPath(); ctx.moveTo(W*0.12, groundY); ctx.lineTo(W*0.11, groundY - 140); ctx.stroke();
        ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(W*0.11, groundY - 100); ctx.lineTo(W*0.06, groundY - 160); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.11, groundY - 80); ctx.lineTo(W*0.16, groundY - 130); ctx.stroke();
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(W*0.06, groundY - 160); ctx.lineTo(W*0.04, groundY - 175); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.06, groundY - 160); ctx.lineTo(W*0.08, groundY - 180); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.16, groundY - 130); ctx.lineTo(W*0.18, groundY - 150); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.16, groundY - 130); ctx.lineTo(W*0.15, groundY - 155); ctx.stroke();
        
        // Dead tree on right
        ctx.lineWidth = 5;
        ctx.beginPath(); ctx.moveTo(W*0.92, groundY); ctx.lineTo(W*0.91, groundY - 120); ctx.stroke();
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(W*0.91, groundY - 80); ctx.lineTo(W*0.95, groundY - 140); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.91, groundY - 90); ctx.lineTo(W*0.87, groundY - 130); ctx.stroke();
        
        // Iron cemetery fence
        ctx.strokeStyle = '#222230';
        ctx.lineWidth = 2;
        const fenceY = groundY - 5;
        // Horizontal bars
        ctx.beginPath(); ctx.moveTo(0, fenceY - 25); ctx.lineTo(W*0.3, fenceY - 25); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.7, fenceY - 25); ctx.lineTo(W, fenceY - 25); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, fenceY - 10); ctx.lineTo(W*0.3, fenceY - 10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*0.7, fenceY - 10); ctx.lineTo(W, fenceY - 10); ctx.stroke();
        // Fence posts with pointed tops
        for (let fp = 0; fp < 20; fp++) {
          const fpx = fp * W/20 + 10;
          if (fpx < W*0.3 || fpx > W*0.7) {
            ctx.beginPath(); ctx.moveTo(fpx, fenceY); ctx.lineTo(fpx, fenceY - 35); ctx.stroke();
            // Pointed tip
            ctx.beginPath(); ctx.moveTo(fpx-3, fenceY - 35); ctx.lineTo(fpx, fenceY - 42); ctx.lineTo(fpx+3, fenceY - 35); ctx.closePath();
            ctx.fillStyle = '#222230'; ctx.fill();
          }
        }
        
        // Other graves — more varied, with crosses and flowers
        ctx.fillStyle = '#1e1e26';
        for (let g = 0; g < 8; g++) {
          const gx = W * 0.05 + g * W * 0.125;
          if (Math.abs(gx - W/2) > 90) {
            const gh = 28 + g*4;
            // Gravestone body
            ctx.fillRect(gx - 12, groundY - gh, 24, gh);
            ctx.beginPath();
            ctx.arc(gx, groundY - gh, 12, Math.PI, 0);
            ctx.fill();
            // Some have crosses
            if (g % 3 === 0) {
              ctx.fillStyle = '#2a2a34';
              ctx.fillRect(gx - 2, groundY - gh - 18, 4, 22);
              ctx.fillRect(gx - 8, groundY - gh - 10, 16, 4);
              ctx.fillStyle = '#1e1e26';
            }
            // Small flower at base of some graves
            if (g % 2 === 0) {
              ctx.fillStyle = '#2a1a2a';
              ctx.beginPath(); ctx.arc(gx + 15, groundY - 3, 4, 0, Math.PI*2); ctx.fill();
              ctx.fillStyle = '#1e1e26';
            }
          }
        }
        
        // MAIN gravestone — center, larger, more detailed
        const gsX = W/2, gsY = groundY;
        // Shadow behind grave
        ctx.fillStyle = '#0a0a10';
        ctx.beginPath();
        ctx.ellipse(gsX, gsY + 5, 50, 8, 0, 0, Math.PI*2);
        ctx.fill();
        // Stone base
        ctx.fillStyle = '#222228';
        ctx.fillRect(gsX - 45, gsY - 8, 90, 12);
        // Gravestone body with weathered texture
        ctx.fillStyle = '#2a2a30';
        ctx.fillRect(gsX - 38, gsY - 90, 76, 86);
        ctx.beginPath();
        ctx.arc(gsX, gsY - 90, 38, Math.PI, 0);
        ctx.fill();
        // Weathering / moss streaks
        ctx.fillStyle = '#1a2818';
        ctx.globalAlpha = 0.2;
        ctx.fillRect(gsX - 35, gsY - 30, 15, 25);
        ctx.fillRect(gsX + 15, gsY - 50, 12, 35);
        ctx.globalAlpha = 1;
        // Border carving
        ctx.strokeStyle = '#3a3a44';
        ctx.lineWidth = 1;
        ctx.strokeRect(gsX - 32, gsY - 83, 64, 75);
        // Decorative cross at top
        ctx.fillStyle = '#3a3a44';
        ctx.fillRect(gsX - 3, gsY - 120, 6, 22);
        ctx.fillRect(gsX - 10, gsY - 112, 20, 5);
        // Engraving — more text
        ctx.fillStyle = '#606068';
        ctx.font = `bold ${Math.min(12, W*0.016)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('STEPHEN', gsX, gsY - 65);
        ctx.fillText('WILLIAM', gsX, gsY - 52);
        ctx.fillText('HAWKING', gsX, gsY - 39);
        ctx.fillStyle = '#4a4a52';
        ctx.font = `${Math.min(9, W*0.012)}px monospace`;
        ctx.fillText('CH CBE FRS FRSA', gsX, gsY - 24);
        ctx.fillText('1942 - 2018', gsX, gsY - 12);
        // Latin inscription
        ctx.fillStyle = '#38383f';
        ctx.font = `italic ${Math.min(7, W*0.009)}px monospace`;
        ctx.fillText('AD ASTRA PER ASPERA', gsX, gsY - 1);
        // Wilted flowers at base
        ctx.fillStyle = '#2a1a2a';
        ctx.beginPath(); ctx.arc(gsX - 25, gsY - 5, 6, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(gsX - 18, gsY - 8, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#1a2818';
        ctx.fillRect(gsX - 28, gsY - 5, 3, 10);
        ctx.fillRect(gsX - 22, gsY - 8, 2, 12);
        
        // Phone on the grave
        const phoneBuzz = sp > 0.15 && sp < 0.45;
        const buzzOff = phoneBuzz ? Math.sin(t * 25) * 4 : 0;
        ctx.fillStyle = '#222';
        ctx.fillRect(gsX + 40 + buzzOff, gsY - 30, 22, 35);
        if (phoneBuzz) {
          // Screen glowing
          ctx.fillStyle = `rgba(255,200,0,${0.4 + Math.sin(t*8)*0.3})`;
          ctx.fillRect(gsX + 42 + buzzOff, gsY - 28, 18, 25);
          ctx.fillStyle = '#fff';
          ctx.font = '5px monospace';
          ctx.fillText('CALL', gsX + 51 + buzzOff, gsY - 15);
          // Buzz vibration rings
          ctx.strokeStyle = `rgba(255,200,0,${Math.sin(t*12)*0.3})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(gsX + 51 + buzzOff, gsY - 12, 20 + Math.sin(t*10)*5, 0, Math.PI*2);
          ctx.stroke();
        }
        
        // Phase 2: Ground starts cracking
        if (sp > 0.4) {
          const crackProg = (sp - 0.4) / 0.3;
          // Cracks emanating from grave
          ctx.strokeStyle = `rgba(255,200,0,${Math.min(0.8, crackProg)})`;
          ctx.lineWidth = 2 + crackProg * 2;
          const crackLen = crackProg * 200;
          // Left crack
          ctx.beginPath();
          ctx.moveTo(gsX - 20, gsY);
          ctx.lineTo(gsX - 20 - crackLen * 0.4, gsY + crackLen * 0.1);
          ctx.lineTo(gsX - 20 - crackLen * 0.7, gsY + crackLen * 0.05);
          ctx.stroke();
          // Right crack
          ctx.beginPath();
          ctx.moveTo(gsX + 20, gsY);
          ctx.lineTo(gsX + 20 + crackLen * 0.5, gsY + crackLen * 0.08);
          ctx.lineTo(gsX + 20 + crackLen * 0.8, gsY - crackLen * 0.03);
          ctx.stroke();
          // Center crack
          ctx.beginPath();
          ctx.moveTo(gsX, gsY);
          ctx.lineTo(gsX + crackLen * 0.1, gsY + crackLen * 0.3);
          ctx.stroke();
          
          // Green glow from underground
          const glowAlpha = crackProg * 0.5;
          const underGlow = ctx.createRadialGradient(gsX, gsY + 10, 5, gsX, gsY + 10, 100 + crackProg * 100);
          underGlow.addColorStop(0, `rgba(255,200,0,${glowAlpha})`);
          underGlow.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = underGlow;
          ctx.fillRect(gsX - 200, gsY - 50, 400, 150);
          
          // Screen shake effect
          if (crackProg > 0.3) {
            const shk = crackProg * 1.5;
            ctx.translate(Math.sin(t*30)*shk, Math.cos(t*25)*shk);
          }
        }
        
        // Phase 3: HE RISES
        if (sp > 0.7) {
          const riseProg = (sp - 0.7) / 0.3;
          
          // Lightning flash at start of rise
          if (riseProg < 0.08) {
            ctx.fillStyle = `rgba(255,200,0,${(0.08 - riseProg) * 8})`;
            ctx.fillRect(0, 0, W, H);
          }
          // Secondary flash
          if (riseProg > 0.15 && riseProg < 0.2) {
            ctx.fillStyle = `rgba(255,255,255,${(0.2 - riseProg) * 12})`;
            ctx.fillRect(0, 0, W, H);
          }
          
          // Screen shake intensifies
          const shk = riseProg * 3;
          ctx.translate(Math.sin(t*35)*shk, Math.cos(t*28)*shk);
          
          // Giant green pillar of light from grave
          if (riseProg > 0.1) {
            const pillarAlpha = Math.min(0.4, (riseProg - 0.1) * 0.8);
            const pillarGrad = ctx.createLinearGradient(gsX - 40, 0, gsX + 40, 0);
            pillarGrad.addColorStop(0, 'rgba(0,0,0,0)');
            pillarGrad.addColorStop(0.3, `rgba(255,200,0,${pillarAlpha * 0.5})`);
            pillarGrad.addColorStop(0.5, `rgba(255,200,0,${pillarAlpha})`);
            pillarGrad.addColorStop(0.7, `rgba(255,200,0,${pillarAlpha * 0.5})`);
            pillarGrad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = pillarGrad;
            ctx.fillRect(gsX - 80, 0, 160, gsY);
          }
          
          // Hawking rising from the ground — BIGGER
          const riseY = gsY - riseProg * 160;
          const hSize = Math.min(W * 0.25, 180);
          ctx.globalAlpha = Math.min(1, riseProg * 2);
          
          // Massive ethereal gold aura — multi-layered
          for (let aLayer = 0; aLayer < 3; aLayer++) {
            const aRad = hSize * (1.2 + aLayer * 0.5);
            const hAura = ctx.createRadialGradient(gsX, riseY + hSize*0.5, 10, gsX, riseY + hSize*0.5, aRad);
            hAura.addColorStop(0, `rgba(255,200,0,${(0.3 - aLayer*0.08) * riseProg})`);
            hAura.addColorStop(0.5, `rgba(255,200,0,${(0.1 - aLayer*0.03) * riseProg})`);
            hAura.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = hAura;
            ctx.beginPath();
            ctx.arc(gsX, riseY + hSize*0.5, aRad, 0, Math.PI*2);
            ctx.fill();
          }
          
          // The figure — triple shadow for ultra glow
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 50 + riseProg * 60;
          ctx.drawImage(hawkingGoldImg, gsX - hSize/2, riseY, hSize, imgH(hawkingGoldImg, hSize));
          ctx.drawImage(hawkingGoldImg, gsX - hSize/2, riseY, hSize, imgH(hawkingGoldImg, hSize));
          ctx.shadowBlur = 0;
          
          // Redraw ground/dirt ON TOP of Hawking so he emerges from behind the earth
          ctx.globalAlpha = 1;
          // Main ground fill
          ctx.fillStyle = '#121218';
          ctx.fillRect(0, gsY, W, H - gsY);
          // Dirt path on top
          ctx.fillStyle = '#18181e';
          ctx.fillRect(W*0.35, gsY, W*0.3, H - gsY);
          // Dirt mound around grave for depth
          ctx.fillStyle = '#121218';
          ctx.beginPath();
          ctx.ellipse(gsX, gsY + 5, 100, 18, 0, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = '#1a1a20';
          ctx.beginPath();
          ctx.ellipse(gsX, gsY + 2, 70, 12, 0, 0, Math.PI*2);
          ctx.fill();
          // Dirt texture re-draw
          ctx.fillStyle = '#ffffff02';
          for (let dt = 0; dt < 50; dt++) {
            ctx.fillRect((dt * 73) % W, gsY + (dt * 37) % (H*0.3), 1, 1);
          }
          
          // Dirt/debris flying up — MORE pieces, varied sizes
          for (let d = 0; d < 16; d++) {
            const dAngle = (d / 16) * Math.PI * 2 + t * 2;
            const dDist = 30 + d * 12 + Math.sin(t*3 + d) * 15;
            const dx = gsX + Math.cos(dAngle) * dDist;
            const dy = gsY - riseProg * (20 + d*15) + Math.sin(d + t*4) * 12;
            ctx.fillStyle = d % 3 === 0 ? '#4a4a40' : '#2a2a20';
            ctx.globalAlpha = Math.max(0, 1 - riseProg * 1.2);
            const dSize = 3 + d%5;
            ctx.save();
            ctx.translate(dx, dy);
            ctx.rotate(t * 3 + d);
            ctx.fillRect(-dSize/2, -dSize/2, dSize, dSize * 0.7);
            ctx.restore();
          }
          ctx.globalAlpha = 1;
          
          // Energy rings radiating outward — MORE rings
          if (riseProg > 0.2) {
            const ringProg = (riseProg - 0.2) / 0.8;
            for (let r = 0; r < 5; r++) {
              const rDelay = r * 0.12;
              const rp = Math.max(0, (ringProg - rDelay) / (1 - rDelay));
              if (rp <= 0) continue;
              const rr = rp * (120 + r * 70);
              ctx.strokeStyle = `rgba(255,200,0,${Math.max(0, (0.7 - rp * 0.8) * (1 - r*0.15))})`;
              ctx.lineWidth = 4 - r * 0.7;
              ctx.beginPath();
              ctx.arc(gsX, riseY + hSize*0.5, rr, 0, Math.PI*2);
              ctx.stroke();
            }
          }
          
          // Lightning bolts from sky to grave
          if (riseProg > 0.05 && riseProg < 0.5) {
            const lFreq = Math.sin(t*20);
            if (lFreq > 0.7) {
              ctx.strokeStyle = `rgba(255,200,0,0.6)`;
              ctx.lineWidth = 2;
              ctx.beginPath();
              let lx = gsX + (Math.random()-0.5)*40, ly = 0;
              ctx.moveTo(lx, ly);
              for (let seg = 0; seg < 8; seg++) {
                lx += (Math.random()-0.5) * 50;
                ly += gsY / 8;
                ctx.lineTo(lx, ly);
              }
              ctx.stroke();
            }
          }
        }
        
        // Dialogue — dramatic slow burn
        ctx.textAlign = 'center';
        if (sp < 0.15) {
          const locAlpha = Math.min(1, sp * 8);
          ctx.globalAlpha = locAlpha;
          ctx.fillStyle = '#555';
          ctx.font = `${Math.min(12, W*0.017)}px monospace`;
          ctx.fillText('WESTMINSTER ABBEY  \u2022  CAMBRIDGE, ENGLAND', W/2, H * 0.86);
          ctx.fillStyle = '#444';
          ctx.font = `${Math.min(10, W*0.014)}px monospace`;
          ctx.fillText('2:47 AM', W/2, H * 0.9);
          ctx.globalAlpha = 1;
        } else if (sp < 0.4) {
          const buzzAlpha = 0.6 + Math.sin(t*12) * 0.3;
          ctx.fillStyle = `rgba(255,200,0,${buzzAlpha})`;
          ctx.font = `italic ${Math.min(18, W*0.025)}px monospace`;
          ctx.fillText('*bzzzz . . . bzzzz . . . bzzzz . . .*', W/2, H * 0.88);
        } else if (sp < 0.7) {
          const crackAlpha = Math.min(1, (sp-0.4)*5);
          ctx.globalAlpha = crackAlpha;
          ctx.fillStyle = '#ffd700';
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 10;
          ctx.font = `italic ${Math.min(22, W*0.03)}px monospace`;
          const crackLine = sp < 0.55 ? '"Did you really think..."' : '"...death could stop me?"';
          ctx.fillText(crackLine, W/2, H * 0.88);
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1;
        } else {
          const riseProg = (sp - 0.7) / 0.3;
          ctx.fillStyle = '#ffd700';
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 25 + riseProg * 20;
          if (riseProg < 0.4) {
            const s1 = Math.min(1, riseProg * 4);
            ctx.font = `bold ${Math.min(26, W*0.036)}px monospace`;
            const line1 = '"THE UNIVERSE ISN\'T DONE WITH ME."';
            const c1 = Math.floor(line1.length * s1);
            ctx.fillText(line1.substring(0, c1), W/2, H * 0.87);
          } else {
            // Dramatic final line — grows larger
            const s2 = Math.min(1, (riseProg - 0.4) * 3);
            const finalSize = Math.min(36, W*0.048) * (1 + (1-s2)*0.3);
            ctx.font = `bold ${finalSize}px monospace`;
            ctx.fillText('"I. AM. INEVITABLE."', W/2, H * 0.87);
            ctx.fillText('"I. AM. INEVITABLE."', W/2, H * 0.87);
          }
          ctx.shadowBlur = 0;
        }
        ctx.restore();
      }
      
      // ═══ SCENE 7 (0.59-1.0): THE CABAL ASSEMBLED ═══
      if (prog >= 0.59) {
        const sp = (prog - 0.59) / 0.41;
        ctx.save();
        
        // Epic dark void background with nebula gradient
        const voidGrad = ctx.createRadialGradient(W/2, H*0.35, 50, W/2, H*0.35, H*1.2);
        voidGrad.addColorStop(0, '#0a0515');
        voidGrad.addColorStop(0.3, '#060310');
        voidGrad.addColorStop(0.6, '#030208');
        voidGrad.addColorStop(1, '#000000');
        ctx.fillStyle = voidGrad;
        ctx.fillRect(0, 0, W, H);
        
        // Distant stars in void — twinkling
        for (let vs = 0; vs < 80; vs++) {
          const vsx = (vs * 83.7) % W;
          const vsy = (vs * 47.3) % H;
          const twinkle = 0.1 + Math.sin(t * 2 + vs*2)*0.08 + Math.sin(t*3.7+vs*5)*0.05;
          ctx.fillStyle = `rgba(200,180,255,${twinkle})`;
          const starSize = vs % 7 === 0 ? 2 : 1;
          ctx.fillRect(vsx, vsy, starSize, starSize);
        }
        
        // Phase definitions for Scene 7:
        // 0.00-0.04: Darkness builds, energy gathers
        // 0.04-0.12: Trump spotlight reveal
        // 0.12-0.20: Epstein spotlight reveal
        // 0.20-0.28: Musk spotlight reveal
        // 0.28-0.36: Clinton spotlight reveal
        // 0.36-0.50: Dramatic pause → Hawking MASSIVE reveal
        // 0.50-0.65: All 5 assembled, energy connecting
        // 0.65-0.80: "THE FINAL STAND" title card
        // 0.80-1.00: Final dramatic build + info + fade
        
        const allCols = ['#ff4400','#8844ff','#4488ff','#cc2222','#44ff88'];
        const allImgs = [bossImg, epsteinImg, muskImg, clintonImg, hawkingImg];
        const allNames = ['TRUMP','EPSTEIN','MUSK','CLINTON','HAWKING'];
        const allTitles = ['The Tyrant','The Shadow','The Architect','The Schemer','THE MASTERMIND'];
        
        // Rotating energy vortex — builds with each reveal
        const vortexIntensity = Math.min(1, sp * 2);
        ctx.globalAlpha = 0.06 * vortexIntensity;
        for (let ring = 0; ring < 18; ring++) {
          const rAngle = t * (0.3 + ring * 0.08) + ring * 0.35;
          const rDist = 50 + ring * 28;
          ctx.strokeStyle = allCols[ring % 5];
          ctx.lineWidth = 3 - ring * 0.1;
          ctx.beginPath();
          ctx.arc(W/2, H*0.38, rDist, rAngle, rAngle + Math.PI * (0.6 + Math.sin(t + ring)*0.2));
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
        
        // Energy rays from center — color-coded, build with reveals
        if (sp > 0.04) {
          const rayAlpha = Math.min(0.08, (sp - 0.04) * 0.2);
          for (let c = 0; c < 15; c++) {
            const ray = t * 1.2 + c * (Math.PI*2/15);
            ctx.strokeStyle = allCols[c % 5];
            ctx.globalAlpha = rayAlpha;
            ctx.lineWidth = 2 + Math.sin(t*2 + c) * 1.5;
            ctx.beginPath();
            ctx.moveTo(W/2, H*0.38);
            ctx.lineTo(W/2 + Math.cos(ray) * W, H*0.38 + Math.sin(ray) * H);
            ctx.stroke();
          }
          ctx.globalAlpha = 1;
        }
        
        // Particle storm — builds up
        const pCount = Math.floor(Math.min(60, sp * 100));
        for (let pp = 0; pp < pCount; pp++) {
          const ppx = (pp * 47.3 + t * (30 + pp%3 * 10)) % W;
          const ppy = (pp * 31.7 + t * (50 + pp%4 * 8)) % H;
          ctx.fillStyle = allCols[pp % 5];
          ctx.globalAlpha = 0.15 + Math.sin(t*3 + pp) * 0.1;
          const ppSize = pp % 5 === 0 ? 3 : (pp % 3 === 0 ? 2 : 1);
          ctx.fillRect(ppx, ppy, ppSize, ppSize);
        }
        ctx.globalAlpha = 1;
        
        // Phase 0 (0-0.04): Dark energy gathering
        if (sp < 0.04) {
          const gatherProg = sp / 0.04;
          // Ominous text
          ctx.globalAlpha = Math.sin(gatherProg * Math.PI);
          ctx.fillStyle = '#666';
          ctx.font = `${Math.min(14, W*0.02)}px monospace`;
          ctx.textAlign = 'center';
          const txt = 'T H E Y   A R E   C O M I N G';
          const charCount = Math.floor(txt.length * gatherProg);
          ctx.fillText(txt.substring(0, charCount), W/2, H/2);
          ctx.globalAlpha = 1;
          // Low rumble pulse
          const rumble = Math.sin(t * 8) * gatherProg * 0.05;
          ctx.fillStyle = `rgba(100,0,0,${rumble})`;
          ctx.fillRect(0, 0, W, H);
        }
        
        // === CHARACTER REVEALS (sequential fade-in at assembly positions) ===
        const revealTimes = [0.04, 0.12, 0.20, 0.28, 0.38];
        const assemblyPos = [
          { x: 0.12, y: 0.35, s: 0.85 },    // Trump far left
          { x: 0.30, y: 0.35, s: 0.9 },      // Epstein inner left
          { x: 0.70, y: 0.35, s: 0.9 },      // Musk inner right
          { x: 0.88, y: 0.35, s: 0.85 },     // Clinton far right
          { x: 0.50, y: 0.18, s: 1.7 },      // Hawking CENTER, BIGGEST
        ];
        
        for (let i = 0; i < 5; i++) {
          if (sp < revealTimes[i]) continue;
          const isHawking = i === 4;
          const fadeProg = Math.min(1, (sp - revealTimes[i]) / 0.06);
          const fadeEase = 1 - Math.pow(1 - fadeProg, 3);
          
          const aPos = assemblyPos[i];
          const baseSize = Math.min(W * 0.11, 75);
          const pSize = baseSize * aPos.s;
          const px = W * aPos.x;
          const py = H * aPos.y;
          const pH = imgH(allImgs[i], pSize);
          const drawX = px - pSize / 2;
          const drawY = py;
          
          ctx.globalAlpha = fadeEase;
          
          // Colored energy pillar behind character
          const pillarW = isHawking ? 50 : 30;
          const pillarGrad = ctx.createLinearGradient(px - pillarW, 0, px + pillarW, 0);
          pillarGrad.addColorStop(0, 'rgba(0,0,0,0)');
          pillarGrad.addColorStop(0.5, allCols[i] + '15');
          pillarGrad.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = pillarGrad;
          ctx.fillRect(px - pillarW, 0, pillarW * 2, H);
          
          // Glow behind portrait
          const glowSize = pSize * (isHawking ? 2.5 : 2.0);
          const pGlow = ctx.createRadialGradient(px, drawY + pH*0.5, 5, px, drawY + pH*0.5, glowSize);
          pGlow.addColorStop(0, allCols[i] + (isHawking ? '88' : '55'));
          pGlow.addColorStop(0.3, allCols[i] + '25');
          pGlow.addColorStop(0.7, allCols[i] + '08');
          pGlow.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = pGlow;
          ctx.beginPath();
          ctx.arc(px, drawY + pH*0.5, glowSize, 0, Math.PI*2);
          ctx.fill();
          
          // Border frame with glow
          ctx.strokeStyle = allCols[i];
          ctx.lineWidth = isHawking ? 4 : 2;
          ctx.shadowColor = allCols[i];
          ctx.shadowBlur = isHawking ? 60 : 25;
          ctx.strokeRect(drawX - 6, drawY - 6, pSize + 12, pH + 12);
          ctx.shadowBlur = 0;
          
          // Portrait image
          ctx.drawImage(allImgs[i], drawX, drawY, pSize, pH);
          if (isHawking) {
            ctx.globalAlpha = fadeEase * 0.3;
            ctx.drawImage(allImgs[i], drawX - 3, drawY - 3, pSize + 6, pH + 6);
            ctx.globalAlpha = fadeEase;
          }
          
          // Corner accent decorations
          const cornerLen = isHawking ? 18 : 12;
          ctx.strokeStyle = allCols[i];
          ctx.lineWidth = isHawking ? 3 : 2;
          const fx = drawX - 6, fy = drawY - 6, fw = pSize + 12, fh = pH + 12;
          ctx.beginPath(); ctx.moveTo(fx, fy + cornerLen); ctx.lineTo(fx, fy); ctx.lineTo(fx + cornerLen, fy); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(fx + fw - cornerLen, fy); ctx.lineTo(fx + fw, fy); ctx.lineTo(fx + fw, fy + cornerLen); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(fx, fy + fh - cornerLen); ctx.lineTo(fx, fy + fh); ctx.lineTo(fx + cornerLen, fy + fh); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(fx + fw - cornerLen, fy + fh); ctx.lineTo(fx + fw, fy + fh); ctx.lineTo(fx + fw, fy + fh - cornerLen); ctx.stroke();
          
          // Impact shockwave on first appearance
          if (fadeProg < 0.3) {
            const shockProg = fadeProg / 0.3;
            const shockR = pSize * (1 + shockProg * (isHawking ? 5 : 3));
            ctx.globalAlpha = (1 - shockProg) * 0.7;
            ctx.strokeStyle = allCols[i];
            ctx.lineWidth = (isHawking ? 5 : 3) * (1 - shockProg);
            ctx.beginPath();
            ctx.arc(px, drawY + pH * 0.5, shockR, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = allCols[i];
            ctx.globalAlpha = (1 - shockProg) * (isHawking ? 0.25 : 0.12);
            ctx.fillRect(0, 0, W, H);
            ctx.globalAlpha = fadeEase;
          }
          
          // Name plate
          const npY = drawY + pH + 8;
          const npH = isHawking ? 50 : 32;
          const npW = pSize + 20;
          const npX = px - npW / 2;
          const plateGrad = ctx.createLinearGradient(npX, npY, npX, npY + npH);
          plateGrad.addColorStop(0, '#111111ee');
          plateGrad.addColorStop(1, '#000000ee');
          ctx.fillStyle = plateGrad;
          ctx.fillRect(npX, npY, npW, npH);
          ctx.strokeStyle = allCols[i] + '88';
          ctx.lineWidth = 1;
          ctx.strokeRect(npX, npY, npW, npH);
          ctx.fillStyle = allCols[i];
          const nameSize = isHawking ? 20 : 13;
          ctx.font = `bold ${nameSize}px monospace`;
          ctx.textAlign = 'center';
          ctx.shadowColor = allCols[i];
          ctx.shadowBlur = 12;
          ctx.fillText(allNames[i], px, npY + nameSize + 2);
          ctx.shadowBlur = 0;
          const titleSize = isHawking ? 12 : 9;
          ctx.fillStyle = isHawking ? '#ffd700' : '#999';
          ctx.font = `${isHawking ? 'bold ' : ''}${titleSize}px monospace`;
          ctx.fillText(allTitles[i], px, npY + nameSize + titleSize + 6);
        }
        
        // Dramatic pause before Hawking (0.36-0.38): screen flickers, tension builds
        if (sp > 0.34 && sp < 0.38) {
          const tensionProg = (sp - 0.34) / 0.04;
          // Rapid flicker
          const flicker = Math.sin(t * 30) * Math.sin(t * 17) * Math.sin(t * 43);
          if (flicker > 0.3) {
            ctx.fillStyle = `rgba(255,200,0,${tensionProg * 0.15})`;
            ctx.fillRect(0, 0, W, H);
          }
          // "?" text building
          ctx.fillStyle = `rgba(255,200,0,${tensionProg * 0.5})`;
          ctx.font = `bold ${60 + Math.sin(t*8)*10}px monospace`;
          ctx.textAlign = 'center';
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 40;
          ctx.fillText('?', W/2, H/2 + 20);
          ctx.shadowBlur = 0;
        }
        
        // Pentagram pattern connecting 5 points (appears during assembly)
        if (sp > 0.52) {
          const pentAlpha = Math.min(0.06, (sp - 0.52) * 0.2);
          ctx.globalAlpha = pentAlpha + Math.sin(t*1.5)*0.02;
          ctx.strokeStyle = '#ffdd44';
          ctx.lineWidth = 1;
          const pentR = 250;
          const pentPoints = [];
          for (let pp2 = 0; pp2 < 5; pp2++) {
            const pAngle = (pp2 / 5) * Math.PI * 2 - Math.PI/2 + t * 0.1;
            pentPoints.push({ x: W/2 + Math.cos(pAngle) * pentR, y: H*0.38 + Math.sin(pAngle) * pentR * 0.7 });
          }
          ctx.beginPath();
          ctx.moveTo(pentPoints[0].x, pentPoints[0].y);
          ctx.lineTo(pentPoints[2].x, pentPoints[2].y);
          ctx.lineTo(pentPoints[4].x, pentPoints[4].y);
          ctx.lineTo(pentPoints[1].x, pentPoints[1].y);
          ctx.lineTo(pentPoints[3].x, pentPoints[3].y);
          ctx.closePath();
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
        
        // Energy connection lines between assembled bosses
        if (sp > 0.55) {
          const connAlpha = Math.min(0.3, (sp - 0.55) * 0.6);
          ctx.globalAlpha = connAlpha;
          for (let a = 0; a < 5; a++) {
            for (let b = a + 1; b < 5; b++) {
              const ax = W * assemblyPos[a].x, ay = H * assemblyPos[a].y + 50;
              const bx = W * assemblyPos[b].x, by = H * assemblyPos[b].y + 50;
              // Animated energy flow along connection
              ctx.strokeStyle = allCols[a];
              ctx.lineWidth = 1;
              ctx.beginPath(); ctx.moveTo(ax, ay); ctx.lineTo(bx, by); ctx.stroke();
              // Moving energy dot along line
              const dotProg = (t * 0.5 + a * 0.3 + b * 0.7) % 1;
              const dotX = ax + (bx - ax) * dotProg;
              const dotY = ay + (by - ay) * dotProg;
              ctx.fillStyle = allCols[a];
              ctx.globalAlpha = connAlpha * 0.8;
              ctx.beginPath(); ctx.arc(dotX, dotY, 3, 0, Math.PI*2); ctx.fill();
              ctx.globalAlpha = connAlpha;
            }
          }
          ctx.globalAlpha = 1;
        }
        
        // === "VS" SCREEN (0.60-0.65) - "YOU vs THE CABAL" ===
        if (sp > 0.60 && sp < 0.70) {
          const vsProg = (sp - 0.60) / 0.10;
          const vsEase = 1 - Math.pow(1 - Math.min(1, vsProg * 2), 3);
          ctx.globalAlpha = vsEase * (vsProg > 0.7 ? Math.max(0, 1 - (vsProg - 0.7) / 0.3) : 1);
          
          // Dramatic diagonal split line
          ctx.strokeStyle = '#ffdd44';
          ctx.lineWidth = 4;
          ctx.shadowColor = '#ffdd44';
          ctx.shadowBlur = 30;
          ctx.beginPath();
          ctx.moveTo(W * 0.45, 0);
          ctx.lineTo(W * 0.55, H);
          ctx.stroke();
          ctx.shadowBlur = 0;
          
          // "VS" text with massive glow
          const vsSize = Math.min(80, W * 0.1) * (1 + Math.sin(t * 4) * 0.05);
          ctx.fillStyle = '#ffdd44';
          ctx.font = `bold ${vsSize}px monospace`;
          ctx.textAlign = 'center';
          ctx.shadowColor = '#ff4400';
          ctx.shadowBlur = 80;
          ctx.fillText('VS', W/2, H/2 + vsSize * 0.3);
          ctx.shadowColor = '#ffdd44';
          ctx.shadowBlur = 40;
          ctx.fillText('VS', W/2, H/2 + vsSize * 0.3);
          ctx.shadowBlur = 0;
          
          // "YOU" on left
          ctx.fillStyle = '#4488ff';
          ctx.font = `bold ${Math.min(30, W*0.04)}px monospace`;
          ctx.shadowColor = '#4488ff';
          ctx.shadowBlur = 20;
          ctx.fillText('Y O U', W * 0.25, H/2 + 10);
          ctx.shadowBlur = 0;
          
          // "THE CABAL" on right  
          ctx.fillStyle = '#ff4400';
          ctx.font = `bold ${Math.min(26, W*0.035)}px monospace`;
          ctx.shadowColor = '#ff4400';
          ctx.shadowBlur = 20;
          ctx.fillText('T H E  C A B A L', W * 0.75, H/2 + 10);
          ctx.shadowBlur = 0;
          
          ctx.globalAlpha = 1;
        }
        
        // === THE FINAL STAND TITLE CARD (0.70-0.95) ===
        if (sp > 0.65) {
          const titleProg = Math.min(1, (sp - 0.65) / 0.15);
          const titleEase = 1 - Math.pow(1 - titleProg, 3);
          ctx.globalAlpha = titleEase;
          
          // Gradient title bar — wider, more dramatic
          const barGrad = ctx.createLinearGradient(0, H * 0.62, 0, H * 0.98);
          barGrad.addColorStop(0, 'rgba(0,0,0,0)');
          barGrad.addColorStop(0.08, 'rgba(0,0,0,0.9)');
          barGrad.addColorStop(0.92, 'rgba(0,0,0,0.9)');
          barGrad.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = barGrad;
          ctx.fillRect(0, H * 0.62, W, H * 0.36);
          
          // Gold border lines — animated expansion
          const lineExpand = Math.min(1, titleProg * 2);
          const lineHalf = W * 0.4 * lineExpand;
          ctx.strokeStyle = '#ffdd44';
          ctx.lineWidth = 2;
          ctx.globalAlpha = titleEase * 0.7;
          ctx.beginPath(); ctx.moveTo(W/2 - lineHalf, H * 0.66); ctx.lineTo(W/2 + lineHalf, H * 0.66); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(W/2 - lineHalf, H * 0.95); ctx.lineTo(W/2 + lineHalf, H * 0.95); ctx.stroke();
          // Decorative diamonds on line ends
          const diaPos = [[W/2 - lineHalf, H*0.66], [W/2 + lineHalf, H*0.66], [W/2 - lineHalf, H*0.95], [W/2 + lineHalf, H*0.95]];
          for (const dp of diaPos) {
            if (lineExpand > 0.5) {
              ctx.save();
              ctx.translate(dp[0], dp[1]);
              ctx.rotate(Math.PI/4);
              ctx.fillStyle = '#ffdd44';
              ctx.fillRect(-3, -3, 6, 6);
              ctx.restore();
            }
          }
          ctx.globalAlpha = titleEase;
          
          // Main title — MASSIVE with triple glow
          ctx.fillStyle = '#ffdd44';
          const titleSize = Math.min(56, W * 0.07) * (1 + (1-titleEase)*0.5);
          ctx.font = `bold ${titleSize}px monospace`;
          ctx.textAlign = 'center';
          // Layer 1: red outer glow
          ctx.shadowColor = '#ff4400';
          ctx.shadowBlur = 80;
          ctx.fillText('\u2605 THE FINAL STAND \u2605', W/2, H * 0.74);
          // Layer 2: orange mid glow
          ctx.shadowColor = '#ff8844';
          ctx.shadowBlur = 50;
          ctx.fillText('\u2605 THE FINAL STAND \u2605', W/2, H * 0.74);
          // Layer 3: gold inner glow
          ctx.shadowColor = '#ffdd44';
          ctx.shadowBlur = 25;
          ctx.fillText('\u2605 THE FINAL STAND \u2605', W/2, H * 0.74);
          ctx.shadowBlur = 0;
          
          // Subtitle — typewriter effect
          if (sp > 0.72) {
            const subProg = Math.min(1, (sp - 0.72) / 0.08);
            ctx.globalAlpha = subProg;
            ctx.fillStyle = '#ff8844';
            ctx.font = `bold ${Math.min(22, W*0.03)}px monospace`;
            const subText = 'DEFEAT THEM ALL.  HAWKING IS LAST.';
            const subChars = Math.floor(subText.length * subProg);
            ctx.fillText(subText.substring(0, subChars), W/2, H * 0.80);
          }
          
          // Shield warning with pulse
          if (sp > 0.78) {
            const warnProg = Math.min(1, (sp - 0.78) / 0.06);
            ctx.globalAlpha = warnProg;
            const warnPulse = 0.7 + Math.sin(t * 4) * 0.3;
            ctx.fillStyle = `rgba(68,170,255,${warnPulse})`;
            ctx.font = `bold ${Math.min(15, W*0.02)}px monospace`;
            ctx.shadowColor = '#44aaff';
            ctx.shadowBlur = 15;
            ctx.fillText('\u26a1 HAWKING IS SHIELDED UNTIL OTHERS FALL \u26a1', W/2, H * 0.86);
            ctx.shadowBlur = 0;
          }
          
          // HP indicator
          if (sp > 0.82) {
            const hpProg = Math.min(1, (sp - 0.82) / 0.05);
            ctx.globalAlpha = hpProg;
            ctx.fillStyle = '#44ff88';
            ctx.font = `bold ${Math.min(18, W*0.024)}px monospace`;
            ctx.shadowColor = '#44ff88';
            ctx.shadowBlur = 10;
            ctx.fillText('\u2764 HP: 50 / 50', W/2, H * 0.92);
            ctx.shadowBlur = 0;
          }
          
          // "GET READY" flashing text at the very end
          if (sp > 0.90) {
            const readyProg = (sp - 0.90) / 0.10;
            const readyFlash = Math.sin(t * 6) > 0 ? 1 : 0.3;
            ctx.globalAlpha = readyProg * readyFlash;
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${Math.min(28, W*0.038)}px monospace`;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 20;
            ctx.fillText('G E T   R E A D Y', W/2, H * 0.58);
            ctx.shadowBlur = 0;
          }
        }
        ctx.globalAlpha = 1;
        ctx.restore();
      }
      
      // Scene transition — glitch/static effect (ENHANCED with smash cuts)
      const scenes = [0.03, 0.055, 0.14, 0.24, 0.34, 0.44, 0.59];
      for (const s of scenes) {
        const dist = Math.abs(prog - s);
        if (dist < 0.02) {
          const glitchIntensity = 1 - dist / 0.02;
          // Hard white flash — SMASH CUT
          ctx.fillStyle = `rgba(255,255,255,${glitchIntensity * 0.7})`;
          ctx.fillRect(0, 0, W, H);
          // Glitch bars — more and wider
          for (let gb = 0; gb < 12; gb++) {
            const gy = Math.random() * H;
            const gHt = 2 + Math.random() * 15;
            ctx.fillStyle = `rgba(${Math.random()>0.5?255:0},${Math.random()>0.5?255:0},${Math.random()>0.5?255:0},${glitchIntensity * 0.4})`;
            ctx.fillRect(0, gy, W, gHt);
          }
          // Horizontal shift — more dramatic
          if (glitchIntensity > 0.3) {
            for (let sl = 0; sl < 3; sl++) {
              const slice = Math.floor(Math.random() * H);
              const sliceH = 10 + Math.random() * 40;
              ctx.drawImage(canvas, 0, slice, W, sliceH, (Math.random()-0.5)*40 * glitchIntensity, slice, W, sliceH);
            }
          }
          // RGB split / chromatic aberration
          if (glitchIntensity > 0.5) {
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = `rgba(255,0,0,${glitchIntensity * 0.08})`;
            ctx.fillRect(-3, 0, W, H);
            ctx.fillStyle = `rgba(0,0,255,${glitchIntensity * 0.08})`;
            ctx.fillRect(3, 0, W, H);
            ctx.globalCompositeOperation = 'source-over';
          }
          // Noise burst
          ctx.globalAlpha = glitchIntensity * 0.15;
          for (let n = 0; n < 80; n++) {
            ctx.fillStyle = Math.random() > 0.5 ? '#fff' : '#000';
            ctx.fillRect(Math.random() * W, Math.random() * H, Math.random() * 4 + 1, Math.random() * 2 + 1);
          }
          ctx.globalAlpha = 1;
        }
      }
      
      // Heartbeat pulse overlay — intensifies near end
      const heartRate = prog > 0.5 ? 5.0 : 3.5;
      const heartbeat = Math.pow(Math.sin(t * heartRate), 20);
      if (heartbeat > 0.1) {
        const hbIntensity = prog > 0.5 ? 0.15 : 0.08;
        ctx.fillStyle = `rgba(100,0,0,${heartbeat * hbIntensity})`;
        ctx.fillRect(0, 0, W, H);
      }
      
      // Close global zoom transform
      ctx.restore();
      
      // Vignette overlay — gets darker toward edges as tension builds
      const vigIntensity = 0.3 + prog * 0.4;
      const vigGrad = ctx.createRadialGradient(W/2, H/2, W*0.25, W/2, H/2, W*0.75);
      vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
      vigGrad.addColorStop(0.6, `rgba(0,0,0,${vigIntensity * 0.3})`);
      vigGrad.addColorStop(1, `rgba(0,0,0,${vigIntensity})`);
      ctx.fillStyle = vigGrad;
      ctx.fillRect(0, 0, W, H);
      
      // Letterbox bars throughout — animated slide in, THICKER for cinematic feel
      const barSlide = Math.min(1, prog * 8);
      const actualBarH = (barH + 15) * barSlide;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, actualBarH);
      ctx.fillRect(0, H - actualBarH, W, actualBarH);
      // Gold trim with glow — double lines
      if (actualBarH > 2) {
        ctx.fillStyle = '#ffdd4422';
        ctx.fillRect(0, actualBarH - 2, W, 2);
        ctx.fillRect(0, H - actualBarH, W, 2);
        ctx.fillStyle = '#ffdd4411';
        ctx.fillRect(0, actualBarH - 4, W, 1);
        ctx.fillRect(0, H - actualBarH + 2, W, 1);
        // Moving gold accent — TWO accents moving opposite directions
        const accentX = (t * 80) % W;
        const accentX2 = (W - (t * 120) % W);
        ctx.fillStyle = '#ffdd4455';
        ctx.fillRect(accentX, actualBarH - 2, 100, 2);
        ctx.fillRect(W - accentX - 100, H - actualBarH, 100, 2);
        ctx.fillStyle = '#ffdd4433';
        ctx.fillRect(accentX2, actualBarH - 2, 50, 2);
        ctx.fillRect(W - accentX2 - 50, H - actualBarH, 50, 2);
      }
      
      // Scene counter in top letterbox bar
      const sceneNum = prog < 0.03 ? 0 : prog < 0.055 ? 1 : prog < 0.14 ? 2 : prog < 0.24 ? 3 : prog < 0.34 ? 4 : prog < 0.44 ? 5 : prog < 0.59 ? 6 : 7;
      if (sceneNum > 0 && sceneNum < 7 && actualBarH > 20) {
        ctx.fillStyle = '#ffffff22';
        ctx.font = `${Math.min(9, W*0.012)}px monospace`;
        ctx.textAlign = 'left';
        ctx.fillText(`SCENE ${sceneNum} / 7`, 15, actualBarH - 8);
        // Progress bar in letterbox
        const scProgress = prog < 0.59 ? prog / 0.59 : 1;
        ctx.fillStyle = '#ffffff11';
        ctx.fillRect(W * 0.3, actualBarH - 5, W * 0.4, 2);
        ctx.fillStyle = '#ffdd4444';
        ctx.fillRect(W * 0.3, actualBarH - 5, W * 0.4 * scProgress, 2);
      }
      
      // Film grain overlay — more grain
      ctx.globalAlpha = 0.04;
      for (let gg = 0; gg < 350; gg++) {
        const gx = Math.random() * W;
        const gy = Math.random() * H;
        ctx.fillStyle = Math.random() > 0.5 ? '#fff' : '#000';
        ctx.fillRect(gx, gy, Math.random() > 0.8 ? 2 : 1, 1);
      }
      ctx.globalAlpha = 1;
      
      // Scanline effect (subtle CRT feel)
      ctx.globalAlpha = 0.015;
      for (let sl = 0; sl < H; sl += 3) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, sl, W, 1);
      }
      ctx.globalAlpha = 1;
      
      // Final dramatic fade to white before fight begins (last 3% of cinematic)
      if (prog > 0.97) {
        const fadeOut = (prog - 0.97) / 0.03;
        ctx.fillStyle = `rgba(255,255,255,${fadeOut * fadeOut})`;
        ctx.fillRect(0, 0, W, H);
      }
      
      // Skip hint — fading in
      if (prog > 0.05) {
        ctx.fillStyle = `rgba(255,255,255,${Math.min(0.25, (prog-0.05)*0.4)})`;
        ctx.font = '10px monospace';
        ctx.textAlign = 'right';
        ctx.fillText('CLICK TO SKIP \u25B6', W - 20, actualBarH - 8);
      }
    }
    
    // Player HP
    const hpW = 200;
    ctx.fillStyle = '#00000099';
    ctx.fillRect(15, 8, hpW + 14, 30);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(17, 10, hpW + 10, 26);
    const phpPctS = player.hp / player.maxHp;
    const phpGradS = ctx.createLinearGradient(22, 0, 22 + hpW, 0);
    const phpColsS = cbHP(phpPctS);
    phpGradS.addColorStop(0, phpColsS.a);
    phpGradS.addColorStop(1, phpColsS.b);
    ctx.fillStyle = phpGradS;
    ctx.fillRect(22, 14, hpW * phpPctS, 18);
    ctx.fillStyle = `rgba(255,255,255,${Math.sin(Date.now()/200)*0.1+0.1})`;
    ctx.fillRect(22, 14, hpW * phpPctS * 0.5, 6);
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(22, 14, hpW, 18);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`\u2764 ${player.hp}/${player.maxHp}`, 28, 29);

    // Mini-boss HP bars at top — show remaining count
    const alive = miniBosses.filter(m => !m.dead);
    const total = miniBosses.length;
    const miniBossW = Math.min(400, W - 260);
    ctx.fillStyle = '#000000cc';
    ctx.fillRect(Math.max(240, W/2 - miniBossW/2), 5, miniBossW, 38);
    ctx.fillStyle = '#ff8844';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#ff4400';
    ctx.shadowBlur = 8;
    const othersUp = miniBosses.filter(m => !m.dead && m.name !== 'HAWKING').length;
    const statusText = hawkingPhase2 ? '★★ HAWKING TRANSCENDED ★★' : (othersUp === 0 ? '★ HAWKING EXPOSED ★' : `DEFEAT THEM ALL  (${total - alive.length}/${total})`);
    ctx.fillStyle = hawkingPhase2 ? '#ffd700' : (othersUp === 0 ? '#44ff88' : '#ff8844');
    ctx.fillText(statusText, W/2, 19);
    ctx.shadowBlur = 0;

    // Mini HP bars for each alive mini-boss
    const startX = W/2 - (alive.length * 55) / 2;
    alive.forEach((mb, i) => {
      const bx = startX + i * 55;
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(bx, 25, 50, 10);
      // Hawking: if shielded, show pulsing bar (gold if phase 2)
      const isShielded = mb.name === 'HAWKING' && othersUp > 0;
      const shieldBarCol = hawkingPhase2 ? [255,200,0] : [68,255,136];
      ctx.fillStyle = isShielded ? `rgba(${shieldBarCol},${0.3 + Math.sin(Date.now()/200)*0.2})` : mb.color;
      ctx.fillRect(bx, 25, 50 * (mb.hp / mb.maxHp), 10);
      ctx.strokeStyle = isShielded ? (hawkingPhase2 ? '#ffd700' : '#44ff88') : '#ffffff33';
      ctx.lineWidth = isShielded ? 2 : 1;
      ctx.strokeRect(bx, 25, 50, 10);
      ctx.fillStyle = '#fff';
      ctx.font = '6px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(isShielded ? '🛡' + mb.name : mb.name, bx + 25, 33);
    });

    // Touch controls
    drawTouchButtons();

    ctx.fillStyle = '#ffffff55';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(_isTouchDev ? 'Defeat them all!' : 'Defeat them all!  |  Click/F Throw  |  \u2190 \u2192 Move  |  \u2191/Space Jump', W / 2, H - 10);
  }

  // ── Cutscene Drawing ──
  if (state === 'cutscene') {
    // Black overlay fading in
    ctx.fillStyle = `rgba(0, 0, 0, ${cutscene.fadeAlpha})`;
    ctx.fillRect(0, 0, W, H);

    if (cutscene.phase >= 1) {
      // Full black
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      // Red vignette
      const vigGrad = ctx.createRadialGradient(W/2, H/2, H*0.25, W/2, H/2, H*0.8);
      vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
      vigGrad.addColorStop(1, 'rgba(180,0,0,0.4)');
      ctx.fillStyle = vigGrad;
      ctx.fillRect(0, 0, W, H);

      // Dramatic speed lines
      ctx.strokeStyle = '#ff222233';
      ctx.lineWidth = 2;
      for (let i = 0; i < 20; i++) {
        const lx = (i * 97 + cutscene.timer * 2) % (W + 200) - 100;
        ctx.beginPath();
        ctx.moveTo(lx, 0);
        ctx.lineTo(lx - 50, H);
        ctx.stroke();
      }

      // Boss portrait - large centered
      const imgW = Math.min(W * 0.35, 350);
      const imgH = imgW * 1.3;
      const imgX = W / 2 - imgW / 2;
      const imgY = H * 0.06;

      // Gold frame
      ctx.fillStyle = '#daa520';
      ctx.fillRect(imgX - 8, imgY - 8, imgW + 16, imgH + 16);
      ctx.fillStyle = '#b8860b';
      ctx.fillRect(imgX - 4, imgY - 4, imgW + 8, imgH + 8);

      // Trump image
      ctx.drawImage(bossIntroImg, imgX, imgY, imgW, imgH);

      // White flash on reveal
      if (cutscene.phase === 1 && cutscene.timer < 15) {
        ctx.fillStyle = `rgba(255, 255, 255, ${1 - cutscene.timer / 15})`;
        ctx.fillRect(0, 0, W, H);
      }

      // Title
      const titleY = imgY + imgH + 45;
      ctx.shadowColor = '#ff4444';
      ctx.shadowBlur = 20;
      ctx.fillStyle = '#ff2222';
      ctx.font = `bold ${Math.min(48, W * 0.06)}px monospace`;
      ctx.textAlign = 'center';
      ctx.fillText('\u2605 BOSS ENCOUNTER \u2605', W / 2, titleY);
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#ffcc00';
      ctx.font = `bold ${Math.min(36, W * 0.045)}px monospace`;
      ctx.fillText('DONALD J. TRUMP', W / 2, titleY + 38);

      ctx.fillStyle = '#ccc';
      ctx.font = `${Math.min(16, W * 0.022)}px monospace`;
      ctx.fillText('"The Wall Builder"', W / 2, titleY + 60);

      if (cutscene.phase === 1) {
        const blink = Math.sin(Date.now() / 300) > 0;
        if (blink) {
          ctx.fillStyle = '#888';
          ctx.font = '14px monospace';
          ctx.fillText(_isTouchDev ? '[ Tap to continue ]' : '[ Click / Press SPACE to continue ]', W / 2, H - 40);
        }
      }

      // Dialogue phase
      if (cutscene.phase === 2 && cutscene.dialogueIndex < cutscene.dialogues.length) {
        const dialogueText = cutscene.dialogues[cutscene.dialogueIndex];

        // Dialogue box
        const boxH = 110;
        const boxY = H - boxH - 30;
        ctx.fillStyle = '#111111ee';
        ctx.fillRect(40, boxY, W - 80, boxH);
        ctx.strokeStyle = '#daa520';
        ctx.lineWidth = 3;
        ctx.strokeRect(40, boxY, W - 80, boxH);

        // Speaker name
        ctx.fillStyle = '#ff4444';
        ctx.font = 'bold 18px monospace';
        ctx.textAlign = 'left';
        ctx.fillText('TRUMP:', 65, boxY + 30);

        // Typewriter dialogue
        const charsToShow = Math.min(dialogueText.length, Math.floor(cutscene.timer * 0.8));
        const visibleText = dialogueText.substring(0, charsToShow);
        ctx.fillStyle = '#fff';
        ctx.font = '16px monospace';
        ctx.fillText(visibleText, 65, boxY + 62);

        // Continue prompt
        if (charsToShow >= dialogueText.length) {
          const blink = Math.sin(Date.now() / 300) > 0;
          if (blink) {
            ctx.fillStyle = '#888';
            ctx.font = '12px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(_isTouchDev ? '[ Tap \u25ba ]' : '[ Click / SPACE \u25ba ]', W - 55, boxY + boxH - 14);
          }
        }
      }

      // Fading out phase
      if (cutscene.phase === 3) {
        ctx.fillStyle = `rgba(0, 0, 0, ${1 - cutscene.fadeAlpha})`;
        ctx.fillRect(0, 0, W, H);
      }
      
      // SKIP button (top-right)
      ctx.fillStyle = '#ffffff33';
      ctx.fillRect(W - 110, 10, 100, 30);
      ctx.strokeStyle = '#ffffff55';
      ctx.lineWidth = 1;
      ctx.strokeRect(W - 110, 10, 100, 30);
      ctx.fillStyle = '#ccc';
      ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('SKIP ▶▶', W - 60, 30);
    }
  }

  // ── Boss Mid-Fight Dialogue Drawing ──
  if (state === 'bossdialogue' && bossDialogue.active) {
    // Semi-transparent overlay — arena stays visible behind
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.fillRect(0, 0, W, H);

    // Red energy border pulse
    const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
    ctx.strokeStyle = `rgba(255, 50, 0, ${pulse * 0.5})`;
    ctx.lineWidth = 4;
    ctx.strokeRect(20, 20, W - 40, H - 40);

    // Phase announcement
    const phaseNum = boss ? boss.phase : 2;
    const phaseNames = { 2: 'PHASE 2: ENRAGED', 3: 'PHASE 3: FINAL FORM' };
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 30;
    ctx.fillStyle = phaseNum === 3 ? '#ff0000' : '#ff6600';
    ctx.font = `bold ${Math.min(42, W * 0.05)}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(phaseNames[phaseNum] || 'PHASE SHIFT', W / 2, H * 0.2);
    ctx.shadowBlur = 0;

    // Trump portrait (left side)
    const portW = Math.min(140, W * 0.15);
    const portH = portW * 1.3;
    const portX = 60;
    const portY = H * 0.35;

    // Gold frame for portrait
    ctx.fillStyle = '#daa520';
    ctx.fillRect(portX - 4, portY - 4, portW + 8, portH + 8);
    ctx.fillStyle = '#b8860b';
    ctx.fillRect(portX - 2, portY - 2, portW + 4, portH + 4);
    ctx.drawImage(bossIntroImg, portX, portY, portW, portH);

    // Red tint on portrait based on phase
    ctx.fillStyle = phaseNum === 3 ? 'rgba(255, 0, 0, 0.25)' : 'rgba(255, 100, 0, 0.15)';
    ctx.fillRect(portX, portY, portW, portH);

    // Dialogue box
    const boxX = portX + portW + 30;
    const boxW = W - boxX - 60;
    const boxH = 120;
    const boxY = portY + portH / 2 - boxH / 2;

    ctx.fillStyle = '#111111ee';
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.strokeStyle = phaseNum === 3 ? '#ff2222' : '#daa520';
    ctx.lineWidth = 3;
    ctx.strokeRect(boxX, boxY, boxW, boxH);

    // Speaker name
    ctx.fillStyle = phaseNum === 3 ? '#ff0000' : '#ff4444';
    ctx.font = 'bold 18px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('TRUMP:', boxX + 20, boxY + 30);

    // Typewriter dialogue text
    if (bossDialogue.index < bossDialogue.texts.length) {
      const dialogueText = bossDialogue.texts[bossDialogue.index];
      const charsToShow = Math.min(dialogueText.length, Math.floor(bossDialogue.timer * 0.8));
      const visibleText = dialogueText.substring(0, charsToShow);

      ctx.fillStyle = '#fff';
      ctx.font = '15px monospace';
      // Word wrap
      const maxLineW = boxW - 40;
      const words = visibleText.split(' ');
      let line = '';
      let lineY = boxY + 60;
      for (const word of words) {
        const testLine = line + word + ' ';
        if (ctx.measureText(testLine).width > maxLineW && line.length > 0) {
          ctx.fillText(line.trim(), boxX + 20, lineY);
          line = word + ' ';
          lineY += 22;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line.trim(), boxX + 20, lineY);

      // Continue prompt
      if (charsToShow >= dialogueText.length) {
        const blink = Math.sin(Date.now() / 300) > 0;
        if (blink) {
          ctx.fillStyle = '#888';
          ctx.font = '12px monospace';
          ctx.textAlign = 'right';
          ctx.fillText(_isTouchDev ? '[ Tap ▸ ]' : '[ Click / SPACE ▸ ]', boxX + boxW - 15, boxY + boxH - 12);
        }
      }
    }

    // Dialogue progress dots
    ctx.textAlign = 'center';
    for (let d = 0; d < bossDialogue.texts.length; d++) {
      ctx.fillStyle = d <= bossDialogue.index ? '#ff6644' : '#555';
      ctx.beginPath();
      ctx.arc(W / 2 - (bossDialogue.texts.length - 1) * 10 + d * 20, H * 0.85, 5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // SKIP button for boss dialogue
    ctx.fillStyle = '#ffffff33';
    ctx.fillRect(W - 110, 10, 100, 28);
    ctx.strokeStyle = '#ffffff55';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 110, 10, 100, 28);
    ctx.fillStyle = '#ccc';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SKIP \u25b6\u25b6', W - 60, 28);
  }

  // ── Screens ──
  
  // ── CINEMATIC INTRO ──
  if (state === 'intro') {
    // Phase 0: Pure black
    if (introPhase === 0) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
      // Subtle breathing dots
      const dotAlpha = 0.3 + 0.2 * Math.sin(introTimer * 0.1);
      ctx.fillStyle = `rgba(240, 192, 64, ${dotAlpha})`;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(W/2 - 20 + i * 20, H/2, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Phase 1: Title SLAM
    if (introPhase === 1) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
      
      // Title drops in with scale
      const titleProgress = Math.min(1, introTimer / 20);
      const titleScale = titleProgress < 1 ? 3 - 2 * titleProgress : 1;
      const titleAlpha = Math.min(1, introTimer / 15);
      const titleShake = introTimer < 15 ? (15 - introTimer) * 0.5 * Math.sin(introTimer * 2) : 0;
      
      ctx.save();
      ctx.translate(W/2 + titleShake, H/2 - 40);
      ctx.scale(titleScale, titleScale);
      ctx.globalAlpha = titleAlpha;
      ctx.textAlign = 'center';
      ctx.font = 'bold 52px monospace';
      // Gold with glow
      ctx.shadowColor = '#f0c040';
      ctx.shadowBlur = 30;
      ctx.fillStyle = '#f0c040';
      ctx.fillText('CRUZA LA FRONTERA', 0, 0);
      ctx.shadowBlur = 0;
      ctx.restore();
      
      // Impact flash on first frames
      if (introTimer < 8) {
        ctx.fillStyle = `rgba(255, 220, 100, ${(8 - introTimer) / 16})`;
        ctx.fillRect(0, 0, W, H);
      }
      
      // Sparks from title impact
      if (introTimer < 10) {
        for (let i = 0; i < 5; i++) {
          const sx = W/2 + (Math.random() - 0.5) * 400;
          const sy = H/2 - 40 + (Math.random() - 0.5) * 30;
          ctx.fillStyle = `rgba(255, ${180 + Math.random()*75}, 50, ${Math.random()})`;
          ctx.fillRect(sx, sy, 2 + Math.random()*4, 2);
        }
      }
    }
    
    // Phase 2: Subtitle
    if (introPhase === 2) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
      
      // Title stays
      ctx.textAlign = 'center';
      ctx.font = 'bold 52px monospace';
      ctx.shadowColor = '#f0c040';
      ctx.shadowBlur = 20;
      ctx.fillStyle = '#f0c040';
      ctx.fillText('CRUZA LA FRONTERA', W/2, H/2 - 40);
      ctx.shadowBlur = 0;
      
      // Subtitle slides in
      const subProgress = Math.min(1, introTimer / 30);
      const subX = W/2 + (1 - subProgress) * 300;
      ctx.globalAlpha = subProgress;
      ctx.font = '18px monospace';
      ctx.fillStyle = '#ff6644';
      ctx.fillText('Cross the border. Fight the power. Survive.', subX, H/2 + 20);
      ctx.globalAlpha = 1;
      
      // Pulsing line under title
      const lineW = 300 * subProgress;
      ctx.strokeStyle = '#f0c04088';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(W/2 - lineW/2, H/2 - 15);
      ctx.lineTo(W/2 + lineW/2, H/2 - 15);
      ctx.stroke();
      
      // Controls hint
      if (introTimer > 40) {
        const hintAlpha = Math.min(1, (introTimer - 40) / 20);
        ctx.globalAlpha = hintAlpha * 0.6;
        ctx.font = '13px monospace';
        ctx.fillStyle = '#888';
        ctx.fillText(_isTouchDev ? 'Use on-screen controls to play' : 'Arrow Keys / WASD to move · Space / Up to jump · F to throw', W/2, H/2 + 60);
        ctx.globalAlpha = 1;
      }
    }
    
    // Phase 3: Camera sweep (level is drawn behind, we add overlay)
    if (introPhase === 3) {
      // Darken edges for cinematic look
      const grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, 'rgba(0,0,0,0.5)');
      grad.addColorStop(0.3, 'rgba(0,0,0,0.1)');
      grad.addColorStop(0.7, 'rgba(0,0,0,0.1)');
      grad.addColorStop(1, 'rgba(0,0,0,0.5)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);
      
      // Sweep text
      ctx.textAlign = 'center';
      ctx.font = 'bold 16px monospace';
      ctx.fillStyle = '#f0c04088';
      ctx.fillText('THE BORDER...', W/2, H * 0.15);
      
      // Draw intro particles
      for (const ip of introParticles) {
        ctx.globalAlpha = ip.life / 60;
        ctx.fillStyle = ip.color;
        ctx.fillRect(ip.x - cameraX, ip.y, ip.size, ip.size);
      }
      ctx.globalAlpha = 1;
      
      // Skip hint
      if (introTimer > 60) {
        const skipAlpha = 0.4 + 0.2 * Math.sin(Date.now() / 400);
        ctx.globalAlpha = skipAlpha;
        ctx.font = '12px monospace';
        ctx.fillStyle = '#aaa';
        ctx.fillText(_isTouchDev ? 'Tap to skip' : 'Press SPACE to skip', W/2, H * 0.9);
        ctx.globalAlpha = 1;
      }
    }
    
    // Phase 4: Zoom to player
    if (introPhase === 4) {
      const grad2 = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, W * 0.7);
      grad2.addColorStop(0, 'rgba(0,0,0,0)');
      grad2.addColorStop(1, 'rgba(0,0,0,0.6)');
      ctx.fillStyle = grad2;
      ctx.fillRect(0, 0, W, H);
      
      ctx.textAlign = 'center';
      ctx.font = 'bold 20px monospace';
      ctx.fillStyle = '#88ff88';
      const readyAlpha = Math.min(1, introTimer / 20);
      ctx.globalAlpha = readyAlpha;
      ctx.fillText('GET READY...', W/2, H * 0.2);
      ctx.globalAlpha = 1;
    }
    
    // Phase 5: GO! flash
    if (introPhase === 5) {
      if (introTimer < 30) {
        const goScale = 1 + (30 - introTimer) / 30 * 2;
        const goAlpha = introTimer < 20 ? 1 : (30 - introTimer) / 10;
        ctx.save();
        ctx.translate(W/2, H/2);
        ctx.scale(goScale, goScale);
        ctx.globalAlpha = goAlpha;
        ctx.textAlign = 'center';
        ctx.font = 'bold 72px monospace';
        ctx.shadowColor = '#88ff88';
        ctx.shadowBlur = 40;
        ctx.fillStyle = '#88ff88';
        ctx.fillText('¡VAMOS!', 0, 0);
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }
    
    // Touch controls during intro (phase 3+ when player can move)
    if (introPhase >= 3) drawTouchButtons();

    // Cinematic letterbox bars for all phases
    const barH2 = introPhase >= 3 ? 50 : (introPhase >= 1 ? 35 : 0);
    if (barH2 > 0) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, barH2);
      ctx.fillRect(0, H - barH2, W, barH2);
    }
  }

  } // end if (state !== 'menu') — skip game-world rendering
  
  if (state === 'menu') {
    // ── ANIMATED BACKGROUND (Geometry Dash style) ──
    // Dark desert sky bg
    const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
    bgGrad.addColorStop(0, '#0a0515');
    bgGrad.addColorStop(0.5, '#1a0a2e');
    bgGrad.addColorStop(0.8, '#2a1020');
    bgGrad.addColorStop(1, '#0a0515');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);
    
    // Scrolling stars
    ctx.fillStyle = '#ffffff33';
    for (let i = 0; i < 50; i++) {
      const sx = ((i * 137 + menuBgTimer * 0.3) % (W + 20));
      const sy = (i * 97 + 30) % (H * 0.6);
      ctx.fillRect(sx, sy, 1 + (i % 3), 1);
    }
    
    // Ground
    ctx.fillStyle = '#3a2515';
    ctx.fillRect(0, menuBgFloorY, W, H - menuBgFloorY);
    ctx.fillStyle = '#5a3520';
    ctx.fillRect(0, menuBgFloorY, W, 4);
    
    // Scrolling ground pattern
    ctx.fillStyle = '#2a1a0a';
    for (let i = 0; i < 30; i++) {
      const gx = ((i * 80 - menuBgTimer * 2) % (W + 80)) - 40;
      ctx.fillRect(gx, menuBgFloorY + 10, 30, 3);
      ctx.fillRect(gx + 40, menuBgFloorY + 25, 20, 3);
    }
    
    // Draw bullets (red glowing)
    for (const b of menuBgBullets) {
      ctx.shadowColor = '#ff4444';
      ctx.shadowBlur = 8;
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    // Draw runners (using actual player/guard images)
    for (let ri = 0; ri < menuBgRunners.length; ri++) {
      const r = menuBgRunners[ri];
      ctx.globalAlpha = 0.6;
      ctx.save();
      // Slight bob to simulate running
      const bob = Math.sin(r.frame * Math.PI / 2) * 3;
      const mrW = r.w * PLAYER_IMG_SCALE;
      const mrH = r.h * PLAYER_IMG_SCALE;
      const mrOffX = (r.w - mrW) / 2;
      const mrOffY = r.h - mrH;
      ctx.drawImage(playerImg, r.x + mrOffX, r.y + mrOffY + bob, mrW, mrH);
      // Trail effect
      ctx.globalAlpha = 0.15;
      for (let t = 1; t <= 3; t++) {
        ctx.drawImage(playerImg, r.x + mrOffX - t * 18, r.y + mrOffY + bob, mrW, mrH);
      }
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    // Draw a guard shooter on the right side — REMOVED
    
    // Foreground overlay
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(0, 0, W, H);
    
    ctx.textAlign = 'center';
    
    // ── TITLE with glow effect ──
    const titlePulse = 1 + Math.sin(Date.now() / 600) * 0.03;
    ctx.save();
    ctx.translate(W/2, H * 0.18);
    ctx.scale(titlePulse, titlePulse);
    ctx.shadowColor = '#f0c040';
    ctx.shadowBlur = 30;
    ctx.fillStyle = '#f0c040';
    ctx.font = `bold ${Math.min(56, W * 0.07)}px monospace`;
    ctx.fillText('CRUZA LA FRONTERA', 0, 0);
    ctx.shadowBlur = 15;
    ctx.fillText('CRUZA LA FRONTERA', 0, 0);
    ctx.shadowBlur = 0;
    ctx.restore();
    
    // Subtitle
    ctx.fillStyle = '#cc6644';
    ctx.font = `${Math.min(16, W * 0.022)}px monospace`;
    ctx.fillText('Cross the Border · Fight the Power · Survive', W/2, H * 0.24);
    
    // Decorative line
    const lineW2 = 300;
    ctx.strokeStyle = '#f0c04066';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(W/2 - lineW2/2, H * 0.27);
    ctx.lineTo(W/2 + lineW2/2, H * 0.27);
    ctx.stroke();
    
    // ── MENU OPTIONS ──
    // Helper: draw custom menu icons
    function drawMenuIcon(type, x, y, size, color) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      const s = size;
      if (type === 'play') {
        // Triangle play button
        ctx.beginPath();
        ctx.moveTo(x - s*0.4, y - s*0.5);
        ctx.lineTo(x + s*0.5, y);
        ctx.lineTo(x - s*0.4, y + s*0.5);
        ctx.closePath();
        ctx.fill();
      } else if (type === 'difficulty') {
        // Crossed swords
        ctx.beginPath();
        ctx.moveTo(x - s*0.5, y - s*0.5);
        ctx.lineTo(x + s*0.5, y + s*0.5);
        ctx.moveTo(x + s*0.5, y - s*0.5);
        ctx.lineTo(x - s*0.5, y + s*0.5);
        ctx.stroke();
        // Hilts
        ctx.beginPath();
        ctx.moveTo(x - s*0.2, y - s*0.1);
        ctx.lineTo(x + s*0.2, y - s*0.1);
        ctx.moveTo(x - s*0.2, y + s*0.1);
        ctx.lineTo(x + s*0.2, y + s*0.1);
        ctx.stroke();
      } else if (type === 'settings') {
        // Gear — circle with teeth
        ctx.beginPath();
        ctx.arc(x, y, s*0.25, 0, Math.PI*2);
        ctx.stroke();
        for (let a = 0; a < 6; a++) {
          const angle = a * Math.PI / 3;
          ctx.beginPath();
          ctx.moveTo(x + Math.cos(angle)*s*0.3, y + Math.sin(angle)*s*0.3);
          ctx.lineTo(x + Math.cos(angle)*s*0.5, y + Math.sin(angle)*s*0.5);
          ctx.stroke();
        }
      } else if (type === 'controls') {
        // Gamepad shape
        ctx.beginPath();
        ctx.roundRect(x - s*0.5, y - s*0.25, s, s*0.5, s*0.15);
        ctx.stroke();
        // D-pad
        ctx.fillRect(x - s*0.35, y - s*0.05, s*0.2, s*0.1);
        ctx.fillRect(x - s*0.3, y - s*0.15, s*0.1, s*0.3);
        // Buttons
        ctx.beginPath();
        ctx.arc(x + s*0.25, y - s*0.05, s*0.06, 0, Math.PI*2);
        ctx.arc(x + s*0.35, y + s*0.05, s*0.06, 0, Math.PI*2);
        ctx.fill();
      } else if (type === 'credits') {
        // Scroll/document
        ctx.beginPath();
        ctx.roundRect(x - s*0.3, y - s*0.45, s*0.6, s*0.9, s*0.05);
        ctx.stroke();
        // Lines on document
        for (let l = 0; l < 3; l++) {
          ctx.fillRect(x - s*0.15, y - s*0.2 + l * s*0.2, s*0.3, s*0.04);
        }
      } else if (type === 'easy') {
        // Smiley face
        ctx.beginPath();
        ctx.arc(x, y, s*0.4, 0, Math.PI*2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x - s*0.15, y - s*0.1, s*0.05, 0, Math.PI*2);
        ctx.arc(x + s*0.15, y - s*0.1, s*0.05, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x, y + s*0.05, s*0.2, 0.1, Math.PI - 0.1);
        ctx.stroke();
      } else if (type === 'normal') {
        // Neutral face
        ctx.beginPath();
        ctx.arc(x, y, s*0.4, 0, Math.PI*2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x - s*0.15, y - s*0.1, s*0.05, 0, Math.PI*2);
        ctx.arc(x + s*0.15, y - s*0.1, s*0.05, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x - s*0.15, y + s*0.15);
        ctx.lineTo(x + s*0.15, y + s*0.15);
        ctx.stroke();
      } else if (type === 'hard') {
        // Angry face
        ctx.beginPath();
        ctx.arc(x, y, s*0.4, 0, Math.PI*2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x - s*0.15, y - s*0.05, s*0.05, 0, Math.PI*2);
        ctx.arc(x + s*0.15, y - s*0.05, s*0.05, 0, Math.PI*2);
        ctx.fill();
        // Angry eyebrows
        ctx.beginPath();
        ctx.moveTo(x - s*0.25, y - s*0.2);
        ctx.lineTo(x - s*0.08, y - s*0.15);
        ctx.moveTo(x + s*0.25, y - s*0.2);
        ctx.lineTo(x + s*0.08, y - s*0.15);
        ctx.stroke();
        // Frown
        ctx.beginPath();
        ctx.arc(x, y + s*0.25, s*0.15, Math.PI + 0.3, -0.3);
        ctx.stroke();
      } else if (type === 'insane') {
        // Skull
        ctx.beginPath();
        ctx.arc(x, y - s*0.1, s*0.35, Math.PI, 0);
        ctx.lineTo(x + s*0.35, y + s*0.15);
        ctx.lineTo(x + s*0.15, y + s*0.4);
        ctx.lineTo(x + s*0.05, y + s*0.3);
        ctx.lineTo(x - s*0.05, y + s*0.4);
        ctx.lineTo(x - s*0.15, y + s*0.3);
        ctx.lineTo(x - s*0.35, y + s*0.15);
        ctx.closePath();
        ctx.stroke();
        // Eyes
        ctx.beginPath();
        ctx.arc(x - s*0.15, y - s*0.05, s*0.08, 0, Math.PI*2);
        ctx.arc(x + s*0.15, y - s*0.05, s*0.08, 0, Math.PI*2);
        ctx.fill();
        // Nose
        ctx.beginPath();
        ctx.moveTo(x, y + s*0.05);
        ctx.lineTo(x - s*0.05, y + s*0.15);
        ctx.lineTo(x + s*0.05, y + s*0.15);
        ctx.closePath();
        ctx.fill();
      } else if (type === 'move') {
        // Left-right arrows
        ctx.beginPath();
        ctx.moveTo(x - s*0.5, y);
        ctx.lineTo(x - s*0.2, y - s*0.3);
        ctx.moveTo(x - s*0.5, y);
        ctx.lineTo(x - s*0.2, y + s*0.3);
        ctx.moveTo(x + s*0.5, y);
        ctx.lineTo(x + s*0.2, y - s*0.3);
        ctx.moveTo(x + s*0.5, y);
        ctx.lineTo(x + s*0.2, y + s*0.3);
        ctx.moveTo(x - s*0.5, y);
        ctx.lineTo(x + s*0.5, y);
        ctx.stroke();
      } else if (type === 'jump') {
        // Up arrow
        ctx.beginPath();
        ctx.moveTo(x, y - s*0.5);
        ctx.lineTo(x - s*0.3, y);
        ctx.moveTo(x, y - s*0.5);
        ctx.lineTo(x + s*0.3, y);
        ctx.moveTo(x, y - s*0.5);
        ctx.lineTo(x, y + s*0.5);
        ctx.stroke();
      } else if (type === 'combat') {
        // Crosshair
        ctx.beginPath();
        ctx.arc(x, y, s*0.35, 0, Math.PI*2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y - s*0.5);
        ctx.lineTo(x, y + s*0.5);
        ctx.moveTo(x - s*0.5, y);
        ctx.lineTo(x + s*0.5, y);
        ctx.stroke();
      } else if (type === 'wall') {
        // Brick wall
        ctx.strokeRect(x - s*0.4, y - s*0.4, s*0.8, s*0.8);
        ctx.beginPath();
        ctx.moveTo(x - s*0.4, y - s*0.13); ctx.lineTo(x + s*0.4, y - s*0.13);
        ctx.moveTo(x - s*0.4, y + s*0.13); ctx.lineTo(x + s*0.4, y + s*0.13);
        ctx.moveTo(x, y - s*0.4); ctx.lineTo(x, y - s*0.13);
        ctx.moveTo(x - s*0.2, y - s*0.13); ctx.lineTo(x - s*0.2, y + s*0.13);
        ctx.moveTo(x + s*0.2, y + s*0.13); ctx.lineTo(x + s*0.2, y + s*0.4);
        ctx.stroke();
      } else if (type === 'tip') {
        // Lightbulb
        ctx.beginPath();
        ctx.arc(x, y - s*0.1, s*0.3, Math.PI*0.8, Math.PI*0.2, true);
        ctx.lineTo(x + s*0.15, y + s*0.2);
        ctx.lineTo(x - s*0.15, y + s*0.2);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x - s*0.12, y + s*0.3);
        ctx.lineTo(x + s*0.12, y + s*0.3);
        ctx.moveTo(x - s*0.08, y + s*0.38);
        ctx.lineTo(x + s*0.08, y + s*0.38);
        ctx.stroke();
      }
      ctx.restore();
    }

    if (menuState === 'main') {
      const optionNames = ['PLAY', 'MULTIPLAYER', 'DIFFICULTY', 'SETTINGS', 'CONTROLS', 'FRIENDS', 'CREDITS', 'CHEATS'];
      const optionIcons = ['play', 'controls', 'difficulty', 'settings', 'controls', 'credits', 'credits', 'settings'];
      const menuY = H * 0.35;
      for (let i = 0; i < optionNames.length; i++) {
        const selected = menuSelection === i;
        const y = menuY + i * 40;
        
        if (selected) {
          const selW = 280;
          ctx.fillStyle = '#f0c04022';
          ctx.fillRect(W/2 - selW/2, y - 16, selW, 32);
          ctx.strokeStyle = '#f0c040';
          ctx.lineWidth = 2;
          ctx.strokeRect(W/2 - selW/2, y - 16, selW, 32);
          
          ctx.fillStyle = '#f0c040';
          ctx.font = 'bold 19px monospace';
          ctx.shadowColor = '#f0c040';
          ctx.shadowBlur = 10;
        } else {
          ctx.fillStyle = '#aaa';
          ctx.font = '16px monospace';
          ctx.shadowBlur = 0;
        }
        drawMenuIcon(optionIcons[i], W/2 - 80, y, 18, selected ? '#f0c040' : '#aaa');
        ctx.fillText(optionNames[i], W/2 + 20, y + 5);
        ctx.shadowBlur = 0;
      }
      
      // Logged in indicator
      if (playerUsername) {
        ctx.fillStyle = '#88ff88';
        ctx.font = '11px monospace';
        ctx.fillText(`Logged in: ${playerUsername}`, W/2, H * 0.79);
      }
      
      // Current difficulty badge
      ctx.fillStyle = '#666';
      ctx.font = '12px monospace';
      ctx.fillText(`Difficulty: ${settings.difficulty.toUpperCase()}`, W/2, H * 0.84);
      
      ctx.fillStyle = '#555';
      ctx.font = '11px monospace';
      ctx.fillText(_isTouchDev ? 'Tap to select' : 'Click / Tap / Arrow Keys + ENTER', W/2, H * 0.89);
      
      ctx.fillStyle = '#333';
      ctx.font = '10px monospace';
      ctx.fillText('v3.0', W/2, H * 0.94);
      
    } else if (menuState === 'multiplayer') {
      // ── MULTIPLAYER SCREEN ──
      ctx.fillStyle = '#44bbff';
      ctx.font = 'bold 28px monospace';
      ctx.fillText('MULTIPLAYER', W/2, H * 0.28);
      
      const mpItems = ['CREATE ROOM', 'JOIN ROOM', 'FRIENDS', 'BACK'];
      const mpColors = ['#88ff88', '#ffcc44', '#88ccff', '#ff8844'];
      const mpY = H * 0.40;
      for (let i = 0; i < mpItems.length; i++) {
        const selected = mpMenuSelection === i;
        const y = mpY + i * 50;
        
        if (selected) {
          ctx.fillStyle = mpColors[i] + '22';
          ctx.fillRect(W/2 - 160, y - 20, 320, 40);
          ctx.strokeStyle = mpColors[i];
          ctx.lineWidth = 2;
          ctx.strokeRect(W/2 - 160, y - 20, 320, 40);
          ctx.fillStyle = mpColors[i];
          ctx.font = 'bold 20px monospace';
        } else {
          ctx.fillStyle = '#aaa';
          ctx.font = '18px monospace';
        }
        ctx.fillText(mpItems[i], W/2, y + 6);
      }
      
      // Room code input overlay
      if (activeTextInput === 'roomcode') {
        ctx.fillStyle = '#000000cc';
        ctx.fillRect(W/2 - 200, H/2 - 60, 400, 120);
        ctx.strokeStyle = '#ffcc44';
        ctx.lineWidth = 2;
        ctx.strokeRect(W/2 - 200, H/2 - 60, 400, 120);
        ctx.fillStyle = '#ffcc44';
        ctx.font = 'bold 18px monospace';
        ctx.fillText('ENTER ROOM CODE', W/2, H/2 - 30);
        // Input box
        ctx.fillStyle = '#111';
        ctx.fillRect(W/2 - 100, H/2 - 10, 200, 36);
        ctx.strokeStyle = '#ffcc44';
        ctx.strokeRect(W/2 - 100, H/2 - 10, 200, 36);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px monospace';
        const cursor = textCursorBlink < 30 ? '|' : '';
        ctx.fillText(joinRoomInput + cursor, W/2, H/2 + 16);
        ctx.fillStyle = '#888';
        ctx.font = '12px monospace';
        ctx.fillText(_isTouchDev ? 'Type 6-letter code' : 'Type 6-letter code + ENTER', W/2, H/2 + 48);
      }
      
      if (!playerUsername) {
        ctx.fillStyle = '#ff8844';
        ctx.font = '14px monospace';
        ctx.fillText('You need an account to play multiplayer', W/2, H * 0.78);
        ctx.fillStyle = '#ffcc44';
        ctx.font = 'bold 14px monospace';
        ctx.fillText('[ Click here to Login / Register ]', W/2, H * 0.83);
      } else {
        // Show logged-in status + logout option
        ctx.fillStyle = '#88ff88';
        ctx.font = '12px monospace';
        ctx.fillText('Logged in as: ' + playerUsername, W/2, H * 0.72);
        const logoutSel = mpMenuSelection === 4;
        ctx.fillStyle = logoutSel ? '#ff6666' : '#aa6666';
        ctx.font = (logoutSel ? 'bold ' : '') + '13px monospace';
        ctx.fillText('[ LOGOUT ]', W/2, H * 0.77);
      }
      
      if (authError) {
        ctx.fillStyle = '#ff4444';
        ctx.font = '13px monospace';
        ctx.fillText(authError, W/2, H * 0.87);
      }
      
      ctx.fillStyle = '#555';
      ctx.font = '12px monospace';
      ctx.fillText(_isTouchDev ? '< Tap to go back' : 'ESC to go back', W/2, H * 0.92);
      
    } else if (menuState === 'account') {
      // ── ACCOUNT SCREEN (Login / Register) ──
      ctx.fillStyle = '#44bbff';
      ctx.font = 'bold 26px monospace';
      ctx.fillText(authScreen === 'register' ? 'CREATE ACCOUNT' : 'LOGIN', W/2, H * 0.28);
      
      if (authLoading) {
        ctx.fillStyle = '#ffcc44';
        ctx.font = '16px monospace';
        ctx.fillText('Loading...', W/2, H * 0.5);
      } else {
        const accY = H * 0.38;
        
        // Username field
        ctx.fillStyle = '#888';
        ctx.font = '13px monospace';
        ctx.textAlign = 'left';
        ctx.fillText('Username:', W/2 - 140, accY);
        ctx.fillStyle = activeTextInput === 'username' ? '#222' : '#111';
        ctx.fillRect(W/2 - 140, accY + 4, 280, 28);
        ctx.strokeStyle = activeTextInput === 'username' ? '#ffcc44' : '#555';
        ctx.lineWidth = 1;
        ctx.strokeRect(W/2 - 140, accY + 4, 280, 28);
        ctx.fillStyle = '#fff';
        ctx.font = '14px monospace';
        ctx.fillText(authInputs.username + (activeTextInput === 'username' && textCursorBlink < 30 ? '|' : ''), W/2 - 132, accY + 22);
        
        // Password field
        const passY = accY + 45;
        ctx.fillStyle = '#888';
        ctx.font = '13px monospace';
        ctx.fillText('Password:', W/2 - 140, passY);
        ctx.fillStyle = activeTextInput === 'password' ? '#222' : '#111';
        ctx.fillRect(W/2 - 140, passY + 4, 280, 28);
        ctx.strokeStyle = activeTextInput === 'password' ? '#ffcc44' : '#555';
        ctx.strokeRect(W/2 - 140, passY + 4, 280, 28);
        ctx.fillStyle = '#fff';
        ctx.font = '14px monospace';
        ctx.fillText('*'.repeat(authInputs.password.length) + (activeTextInput === 'password' && textCursorBlink < 30 ? '|' : ''), W/2 - 132, passY + 22);
        
        // Confirm password (register only)
        let btnBaseY = passY + 60;
        if (authScreen === 'register') {
          const confY = passY + 45;
          ctx.fillStyle = '#888';
          ctx.font = '13px monospace';
          ctx.fillText('Confirm:', W/2 - 140, confY);
          ctx.fillStyle = activeTextInput === 'confirm' ? '#222' : '#111';
          ctx.fillRect(W/2 - 140, confY + 4, 280, 28);
          ctx.strokeStyle = activeTextInput === 'confirm' ? '#ffcc44' : '#555';
          ctx.strokeRect(W/2 - 140, confY + 4, 280, 28);
          ctx.fillStyle = '#fff';
          ctx.font = '14px monospace';
          ctx.fillText('*'.repeat(authInputs.confirm.length) + (activeTextInput === 'confirm' && textCursorBlink < 30 ? '|' : ''), W/2 - 132, confY + 22);
          btnBaseY = confY + 50;
        }
        
        ctx.textAlign = 'center';
        
        // Submit button
        ctx.fillStyle = '#88ff8833';
        ctx.fillRect(W/2 - 100, btnBaseY, 200, 32);
        ctx.strokeStyle = '#88ff88';
        ctx.lineWidth = 1;
        ctx.strokeRect(W/2 - 100, btnBaseY, 200, 32);
        ctx.fillStyle = '#88ff88';
        ctx.font = 'bold 16px monospace';
        ctx.fillText(authScreen === 'register' ? 'REGISTER' : 'LOGIN', W/2, btnBaseY + 22);
        
        // Toggle
        ctx.fillStyle = '#88ccff';
        ctx.font = '13px monospace';
        ctx.fillText(authScreen === 'login' ? 'No account? Click to Register' : 'Have account? Click to Login', W/2, btnBaseY + 55);
        
        // Guest
        ctx.fillStyle = '#aaa';
        ctx.font = '13px monospace';
        ctx.fillText('[ Play as Guest ]', W/2, btnBaseY + 80);
        
        // Tap hint
        ctx.fillStyle = '#666';
        ctx.font = '11px monospace';
        ctx.fillText('Tap a field to type', W/2, btnBaseY + 105);
      }
      
      if (authError) {
        ctx.fillStyle = '#ff4444';
        ctx.font = '13px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(authError, W/2, H * 0.88);
      }
      
      ctx.textAlign = 'center';
      ctx.fillStyle = '#555';
      ctx.font = '12px monospace';
      ctx.fillText(_isTouchDev ? '< Tap to go back' : 'ESC to go back', W/2, H * 0.94);
      
    } else if (menuState === 'lobby') {
      // ── LOBBY SCREEN ──
      ctx.fillStyle = '#44bbff';
      ctx.font = 'bold 22px monospace';
      ctx.fillText('LOBBY', W/2, H * 0.06);
      
      // Room code — displayed prominently with background
      const rcText = 'Room: ' + (currentRoom || '???');
      ctx.fillStyle = '#00000066';
      const rcW = ctx.measureText(rcText).width + 30;
      ctx.fillRect(W/2 - rcW/2, H * 0.09, rcW, 30);
      ctx.fillStyle = '#ffcc44';
      ctx.font = 'bold 16px monospace';
      ctx.fillText(rcText, W/2, H * 0.09 + 20);
      
      // === LEFT COLUMN: Players + Chat ===
      const colW = Math.min(230, (W - 30) / 2);
      const colL = W/2 - colW - 5;
      const colR = W/2 + 5;
      
      // Players list
      const pids = Object.keys(roomPlayers);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 13px monospace';
      ctx.textAlign = 'left';
      ctx.fillText('PLAYERS (' + pids.length + '/4)', colL, H * 0.20);
      const pListY = H * 0.24;
      for (let i = 0; i < pids.length; i++) {
        const rp = roomPlayers[pids[i]];
        const y = pListY + i * 22;
        const isMe = pids[i] === myUid();
        ctx.fillStyle = isMe ? '#ffcc44' : '#ccc';
        ctx.font = `${isMe ? 'bold ' : ''}12px monospace`;
        ctx.fillText((rp.username || 'Player') + (isMe ? ' (you)' : ''), colL + 4, y);
      }
      
      // Chat area (left column, below players)
      const chatBoxY = H * 0.42;
      const chatBoxH = H * 0.40;
      ctx.fillStyle = '#ffffff08';
      ctx.fillRect(colL, chatBoxY, colW, chatBoxH);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.strokeRect(colL, chatBoxY, colW, chatBoxH);
      
      ctx.fillStyle = '#666';
      ctx.font = 'bold 10px monospace';
      ctx.fillText('CHAT (tap to type)', colL + 4, chatBoxY - 4);
      
      const chatStartY = chatBoxY + 16;
      const maxChatVisible = Math.floor((chatBoxH - 30) / 16);
      const chatSlice = roomChat.slice(-maxChatVisible);
      for (let i = 0; i < chatSlice.length; i++) {
        const msg = chatSlice[i];
        ctx.fillStyle = '#88ccff';
        ctx.font = 'bold 10px monospace';
        ctx.fillText(msg.username + ':', colL + 4, chatStartY + i * 16);
        ctx.fillStyle = '#ccc';
        ctx.font = '10px monospace';
        ctx.fillText(msg.text, colL + 4 + (msg.username.length + 1) * 7, chatStartY + i * 16);
      }
      
      // Chat input
      if (chatOpen || activeTextInput === 'chat') {
        ctx.fillStyle = '#222';
        ctx.fillRect(colL + 2, chatBoxY + chatBoxH - 22, colW - 4, 20);
        ctx.strokeStyle = '#ffcc44';
        ctx.strokeRect(colL + 2, chatBoxY + chatBoxH - 22, colW - 4, 20);
        ctx.fillStyle = '#fff';
        ctx.font = '11px monospace';
        ctx.fillText(chatInput + (textCursorBlink < 30 ? '|' : ''), colL + 6, chatBoxY + chatBoxH - 7);
      }
      
      // === RIGHT COLUMN: Match Settings ===
      ctx.textAlign = 'left';
      ctx.fillStyle = '#ffcc44';
      ctx.font = 'bold 13px monospace';
      ctx.fillText('MATCH SETTINGS', colR, H * 0.20);
      
      if (!isHost) {
        ctx.fillStyle = '#888';
        ctx.font = '10px monospace';
        ctx.fillText('(Host controls)', colR, H * 0.23);
      }
      
      const settY = H * 0.26;
      const SETT_SPACING = _isTouchDev ? 34 : 26;
      const settItems = [
        { label: 'Difficulty', value: settings.difficulty.toUpperCase(), key: 'difficulty' },
        { label: 'Double Jump', value: settings.doubleJump ? 'ON' : 'OFF', key: 'doubleJump' },
        { label: 'God Mode', value: cheats.godMode ? 'ON' : 'OFF', key: 'godMode' },
        { label: 'One Hit Kill', value: cheats.oneHitKill ? 'ON' : 'OFF', key: 'oneHitKill' },
        { label: 'Infinite Jumps', value: cheats.infiniteJumps ? 'ON' : 'OFF', key: 'infiniteJumps' },
        { label: 'Speed Boost', value: cheats.speedBoost ? 'ON' : 'OFF', key: 'speedBoost' },
        { label: 'Big Projectiles', value: cheats.bigProjectiles ? 'ON' : 'OFF', key: 'bigProjectiles' },
        { label: 'No Cooldown', value: cheats.noCooldown ? 'ON' : 'OFF', key: 'noCooldown' },
      ];
      for (let i = 0; i < settItems.length; i++) {
        const y = settY + i * SETT_SPACING;
        const sel = isHost && mpSettingsSelection === i;
        // Touch-friendly row background
        if (_isTouchDev && isHost) {
          ctx.fillStyle = sel ? '#ffffff18' : (i % 2 === 0 ? '#ffffff08' : '#ffffff04');
          ctx.fillRect(colR, y - 12, colW, SETT_SPACING - 2);
        }
        ctx.fillStyle = sel ? '#ffcc44' : '#aaa';
        ctx.font = `${sel ? 'bold ' : ''}12px monospace`;
        ctx.fillText(settItems[i].label + ':', colR + 4, y);
        // Value (right-aligned)
        const valColor = settItems[i].value === 'ON' ? '#88ff88' : settItems[i].value === 'OFF' ? '#ff6666' : '#ffffff';
        ctx.fillStyle = sel ? '#ffffff' : valColor;
        ctx.font = `bold 12px monospace`;
        ctx.textAlign = 'right';
        ctx.fillText(settItems[i].value, colR + colW - 4, y);
        ctx.textAlign = 'left';
      }
      
      ctx.textAlign = 'center';
      
      // Start / Leave buttons
      if (isHost) {
        ctx.fillStyle = '#88ff8833';
        ctx.fillRect(W/2 - 100, H * 0.88, 200, 32);
        ctx.strokeStyle = '#88ff88';
        ctx.strokeRect(W/2 - 100, H * 0.88, 200, 32);
        ctx.fillStyle = '#88ff88';
        ctx.font = 'bold 16px monospace';
        ctx.fillText('START GAME', W/2, H * 0.88 + 22);
      } else {
        ctx.fillStyle = '#888';
        ctx.font = '14px monospace';
        ctx.fillText('Waiting for host to start...', W/2, H * 0.91);
      }
      
      // Leave button
      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 12px monospace';
      ctx.fillText('< LEAVE', 60, 28);
      
    } else if (menuState === 'friends') {
      // ── FRIENDS SCREEN ──
      ctx.fillStyle = '#88ccff';
      ctx.font = 'bold 26px monospace';
      ctx.fillText('FRIENDS', W/2, H * 0.18);
      
      if (!currentUser) {
        ctx.fillStyle = '#ff8844';
        ctx.font = '16px monospace';
        ctx.fillText('Login to use friends!', W/2, H * 0.5);
        ctx.fillStyle = '#555';
        ctx.font = '12px monospace';
        ctx.fillText(_isTouchDev ? '< Tap to go back' : 'ESC to go back', W/2, H * 0.9);
      } else {
        // Tabs
        const tabs = ['FRIENDS', 'REQUESTS', 'BLOCKED', 'ADD'];
        const tabW = W / 4;
        for (let i = 0; i < tabs.length; i++) {
          const tx = i * tabW;
          const selected = friendTab === i;
          ctx.fillStyle = selected ? '#88ccff22' : '#00000022';
          ctx.fillRect(tx, H * 0.25, tabW, H * 0.07);
          ctx.strokeStyle = selected ? '#88ccff' : '#444';
          ctx.lineWidth = 1;
          ctx.strokeRect(tx, H * 0.25, tabW, H * 0.07);
          ctx.fillStyle = selected ? '#88ccff' : '#888';
          ctx.font = `${selected ? 'bold ' : ''}13px monospace`;
          ctx.fillText(tabs[i], tx + tabW/2, H * 0.29);
        }
        
        const listY = H * 0.38;
        
        if (friendTab === 0) {
          // Friends list
          if (friendsList.length === 0) {
            ctx.fillStyle = '#666';
            ctx.font = '14px monospace';
            ctx.fillText('No friends yet', W/2, listY + 20);
          }
          for (let i = 0; i < friendsList.length; i++) {
            const f = friendsList[i];
            const y = listY + i * 36;
            const sel = friendMenuSelection === i;
            if (sel) {
              ctx.fillStyle = '#ffffff11';
              ctx.fillRect(W/2 - 200, y - 10, 400, 30);
            }
            ctx.fillStyle = f.online ? '#88ff88' : '#888';
            ctx.font = '14px monospace';
            ctx.textAlign = 'left';
            ctx.fillText((f.online ? '\u25CF ' : '\u25CB ') + f.username, W/2 - 180, y + 8);
            // Unfriend button
            ctx.fillStyle = '#ff4444';
            ctx.font = '11px monospace';
            ctx.textAlign = 'right';
            ctx.fillText('[REMOVE]', W/2 + 180, y + 8);
            ctx.textAlign = 'center';
          }
        } else if (friendTab === 1) {
          // Friend requests
          if (friendRequests.length === 0) {
            ctx.fillStyle = '#666';
            ctx.font = '14px monospace';
            ctx.fillText('No pending requests', W/2, listY + 20);
          }
          for (let i = 0; i < friendRequests.length; i++) {
            const r = friendRequests[i];
            const y = listY + i * 36;
            ctx.fillStyle = '#ccc';
            ctx.font = '14px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(r.username, W/2 - 180, y + 8);
            ctx.fillStyle = '#88ff88';
            ctx.font = '11px monospace';
            ctx.textAlign = 'right';
            ctx.fillText('[ACCEPT]', W/2 + 120, y + 8);
            ctx.fillStyle = '#ff4444';
            ctx.fillText('[DENY]', W/2 + 180, y + 8);
            ctx.textAlign = 'center';
          }
        } else if (friendTab === 2) {
          // Blocked
          if (blockedUsers.length === 0) {
            ctx.fillStyle = '#666';
            ctx.font = '14px monospace';
            ctx.fillText('No blocked users', W/2, listY + 20);
          }
          for (let i = 0; i < blockedUsers.length; i++) {
            const b = blockedUsers[i];
            const y = listY + i * 36;
            ctx.fillStyle = '#ff8844';
            ctx.font = '14px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(b.username, W/2 - 180, y + 8);
            ctx.fillStyle = '#88ff88';
            ctx.font = '11px monospace';
            ctx.textAlign = 'right';
            ctx.fillText('[UNBLOCK]', W/2 + 180, y + 8);
            ctx.textAlign = 'center';
          }
        } else if (friendTab === 3) {
          // Add friend
          ctx.fillStyle = '#ccc';
          ctx.font = '14px monospace';
          ctx.fillText('Enter username to add:', W/2, listY);
          
          ctx.fillStyle = activeTextInput === 'friendadd' ? '#222' : '#111';
          ctx.fillRect(W/2 - 140, listY + 10, 280, 30);
          ctx.strokeStyle = activeTextInput === 'friendadd' ? '#ffcc44' : '#555';
          ctx.lineWidth = 1;
          ctx.strokeRect(W/2 - 140, listY + 10, 280, 30);
          ctx.fillStyle = '#fff';
          ctx.font = '14px monospace';
          ctx.fillText(friendInput + (activeTextInput === 'friendadd' && textCursorBlink < 30 ? '|' : ''), W/2, listY + 30);
          
          ctx.fillStyle = '#888';
          ctx.font = '12px monospace';
          ctx.fillText('Tap field + type name + ENTER', W/2, listY + 60);
        }
        
        if (authError) {
          ctx.fillStyle = '#ff8844';
          ctx.font = '13px monospace';
          ctx.fillText(authError, W/2, H * 0.82);
        } else if (authSuccessMsg) {
          ctx.fillStyle = '#88ff88';
          ctx.font = '13px monospace';
          ctx.fillText(authSuccessMsg, W/2, H * 0.82);
        }
        
        ctx.fillStyle = '#555';
        ctx.font = '12px monospace';
        ctx.fillText(_isTouchDev ? 'Tap tabs to switch' : 'ESC to go back | \u2190 \u2192 tabs', W/2, H * 0.92);
      }
      
    } else if (menuState === 'difficulty') {
      // ── DIFFICULTY SCREEN ──
      ctx.fillStyle = '#f0c040';
      ctx.font = 'bold 28px monospace';
      drawMenuIcon('difficulty', W/2 - 130, H * 0.32 - 4, 22, '#f0c040');
      ctx.fillText('DIFFICULTY', W/2, H * 0.32);
      
      const diffs = [
        { name: 'EASY', desc: 'More HP, weaker enemies, slower bullets', color: '#88ff88', icon: 'easy' },
        { name: 'NORMAL', desc: 'Balanced challenge', color: '#ffdd44', icon: 'normal' },
        { name: 'HARD', desc: 'Less HP, tougher enemies, faster bullets', color: '#ff8844', icon: 'hard' },
        { name: 'INSANE', desc: 'Minimal HP, brutal enemies, insane speed', color: '#ff2222', icon: 'insane' },
      ];
      const diffY = H * 0.42;
      for (let i = 0; i < diffs.length; i++) {
        const selected = menuSelection === i;
        const current = settings.difficulty === diffs[i].name.toLowerCase();
        const y = diffY + i * 55;
        
        if (selected) {
          ctx.fillStyle = `${diffs[i].color}22`;
          ctx.fillRect(W/2 - 200, y - 20, 400, 50);
          ctx.strokeStyle = diffs[i].color;
          ctx.lineWidth = 2;
          ctx.strokeRect(W/2 - 200, y - 20, 400, 50);
        }
        
        // Current difficulty checkmark
        if (current) {
          ctx.fillStyle = diffs[i].color;
          ctx.font = 'bold 18px monospace';
          ctx.textAlign = 'left';
          ctx.fillText('\u2713', W/2 - 185, y + 6);
        }
        
        const iconColor = selected ? diffs[i].color : (current ? diffs[i].color : '#888');
        drawMenuIcon(diffs[i].icon, W/2 - 150, y, 22, iconColor);
        ctx.fillStyle = iconColor;
        ctx.font = `${selected ? 'bold ' : ''}20px monospace`;
        ctx.textAlign = 'left';
        ctx.fillText(diffs[i].name, W/2 - 110, y + 6);
        ctx.textAlign = 'center';
        
        if (selected) {
          ctx.fillStyle = '#999';
          ctx.font = '12px monospace';
          ctx.fillText(diffs[i].desc, W/2, y + 26);
        }
      }
      
      // Show current difficulty at bottom
      ctx.fillStyle = '#666';
      ctx.font = '13px monospace';
      ctx.fillText(`Current: ${settings.difficulty.toUpperCase()}`, W/2, H * 0.82);
      
      ctx.fillStyle = '#555';
      ctx.font = '12px monospace';
      ctx.fillText(_isTouchDev ? 'Tap to select' : 'Click / ENTER to select -- ESC to go back', W/2, H * 0.88);
      
    } else if (menuState === 'settings') {
      // ── SETTINGS SCREEN ──
      ctx.fillStyle = '#f0c040';
      ctx.font = 'bold 28px monospace';
      drawMenuIcon('settings', W/2 - 100, H * 0.28 - 4, 22, '#f0c040');
      ctx.fillText('SETTINGS', W/2, H * 0.28);
      
      const settingsItems = [
        { name: 'Screen Shake', value: settings.screenShake },
        { name: 'Particles', value: settings.particles },
        { name: 'Show FPS', value: settings.showFPS },
        { name: 'Double Jump', value: settings.doubleJump },
        { name: 'Show Timer', value: settings.showTimer },
        { name: 'Colorblind Mode', value: settings.colorblind },
        { name: 'Touch Controls \u25b6', value: 'page' },
        { name: 'BACK', value: null },
      ];
      const setY = H * 0.36;
      for (let i = 0; i < settingsItems.length; i++) {
        const selected = menuSelection === i;
        const y = setY + i * 40;
        const item = settingsItems[i];
        
        if (selected) {
          ctx.fillStyle = '#f0c04015';
          ctx.fillRect(W/2 - 200, y - 14, 400, 32);
          ctx.strokeStyle = '#f0c04088';
          ctx.lineWidth = 1;
          ctx.strokeRect(W/2 - 200, y - 14, 400, 32);
        }
        
        if (item.value === null) {
          ctx.fillStyle = selected ? '#ff8844' : '#888';
          ctx.font = `${selected ? 'bold ' : ''}16px monospace`;
          ctx.fillText('<- ' + item.name, W/2, y + 6);
        } else if (item.value === 'page') {
          ctx.fillStyle = selected ? '#88ddff' : '#6699bb';
          ctx.font = `${selected ? 'bold ' : ''}15px monospace`;
          ctx.fillText(item.name, W/2, y + 6);
        } else {
          ctx.fillStyle = selected ? '#fff' : '#aaa';
          ctx.font = `${selected ? 'bold ' : ''}15px monospace`;
          ctx.fillText(item.name, W/2 - 80, y + 6);
          // Draw toggle switch instead of text
          const toggleX = W/2 + 110;
          const toggleW = 40, toggleH = 18;
          ctx.fillStyle = item.value ? (selected ? '#88ff88' : '#448844') : (selected ? '#ff4444' : '#884444');
          ctx.beginPath();
          ctx.roundRect(toggleX - toggleW/2, y - toggleH/2 + 2, toggleW, toggleH, toggleH/2);
          ctx.fill();
          ctx.fillStyle = '#fff';
          const knobX = item.value ? toggleX + toggleW/2 - toggleH/2 : toggleX - toggleW/2 + toggleH/2;
          ctx.beginPath();
          ctx.arc(knobX, y + 2, toggleH/2 - 2, 0, Math.PI*2);
          ctx.fill();
        }
      }
      
      ctx.fillStyle = '#555';
      ctx.font = '12px monospace';
      ctx.fillText(_isTouchDev ? 'Tap to toggle' : 'Click / ENTER to toggle -- ESC Back', W/2, H * 0.88);
      
    } else if (menuState === 'touchcontrols') {
      // ── TOUCH CONTROLS CUSTOMIZATION ──
      ctx.fillStyle = '#88ddff';
      ctx.font = 'bold 24px monospace';
      ctx.fillText('TOUCH CONTROLS', W/2, H * 0.12);

      // Current preset label
      ctx.fillStyle = '#aaa';
      ctx.font = '13px monospace';
      ctx.fillText('Current: ' + (touchPresetName === 'custom' ? 'Custom' : TOUCH_PRESETS[touchPresetName]?.name || touchPresetName), W/2, H * 0.18);

      // Preset list (left side)
      const presetKeys = Object.keys(TOUCH_PRESETS);
      const tcY = H * 0.24;
      for (let i = 0; i < presetKeys.length; i++) {
        const key = presetKeys[i];
        const preset = TOUCH_PRESETS[key];
        const y = tcY + i * 32;
        const selected = touchPresetName === key;
        ctx.fillStyle = selected ? '#88ddff' : '#777';
        ctx.font = `${selected ? 'bold ' : ''}14px monospace`;
        if (selected) {
          ctx.fillStyle = '#88ddff20';
          ctx.fillRect(W/2 - 100, y - 10, 200, 24);
          ctx.strokeStyle = '#88ddff66';
          ctx.lineWidth = 1;
          ctx.strokeRect(W/2 - 100, y - 10, 200, 24);
          ctx.fillStyle = '#88ddff';
        }
        ctx.fillText(preset.name, W/2, y + 6);
      }

      // Size controls
      const sizeY = tcY + presetKeys.length * 32 + 16;
      ctx.fillStyle = '#aaa';
      ctx.font = '13px monospace';
      ctx.fillText('Move Size: ' + touchLayout.moveR, W/2, sizeY + 4);
      // - button
      ctx.fillStyle = '#ff8844';
      ctx.font = 'bold 18px monospace';
      ctx.fillText('[-]', W/2 - 60, sizeY + 5);
      ctx.fillText('[+]', W/2 + 60, sizeY + 5);

      const sizeY2 = sizeY + 28;
      ctx.fillStyle = '#aaa';
      ctx.font = '13px monospace';
      ctx.fillText('Aim Size: ' + touchLayout.aimR, W/2, sizeY2 + 4);
      ctx.fillStyle = '#ff8844';
      ctx.font = 'bold 18px monospace';
      ctx.fillText('[-]', W/2 - 60, sizeY2 + 5);
      ctx.fillText('[+]', W/2 + 60, sizeY2 + 5);

      // Reset + Back
      const resetY = sizeY2 + 32;
      ctx.fillStyle = '#ffaa44';
      ctx.font = '14px monospace';
      ctx.fillText('Reset to Default', W/2, resetY + 4);
      const backY = resetY + 32;
      ctx.fillStyle = '#ff8844';
      ctx.font = 'bold 14px monospace';
      ctx.fillText('<- BACK', W/2, backY + 4);

      // ── PREVIEW: Draw joystick positions at bottom ──
      const pvTop = H * 0.7;
      const pvH = H - pvTop - 10;
      ctx.fillStyle = '#111';
      ctx.fillRect(20, pvTop, W - 40, pvH);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.strokeRect(20, pvTop, W - 40, pvH);
      ctx.fillStyle = '#444';
      ctx.font = '11px monospace';
      ctx.fillText('Preview  --  Drag joysticks to reposition', W/2, pvTop + 14);

      // Scale positions into preview area
      const pvCenterY = pvTop + pvH / 2 + 8;
      const pvScaleX = (W - 80) / W;
      const pvScaleR = 0.5;
      const pvMCX = 40 + touchLayout.moveX * pvScaleX;
      const pvMCY = pvCenterY;
      const pvACX = 40 + touchLayout.aimX * pvScaleX;
      const pvACY = pvCenterY;

      // Draw move joystick preview
      ctx.globalAlpha = 0.5;
      ctx.strokeStyle = '#88bbff';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(pvMCX, pvMCY, touchLayout.moveR * pvScaleR, 0, Math.PI * 2); ctx.stroke();
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#88bbff';
      ctx.beginPath(); ctx.arc(pvMCX, pvMCY, 14, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#000'; ctx.font = 'bold 9px monospace';
      ctx.fillText('MOVE', pvMCX, pvMCY + 3);

      // Draw aim joystick preview
      ctx.globalAlpha = 0.5;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(pvACX, pvACY, touchLayout.aimR * pvScaleR, 0, Math.PI * 2); ctx.stroke();
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.arc(pvACX, pvACY, 14, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#000'; ctx.font = 'bold 9px monospace';
      ctx.fillText('AIM', pvACX, pvACY + 3);
      ctx.globalAlpha = 1.0;

      ctx.fillStyle = '#444';
      ctx.font = '11px monospace';
      ctx.fillText(_isTouchDev ? 'Tap preset or drag joysticks' : 'Click preset or drag joysticks -- ESC Back', W/2, H * 0.97);

    } else if (menuState === 'controls') {
      // ── CONTROLS SCREEN ──
      ctx.fillStyle = '#f0c040';
      ctx.font = 'bold 28px monospace';
      drawMenuIcon('controls', W/2 - 110, H * 0.28 - 4, 22, '#f0c040');
      ctx.fillText('CONTROLS', W/2, H * 0.28);
      
      const controls = [
        ['< > / A D', 'Move left/right'],
        ['UP / W / SPACE', 'Jump (double jump in air!)'],
        ['F / E / Click', 'Throw projectile'],
        ['ESC', 'Skip cutscenes'],
        ['CLIMB', 'Touch the big wall to climb it'],
      ];
      const ctrlY = H * 0.38;
      for (let i = 0; i < controls.length; i++) {
        const y = ctrlY + i * 38;
        // Key box
        ctx.fillStyle = '#f0c04033';
        ctx.fillRect(W/2 - 170, y - 12, 130, 24);
        ctx.strokeStyle = '#f0c04088';
        ctx.lineWidth = 1;
        ctx.strokeRect(W/2 - 170, y - 12, 130, 24);
        ctx.fillStyle = '#f0c040';
        ctx.font = 'bold 13px monospace';
        ctx.fillText(controls[i][0], W/2 - 105, y + 4);
        ctx.fillStyle = '#ccc';
        ctx.font = '13px monospace';
        ctx.textAlign = 'left';
        ctx.fillText(controls[i][1], W/2 - 20, y + 4);
        ctx.textAlign = 'center';
      }
      
      // Touch controls section
      ctx.fillStyle = '#ff8844';
      ctx.font = 'bold 14px monospace';
      ctx.fillText('-- TOUCH / MOBILE --', W/2, H * 0.70);
      ctx.fillStyle = '#ccc';
      ctx.font = '12px monospace';
      ctx.fillText('Left side: Move (flick up to jump) | Right side: Throw', W/2, H * 0.75);
      
      ctx.fillStyle = '#666';
      ctx.font = '12px monospace';
      ctx.fillText(_isTouchDev ? 'Tap anywhere to go back' : 'Click anywhere / ESC / ENTER to go back', W/2, H * 0.88);
      
    } else if (menuState === 'credits') {
      // ── CREDITS SCREEN ──
      ctx.fillStyle = '#f0c040';
      ctx.font = 'bold 28px monospace';
      drawMenuIcon('credits', W/2 - 100, H * 0.22 - 4, 22, '#f0c040');
      ctx.fillText('CREDITS', W/2, H * 0.22);
      
      // Decorative line
      ctx.strokeStyle = '#f0c04066';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(W/2 - 120, H * 0.27);
      ctx.lineTo(W/2 + 120, H * 0.27);
      ctx.stroke();
      
      ctx.fillStyle = '#f0c040';
      ctx.font = 'bold 20px monospace';
      ctx.fillText('CRUZA LA FRONTERA', W/2, H * 0.35);
      
      ctx.fillStyle = '#cc8844';
      ctx.font = '14px monospace';
      ctx.fillText('v2.0', W/2, H * 0.40);
      
      ctx.fillStyle = '#ccc';
      ctx.font = '15px monospace';
      ctx.fillText('A game about perseverance', W/2, H * 0.48);
      ctx.fillText('and the will to be free.', W/2, H * 0.53);
      
      ctx.fillStyle = '#ff8844';
      ctx.font = 'bold 14px monospace';
      ctx.fillText('-- BUILT WITH --', W/2, H * 0.63);
      ctx.fillStyle = '#aaa';
      ctx.font = '13px monospace';
      ctx.fillText('HTML5 Canvas + JavaScript', W/2, H * 0.68);
      ctx.fillText('No frameworks, no engines, just code', W/2, H * 0.73);
      
      ctx.fillStyle = '#666';
      ctx.font = '12px monospace';
      ctx.fillText(_isTouchDev ? 'Tap anywhere to go back' : 'Click anywhere / ESC / ENTER to go back', W/2, H * 0.88);
    } else if (menuState === 'cheats') {
      // ── CHEATS SCREEN ──
      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 28px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('\u26a0 CHEATS', W/2, H * 0.18);
      
      // Warning text
      ctx.fillStyle = '#ff884488';
      ctx.font = '11px monospace';
      ctx.fillText('Cheats are active during gameplay. Have fun!', W/2, H * 0.23);
      
      // Decorative line
      ctx.strokeStyle = '#ff444466';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(W/2 - 200, H * 0.26);
      ctx.lineTo(W/2 + 200, H * 0.26);
      ctx.stroke();
      
      const cheatKeys = Object.keys(cheats);
      const cheatLabels = ['GOD MODE', 'ONE HIT KILL', 'INFINITE JUMPS', 'SPEED BOOST (2X)', 'BIG PROJECTILES', 'NO COOLDOWN'];
      const cheatDescs = ['Take no damage', 'All attacks kill instantly', 'Unlimited mid-air jumps', 'Double movement speed', 'Larger & faster throws', 'No throw cooldown'];
      const cheatY = H * 0.28;
      const totalItems = cheatKeys.length + 3; // cheats + skip + watch + back
      
      for (let i = 0; i < totalItems; i++) {
        const y = cheatY + i * 38;
        const selected = cheatSelection === i;
        
        if (i < cheatKeys.length) {
          // Cheat toggle
          const isOn = cheats[cheatKeys[i]];
          
          if (selected) {
            ctx.fillStyle = '#ff444422';
            ctx.fillRect(W/2 - 220, y - 14, 440, 32);
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 1;
            ctx.strokeRect(W/2 - 220, y - 14, 440, 32);
          }
          
          // Toggle indicator
          const toggleX = W/2 - 200;
          ctx.fillStyle = isOn ? '#44ff44' : '#333';
          ctx.fillRect(toggleX, y - 6, 32, 16);
          ctx.strokeStyle = '#888';
          ctx.lineWidth = 1;
          ctx.strokeRect(toggleX, y - 6, 32, 16);
          // Toggle knob
          ctx.fillStyle = '#fff';
          ctx.fillRect(isOn ? toggleX + 18 : toggleX + 2, y - 4, 12, 12);
          
          // Label
          ctx.fillStyle = selected ? '#ff4444' : (isOn ? '#44ff44' : '#aaa');
          ctx.font = `${selected ? 'bold ' : ''}14px monospace`;
          ctx.textAlign = 'left';
          ctx.fillText(cheatLabels[i], W/2 - 150, y + 6);
          
          // Description
          ctx.fillStyle = '#666';
          ctx.font = '10px monospace';
          ctx.textAlign = 'right';
          ctx.fillText(cheatDescs[i], W/2 + 210, y + 6);
          
          // Status
          ctx.fillStyle = isOn ? '#44ff44' : '#444';
          ctx.font = 'bold 10px monospace';
          ctx.textAlign = 'center';
          ctx.fillText(isOn ? 'ON' : 'OFF', W/2 + 170, y + 6);
          
        } else if (i === cheatKeys.length) {
          // Skip to final boss button
          if (selected) {
            ctx.fillStyle = '#ff880044';
            ctx.fillRect(W/2 - 180, y - 14, 360, 32);
            ctx.strokeStyle = '#ff8800';
            ctx.lineWidth = 2;
            ctx.strokeRect(W/2 - 180, y - 14, 360, 32);
          }
          ctx.fillStyle = selected ? '#ffaa00' : '#ff8844';
          ctx.font = `bold 16px monospace`;
          ctx.textAlign = 'center';
          ctx.shadowColor = '#ff4400';
          ctx.shadowBlur = selected ? 15 : 0;
          ctx.fillText('\u26a1 SKIP TO FINAL BOSS FIGHT \u26a1', W/2, y + 6);
          ctx.shadowBlur = 0;
          
        } else if (i === cheatKeys.length + 1) {
          // Watch cutscene button
          if (selected) {
            ctx.fillStyle = '#4488ff44';
            ctx.fillRect(W/2 - 180, y - 14, 360, 32);
            ctx.strokeStyle = '#4488ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(W/2 - 180, y - 14, 360, 32);
          }
          ctx.fillStyle = selected ? '#66aaff' : '#4488ff';
          ctx.font = `bold 16px monospace`;
          ctx.textAlign = 'center';
          ctx.shadowColor = '#4488ff';
          ctx.shadowBlur = selected ? 15 : 0;
          ctx.fillText('\ud83c\udfac WATCH BOSS CUTSCENE \ud83c\udfac', W/2, y + 6);
          ctx.shadowBlur = 0;
          
        } else {
          // Back button
          ctx.fillStyle = selected ? '#f0c040' : '#888';
          ctx.font = `${selected ? 'bold ' : ''}14px monospace`;
          ctx.textAlign = 'center';
          ctx.fillText('\u25c0 BACK', W/2, y + 6);
        }
        ctx.textAlign = 'center';
      }
      
      // Active cheats count
      const activeCount = Object.values(cheats).filter(v => v).length;
      if (activeCount > 0) {
        ctx.fillStyle = '#ff4444';
        ctx.font = 'bold 12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`${activeCount} CHEAT${activeCount > 1 ? 'S' : ''} ACTIVE`, W/2, H * 0.93);
      }
      
      ctx.fillStyle = '#555';
      ctx.font = '11px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(_isTouchDev ? '< Tap to go back' : 'ESC to go back', W/2, H * 0.97);
    }
  }

  // ── TUTORIAL SCREEN ──
  if (state === 'tutorial') {
    // Draw same bg as menu
    ctx.fillStyle = '#0a0515';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);
    
    ctx.textAlign = 'center';
    ctx.fillStyle = '#f0c040';
    ctx.font = 'bold 30px monospace';
    ctx.fillText('HOW TO PLAY', W/2, H * 0.12);
    
    // Page indicator dots
    for (let i = 0; i < 5; i++) {
      ctx.fillStyle = i === tutorialPage ? '#f0c040' : '#444';
      ctx.beginPath();
      ctx.arc(W/2 - 40 + i * 20, H * 0.17, 5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    const tutPages = [
      {
        title: 'MOVEMENT',
        lines: [
          'Use < > Arrow Keys or A/D to move',
          'You are trying to reach the border wall!',
          'Dodge guards and their bullets along the way.',
          '',
          'Run fast and stay alive!',
        ],
        icon: 'move',
      },
      {
        title: 'JUMPING',
        lines: [
          _isTouchDev ? 'Flick the move joystick UP to jump' : 'Press UP, W, or SPACE to jump',
          'Jump over walls and onto platforms.',
          '',
          '>> YOU CAN DOUBLE JUMP! <<',
          _isTouchDev ? 'Flick down then up again in mid-air!' : 'Press jump again in mid-air for a second jump!',
          'A blue ring appears when you double jump.',
        ],
        icon: 'jump',
      },
      {
        title: 'COMBAT',
        lines: [
          'Press F or E to throw projectiles at enemies.',
          'Click the mouse to throw too!',
          'Hit guards to take them out.',
          '',
          'You will face powerful BOSSES later!',
          'Bosses have multiple attack phases.',
        ],
        icon: 'combat',
      },
      {
        title: 'THE WALL',
        lines: [
          'At the end of the level is THE BIG WALL.',
          'Touch it and hold UP to climb it!',
          '',
          'Reach the top to trigger the boss fight.',
          'The wall is your gateway to freedom!',
        ],
        icon: 'wall',
      },
      {
        title: 'TIPS',
        lines: [
          `Difficulty: ${settings.difficulty.toUpperCase()}`,
          `You have ${getDiffMult().playerHp} HP`,
          settings.doubleJump ? 'Double Jump: ENABLED' : 'Double Jump: DISABLED',
          '',
          'Your HP resets at each new boss!',
          'Press ESC to skip any cutscene.',
          'Good luck, amigo! Buena suerte!',
        ],
        icon: 'tip',
      },
    ];
    
    const page = tutPages[tutorialPage];
    
    // Page title with icon
    if (typeof drawMenuIcon === 'function') {
      drawMenuIcon(page.icon, W/2 - 100, H * 0.3 - 4, 22, '#ff8844');
    }
    ctx.fillStyle = '#ff8844';
    ctx.font = 'bold 26px monospace';
    ctx.fillText(page.title, W/2 + 10, H * 0.3);
    
    // Content lines
    ctx.font = '15px monospace';
    for (let i = 0; i < page.lines.length; i++) {
      const line = page.lines[i];
      if (line.startsWith('>>')) {
        ctx.fillStyle = '#88ccff';
        ctx.font = 'bold 17px monospace';
      } else if (line === '') {
        continue;
      } else {
        ctx.fillStyle = '#ccc';
        ctx.font = '15px monospace';
      }
      ctx.fillText(line, W/2, H * 0.4 + i * 30);
    }
    
    // Navigation
    ctx.fillStyle = '#88ff88';
    ctx.font = 'bold 16px monospace';
    const blink3 = Math.sin(Date.now() / 300) > 0;
    if (blink3) {
      if (tutorialPage < 4) {
        ctx.fillText(_isTouchDev ? '[ TAP → Next ]' : '[ SPACE / ENTER → Next ]', W/2, H * 0.82);
      } else {
        ctx.fillText(_isTouchDev ? '[ TAP → START GAME! ]' : '[ SPACE / ENTER → START GAME! ]', W/2, H * 0.82);
      }
    }
    if (tutorialPage > 0) {
      ctx.fillStyle = '#888';
      ctx.font = '13px monospace';
      ctx.fillText(_isTouchDev ? '← Tap left side' : '← Previous', W/2 - 160, H * 0.82);
    }
    ctx.fillStyle = '#555';
    ctx.font = '11px monospace';
    ctx.fillText('Complete all pages to start playing', W/2, H * 0.9);
  }

  if (state === 'won') {
    ctx.fillStyle = '#000000bb';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#44ff88';
    ctx.font = 'bold 40px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('¡LO LOGRASTE!', W / 2, H / 2 - 60);

    ctx.fillStyle = '#ffdd44';
    ctx.font = '18px monospace';
    ctx.fillText('You made it across the border! ¡Bienvenido!', W / 2, H / 2 - 25);

    if (settings.showTimer) {
      ctx.fillStyle = '#aaa';
      ctx.font = '14px monospace';
      const mins = Math.floor(gameTimer / 3600);
      const secs = Math.floor((gameTimer % 3600) / 60);
      ctx.fillText(`Time: ${mins}:${secs.toString().padStart(2, '0')}`, W / 2, H / 2 + 5);
    }

    // Retry / Leave buttons
    if (restartCooldown <= 0) {
      const btnY = H / 2 + 30;
      const btnW = 160, btnH = 48;
      // Retry button
      const retryHover = mpRetrySelection === 0;
      ctx.fillStyle = retryHover ? '#44ff8844' : '#ffffff11';
      ctx.fillRect(W/2 - btnW - 10, btnY, btnW, btnH);
      ctx.strokeStyle = retryHover ? '#44ff88' : '#888';
      ctx.lineWidth = 2;
      ctx.strokeRect(W/2 - btnW - 10, btnY, btnW, btnH);
      ctx.fillStyle = retryHover ? '#44ff88' : '#ccc';
      ctx.font = 'bold 18px monospace';
      ctx.fillText('RETRY', W/2 - btnW/2 - 10, btnY + 31);

      // Leave button
      const leaveHover = mpRetrySelection === 1;
      ctx.fillStyle = leaveHover ? '#ff444444' : '#ffffff11';
      ctx.fillRect(W/2 + 10, btnY, btnW, btnH);
      ctx.strokeStyle = leaveHover ? '#ff4444' : '#888';
      ctx.strokeRect(W/2 + 10, btnY, btnW, btnH);
      ctx.fillStyle = leaveHover ? '#ff4444' : '#ccc';
      ctx.fillText('LEAVE', W/2 + btnW/2 + 10, btnY + 31);

      // MP retry votes
      if (mpEnabled) {
        const totalPlayers = Object.keys(roomPlayers).length;
        const retryCount = Object.keys(mpRetryVotes).length;
        ctx.fillStyle = '#88ccff';
        ctx.font = '12px monospace';
        ctx.fillText(`Retry votes: ${retryCount}/${totalPlayers}`, W/2, btnY + 68);
        if (mpRetryVotes[myUid()]) {
          ctx.fillStyle = '#88ff88';
          ctx.fillText('✓ You voted to retry', W/2, btnY + 86);
        }
      }
    }
  }

  if (state === 'dead') {
    ctx.fillStyle = '#000000bb';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#ff4444';
    ctx.font = 'bold 36px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('¡ATRAPADO!', W / 2, H / 2 - 60);

    ctx.fillStyle = '#ccc';
    ctx.font = '16px monospace';
    if (mpEnabled) {
      ctx.fillText('All players have been caught!', W / 2, H / 2 - 25);
    } else {
      ctx.fillText('La migra te atrapó! Border patrol got you!', W / 2, H / 2 - 25);
    }

    ctx.fillStyle = '#888';
    ctx.font = '12px monospace';
    ctx.fillText(`Difficulty: ${settings.difficulty.toUpperCase()}`, W / 2, H / 2 + 0);

    // Retry / Leave buttons
    if (restartCooldown <= 0) {
      const btnY = H / 2 + 20;
      const btnW = 160, btnH = 48;
      // Retry button
      const retryHover = mpRetrySelection === 0;
      ctx.fillStyle = retryHover ? '#44ff8844' : '#ffffff11';
      ctx.fillRect(W/2 - btnW - 10, btnY, btnW, btnH);
      ctx.strokeStyle = retryHover ? '#44ff88' : '#888';
      ctx.lineWidth = 2;
      ctx.strokeRect(W/2 - btnW - 10, btnY, btnW, btnH);
      ctx.fillStyle = retryHover ? '#44ff88' : '#ccc';
      ctx.font = 'bold 18px monospace';
      ctx.fillText('RETRY', W/2 - btnW/2 - 10, btnY + 31);

      // Leave button
      const leaveHover = mpRetrySelection === 1;
      ctx.fillStyle = leaveHover ? '#ff444444' : '#ffffff11';
      ctx.fillRect(W/2 + 10, btnY, btnW, btnH);
      ctx.strokeStyle = leaveHover ? '#ff4444' : '#888';
      ctx.strokeRect(W/2 + 10, btnY, btnW, btnH);
      ctx.fillStyle = leaveHover ? '#ff4444' : '#ccc';
      ctx.fillText('LEAVE', W/2 + btnW/2 + 10, btnY + 31);

      // MP retry votes
      if (mpEnabled) {
        const totalPlayers = Object.keys(roomPlayers).length;
        const retryCount = Object.keys(mpRetryVotes).length;
        ctx.fillStyle = '#88ccff';
        ctx.font = '12px monospace';
        ctx.fillText(`Retry votes: ${retryCount}/${totalPlayers}`, W/2, btnY + 68);
        if (mpRetryVotes[myUid()]) {
          ctx.fillStyle = '#88ff88';
          ctx.fillText('✓ You voted to retry', W/2, btnY + 86);
        }
      }
    }
  }

  // Spectator overlay
  if (mpSpectating) {
    ctx.fillStyle = '#00000066';
    ctx.fillRect(0, 0, W, 50);
    ctx.fillRect(0, H - 48, W, 48);

    // Top bar — "SPECTATING" label + player name
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ff6666';
    ctx.font = 'bold 14px monospace';
    ctx.fillText('☠ YOU DIED — SPECTATING ☠', W / 2, 18);

    const aliveList = getAlivePlayerList();
    let targetName = '???';
    if (mpSpectateTarget && roomPlayers[mpSpectateTarget]) {
      targetName = roomPlayers[mpSpectateTarget].username || mpSpectateTarget.substring(0, 6);
    }
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 16px monospace';
    ctx.fillText(targetName, W / 2, 40);

    // Bottom bar — controls hint + alive count
    if (_isTouchDev && aliveList.length > 1) {
      // Draw tappable arrow buttons for touch users
      ctx.fillStyle = '#ffffff22';
      ctx.fillRect(0, H - 48, 90, 48);
      ctx.fillRect(W - 90, H - 48, 90, 48);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 28px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('◀', 45, H - 16);
      ctx.fillText('▶', W - 45, H - 16);
    }
    ctx.textAlign = 'center';
    ctx.fillStyle = '#aaaaaa';
    ctx.font = '12px monospace';
    ctx.fillText(_isTouchDev ? 'TAP ARROWS TO SWITCH' : '← A / D → to switch players', W / 2, H - 30);
    ctx.fillStyle = '#88ff88';
    ctx.font = '11px monospace';
    ctx.fillText(`${aliveList.length} player${aliveList.length !== 1 ? 's' : ''} alive`, W / 2, H - 12);
  }

  ctx.restore();

  // ── OVERLAY HUD (outside camera transform) ──
  // FPS counter — positioned below HP bar to avoid overlap
  if (settings.showFPS) {
    if (!window._fpsData) window._fpsData = { frames: 0, last: Date.now(), fps: 60 };
    window._fpsData.frames++;
    const now = Date.now();
    if (now - window._fpsData.last >= 1000) {
      window._fpsData.fps = window._fpsData.frames;
      window._fpsData.frames = 0;
      window._fpsData.last = now;
    }
    const fpsY = (state === 'playing' || state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight') ? 52 : 16;
    ctx.fillStyle = '#88ff88';
    ctx.font = '11px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`FPS: ${window._fpsData.fps}`, 10, fpsY);
  }
  
  // Game timer display — positioned below boss bar / fullscreen btn to avoid overlap
  if (settings.showTimer && (state === 'playing' || state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight')) {
    const mins = Math.floor(gameTimer / 3600);
    const secs = Math.floor((gameTimer % 3600) / 60);
    const ms = Math.floor((gameTimer % 60) / 60 * 100);
    ctx.fillStyle = '#ffffff88';
    ctx.font = '12px monospace';
    ctx.textAlign = 'right';
    ctx.fillText(`${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`, W - 50, 52);
  }
  
  // Double jump indicator during gameplay
  if ((state === 'playing' || state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight') && settings.doubleJump) {
    const jumpColor = player.jumpsLeft > 0 ? '#88ccff' : '#444';
    ctx.fillStyle = jumpColor;
    ctx.font = '11px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`Jumps: ${'●'.repeat(player.jumpsLeft)}${'○'.repeat(player.maxJumps - player.jumpsLeft)}`, _isTouchDev ? getMoveCenterX() - 30 : 10, _isTouchDev ? getMoveCenterY() - getMoveRadius() - 35 : H - 15);
  }

  // Cheats active indicator — positioned to avoid boss HP bars
  const activeCheats = Object.entries(cheats).filter(([k,v]) => v);
  if (activeCheats.length > 0 && state !== 'menu') {
    ctx.save();
    ctx.globalAlpha = 0.7;
    const cheatsY = (state === 'bossfight' || state === 'epsteinfight' || state === 'fusionfight' || state === 'splitfight') ? 88 : 46;
    ctx.fillStyle = '#ff000088';
    ctx.fillRect(W - 160, cheatsY, 116, 14 + activeCheats.length * 13);
    ctx.strokeStyle = '#ff4444';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 160, cheatsY, 116, 14 + activeCheats.length * 13);
    ctx.fillStyle = '#ff4444';
    ctx.font = 'bold 10px monospace';
    ctx.textAlign = 'right';
    ctx.fillText('CHEATS ON', W - 48, cheatsY + 11);
    ctx.font = '9px monospace';
    ctx.fillStyle = '#ffaa44';
    const cheatShort = {godMode:'GOD',oneHitKill:'1HIT',infiniteJumps:'INF-J',speedBoost:'SPD',bigProjectiles:'BIG-P',noCooldown:'NO-CD'};
    activeCheats.forEach(([k], i) => {
      ctx.fillText(cheatShort[k] || k, W - 48, cheatsY + 23 + i * 13);
    });
    ctx.restore();
  }

  // Fullscreen button (always visible, top-right) — 44x44 for touch
  const isFS = !!(document.fullscreenElement || document.webkitFullscreenElement);
  ctx.save();
  ctx.globalAlpha = 0.5;
  ctx.fillStyle = '#000';
  ctx.fillRect(W - 46, 2, 44, 44);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.strokeRect(W - 46, 2, 44, 44);
  // Draw expand/collapse icon
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  if (!isFS) {
    const cx = W - 24, cy = 24;
    // Top-left corner
    ctx.beginPath(); ctx.moveTo(cx-7, cy-4); ctx.lineTo(cx-7, cy-7); ctx.lineTo(cx-4, cy-7); ctx.stroke();
    // Top-right corner
    ctx.beginPath(); ctx.moveTo(cx+4, cy-7); ctx.lineTo(cx+7, cy-7); ctx.lineTo(cx+7, cy-4); ctx.stroke();
    // Bottom-left corner
    ctx.beginPath(); ctx.moveTo(cx-7, cy+4); ctx.lineTo(cx-7, cy+7); ctx.lineTo(cx-4, cy+7); ctx.stroke();
    // Bottom-right corner
    ctx.beginPath(); ctx.moveTo(cx+4, cy+7); ctx.lineTo(cx+7, cy+7); ctx.lineTo(cx+7, cy+4); ctx.stroke();
  } else {
    const cx = W - 24, cy = 24;
    ctx.beginPath(); ctx.moveTo(cx-3, cy-8); ctx.lineTo(cx-3, cy-3); ctx.lineTo(cx-8, cy-3); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx+3, cy-8); ctx.lineTo(cx+3, cy-3); ctx.lineTo(cx+8, cy-3); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx-3, cy+8); ctx.lineTo(cx-3, cy+3); ctx.lineTo(cx-8, cy+3); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx+3, cy+8); ctx.lineTo(cx+3, cy+3); ctx.lineTo(cx+8, cy+3); ctx.stroke();
  }
  ctx.restore();

  // Draw MP toast notifications (visible in ALL states)
  if (mpToasts.length > 0) {
    ctx.save();
    for (let i = 0; i < mpToasts.length; i++) {
      const t = mpToasts[i];
      const alpha = Math.min(1, t.life / 30); // fade out last 0.5s
      ctx.globalAlpha = alpha;
      ctx.font = 'bold 16px Arial';
      const tw = ctx.measureText(t.text).width;
      const tx = W / 2 - tw / 2 - 12;
      const ty = 50 + i * 32;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.beginPath();
      ctx.roundRect(tx, ty - 16, tw + 24, 28, 8);
      ctx.fill();
      ctx.fillStyle = t.color;
      ctx.fillText(t.text, W / 2 - tw / 2, ty + 2);
    }
    ctx.restore();
  }

  // ── Performance Mode Prompt (iPad/mobile) ──
  if (_showPerfPrompt) {
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
    const boxW = Math.min(420, W - 40);
    const boxH = 220;
    const bx = W/2 - boxW/2, by = H/2 - boxH/2;
    ctx.fillStyle = '#1a1a2e';
    ctx.beginPath(); ctx.roundRect(bx, by, boxW, boxH, 16); ctx.fill();
    ctx.strokeStyle = '#f0c040';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(bx, by, boxW, boxH, 16); ctx.stroke();
    ctx.fillStyle = '#f0c040';
    ctx.font = 'bold 20px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('📱 Performance Mode', W/2, by + 40);
    ctx.fillStyle = '#ccc';
    ctx.font = '14px monospace';
    ctx.fillText('We detected you\'re on a', W/2, by + 75);
    ctx.fillText('mobile/tablet device.', W/2, by + 95);
    ctx.fillText('Turn on Performance Mode?', W/2, by + 120);
    ctx.fillStyle = '#888';
    ctx.font = '11px monospace';
    ctx.fillText('(Disables particles & screen shake)', W/2, by + 142);
    // YES button
    const yBtnX = W/2 - 110, yBtnY = by + 160, btnW = 100, btnH = 36;
    ctx.fillStyle = '#22aa44';
    ctx.beginPath(); ctx.roundRect(yBtnX, yBtnY, btnW, btnH, 8); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 15px monospace';
    ctx.fillText('YES', yBtnX + btnW/2, yBtnY + 24);
    // NO button
    const nBtnX = W/2 + 10;
    ctx.fillStyle = '#aa2222';
    ctx.beginPath(); ctx.roundRect(nBtnX, yBtnY, btnW, btnH, 8); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.fillText('NO', nBtnX + btnW/2, yBtnY + 24);
    // Store button rects for click handling
    window._perfYesBtn = { x: yBtnX, y: yBtnY, w: btnW, h: btnH };
    window._perfNoBtn = { x: nBtnX, y: yBtnY, w: btnW, h: btnH };
    ctx.restore();
  }
}
let _lastFrameTime = 0;
let _lastSyncTime = 0;
let _lastEnemySyncTime = 0;
function loop(timestamp) {
  if (!_lastFrameTime) _lastFrameTime = timestamp;
  const elapsed = timestamp - _lastFrameTime;
  _lastFrameTime = timestamp;
  // Run multiple ticks per frame on slow devices (iPad 30fps) to maintain game speed
  // Cap at 3 ticks to prevent performance death spiral
  const ticks = Math.min(Math.max(1, Math.round(elapsed / 16.67)), 3);
  try {
    for (let i = 0; i < ticks; i++) update();
    draw();
  } catch (e) { console.error('Game loop error:', e); }
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
